; ModuleID = 'samples/579.bc'
source_filename = "../spack-src/test/x86/avx512/rorv.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.anon = type { ptr, ptr }
%struct.anon.0 = type { [4 x i32], [4 x i32], [4 x i32] }
%struct.anon.1 = type { [4 x i32], i8, [4 x i32], [4 x i32], [4 x i32] }
%struct.anon.2 = type { i8, [4 x i32], [4 x i32], [4 x i32] }
%struct.anon.3 = type { [8 x i32], [8 x i32], [8 x i32] }
%struct.anon.4 = type { [8 x i32], i8, [8 x i32], [8 x i32], [8 x i32] }
%struct.anon.5 = type { i8, [8 x i32], [8 x i32], [8 x i32] }
%struct.anon.6 = type { [16 x i32], [16 x i32], [16 x i32] }
%struct.anon.7 = type { [16 x i32], i16, [16 x i32], [16 x i32], [16 x i32] }
%struct.anon.8 = type { i16, [16 x i32], [16 x i32], [16 x i32] }
%struct.anon.9 = type { [2 x i64], [2 x i64], [2 x i64] }
%struct.anon.10 = type { [2 x i64], i8, [2 x i64], [2 x i64], [2 x i64] }
%struct.anon.11 = type { i8, [2 x i64], [2 x i64], [2 x i64] }
%struct.anon.12 = type { [4 x i64], [4 x i64], [4 x i64] }
%struct.anon.13 = type { [4 x i64], i8, [4 x i64], [4 x i64], [4 x i64] }
%struct.anon.14 = type { i8, [4 x i64], [4 x i64], [4 x i64] }
%struct.anon.15 = type { [8 x i64], [8 x i64], [8 x i64] }
%struct.anon.16 = type { [8 x i64], i8, [8 x i64], [8 x i64], [8 x i64] }
%struct.anon.17 = type { i8, [8 x i64], [8 x i64], [8 x i64] }
%struct.__loadu_si128 = type { <2 x i64> }
%union.simde__m128i_private = type { <16 x i8> }
%struct.__storeu_si128 = type { <2 x i64> }
%struct.__va_list_tag = type { i32, i32, ptr, ptr }
%union.simde__m256i_private = type { <32 x i8> }
%struct.simde_mm512_loadu_si512_s = type { <8 x i64> }
%union.simde__m512i_private = type { <64 x i8> }

@stdout = external global ptr, align 8
@.str = private unnamed_addr constant [8 x i8] c"1..%zu\0A\00", align 1
@test_suite_tests = internal constant [18 x %struct.anon] [%struct.anon { ptr @test_simde_mm_rorv_epi32, ptr @.str.3 }, %struct.anon { ptr @test_simde_mm_mask_rorv_epi32, ptr @.str.4 }, %struct.anon { ptr @test_simde_mm_maskz_rorv_epi32, ptr @.str.5 }, %struct.anon { ptr @test_simde_mm256_rorv_epi32, ptr @.str.6 }, %struct.anon { ptr @test_simde_mm256_mask_rorv_epi32, ptr @.str.7 }, %struct.anon { ptr @test_simde_mm256_maskz_rorv_epi32, ptr @.str.8 }, %struct.anon { ptr @test_simde_mm512_rorv_epi32, ptr @.str.9 }, %struct.anon { ptr @test_simde_mm512_mask_rorv_epi32, ptr @.str.10 }, %struct.anon { ptr @test_simde_mm512_maskz_rorv_epi32, ptr @.str.11 }, %struct.anon { ptr @test_simde_mm_rorv_epi64, ptr @.str.12 }, %struct.anon { ptr @test_simde_mm_mask_rorv_epi64, ptr @.str.13 }, %struct.anon { ptr @test_simde_mm_maskz_rorv_epi64, ptr @.str.14 }, %struct.anon { ptr @test_simde_mm256_rorv_epi64, ptr @.str.15 }, %struct.anon { ptr @test_simde_mm256_mask_rorv_epi64, ptr @.str.16 }, %struct.anon { ptr @test_simde_mm256_maskz_rorv_epi64, ptr @.str.17 }, %struct.anon { ptr @test_simde_mm512_rorv_epi64, ptr @.str.18 }, %struct.anon { ptr @test_simde_mm512_mask_rorv_epi64, ptr @.str.19 }, %struct.anon { ptr @test_simde_mm512_maskz_rorv_epi64, ptr @.str.20 }], align 16
@.str.1 = private unnamed_addr constant [20 x i8] c"not ok %zu rorv/%s\0A\00", align 1
@.str.2 = private unnamed_addr constant [16 x i8] c"ok %zu rorv/%s\0A\00", align 1
@.str.3 = private unnamed_addr constant [14 x i8] c"mm_rorv_epi32\00", align 1
@.str.4 = private unnamed_addr constant [19 x i8] c"mm_mask_rorv_epi32\00", align 1
@.str.5 = private unnamed_addr constant [20 x i8] c"mm_maskz_rorv_epi32\00", align 1
@.str.6 = private unnamed_addr constant [17 x i8] c"mm256_rorv_epi32\00", align 1
@.str.7 = private unnamed_addr constant [22 x i8] c"mm256_mask_rorv_epi32\00", align 1
@.str.8 = private unnamed_addr constant [23 x i8] c"mm256_maskz_rorv_epi32\00", align 1
@.str.9 = private unnamed_addr constant [17 x i8] c"mm512_rorv_epi32\00", align 1
@.str.10 = private unnamed_addr constant [22 x i8] c"mm512_mask_rorv_epi32\00", align 1
@.str.11 = private unnamed_addr constant [23 x i8] c"mm512_maskz_rorv_epi32\00", align 1
@.str.12 = private unnamed_addr constant [14 x i8] c"mm_rorv_epi64\00", align 1
@.str.13 = private unnamed_addr constant [19 x i8] c"mm_mask_rorv_epi64\00", align 1
@.str.14 = private unnamed_addr constant [20 x i8] c"mm_maskz_rorv_epi64\00", align 1
@.str.15 = private unnamed_addr constant [17 x i8] c"mm256_rorv_epi64\00", align 1
@.str.16 = private unnamed_addr constant [22 x i8] c"mm256_mask_rorv_epi64\00", align 1
@.str.17 = private unnamed_addr constant [23 x i8] c"mm256_maskz_rorv_epi64\00", align 1
@.str.18 = private unnamed_addr constant [17 x i8] c"mm512_rorv_epi64\00", align 1
@.str.19 = private unnamed_addr constant [22 x i8] c"mm512_mask_rorv_epi64\00", align 1
@.str.20 = private unnamed_addr constant [23 x i8] c"mm512_maskz_rorv_epi64\00", align 1
@test_simde_mm_rorv_epi32.test_vec = internal constant [8 x %struct.anon.0] [%struct.anon.0 { [4 x i32] [i32 -69354328, i32 -1197998948, i32 293111754, i32 1832942147], [4 x i32] [i32 -411975625, i32 1192461355, i32 1780271933, i32 1641329593], [4 x i32] [i32 -1149677065, i32 -1818815745, i32 -1950073264, i32 -1606606410] }, %struct.anon.0 { [4 x i32] [i32 207401327, i32 2009396397, i32 -1098367621, i32 -282277449], [4 x i32] [i32 -1261003383, i32 1593567521, i32 1858607028, i32 986684618], [4 x i32] [i32 -1215943080, i32 -1142785450, i32 -2083013656, i32 1845218098] }, %struct.anon.0 { [4 x i32] [i32 -96064435, i32 -1687090656, i32 -10880441, i32 1290700227], [4 x i32] [i32 1140900898, i32 1638071213, i32 -573609198, i32 1427611399], [4 x i32] [i32 2123467539, i32 1359272840, i32 2123497430, i32 -2036736757] }, %struct.anon.0 { [4 x i32] [i32 -347120181, i32 -1350123161, i32 2125389755, i32 -2016764827], [4 x i32] [i32 231459424, i32 -680628539, i32 -525058343, i32 -1472869411], [4 x i32] [i32 -347120181, i32 1031550475, i32 1466949055, i32 1045750572] }, %struct.anon.0 { [4 x i32] [i32 -1869380312, i32 20912454, i32 1568665080, i32 -370849399], [4 x i32] [i32 -654921709, i32 -139500514, i32 2144887970, i32 1478954287], [4 x i32] [i32 1889866258, i32 83649816, i32 392166270, i32 -1827417142] }, %struct.anon.0 { [4 x i32] [i32 -655836526, i32 -858183725, i32 -1658234860, i32 -1266282847], [4 x i32] [i32 -577995585, i32 -2083177248, i32 -821908064, i32 1294412474], [4 x i32] [i32 -1311673051, i32 -858183725, i32 -1658234860, i32 562276461] }, %struct.anon.0 { [4 x i32] [i32 -1205530652, i32 1250230070, i32 -102257321, i32 2074963388], [4 x i32] [i32 -900187415, i32 374156662, i32 -1780133926, i32 1591872889], [4 x i32] [i32 -228846969, i32 335337770, i32 2045466110, i32 -692658627] }, %struct.anon.0 { [4 x i32] [i32 1393952540, i32 1587386886, i32 56067399, i32 -595720974], [4 x i32] [i32 -1264134338, i32 -540347644, i32 -1133203390, i32 -652585283], [4 x i32] [i32 1280842865, i32 1709824416, i32 -1059724975, i32 -470800490] }], align 16
@.str.21 = private unnamed_addr constant [36 x i8] c"../spack-src/test/x86/avx512/rorv.c\00", align 1
@.str.22 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.23 = private unnamed_addr constant [38 x i8] c"simde_x_mm_loadu_epi32(test_vec[i].r)\00", align 1
@.str.24 = private unnamed_addr constant [56 x i8] c"%s:%d: assertion failed: %s[%zu] == %s[%zu] (%d == %d)\0A\00", align 1
@stderr = external global ptr, align 8
@test_simde_mm_mask_rorv_epi32.test_vec = internal constant [8 x %struct.anon.1] [%struct.anon.1 { [4 x i32] [i32 161852646, i32 -1964798349, i32 1283013027, i32 1063349850], i8 -23, [4 x i32] [i32 -609719213, i32 995443397, i32 -1712393867, i32 1082183316], [4 x i32] [i32 45320564, i32 -1515897492, i32 620753590, i32 -1492304301], [4 x i32] [i32 -2033893958, i32 -1964798349, i32 1283013027, i32 433227792] }, %struct.anon.1 { [4 x i32] [i32 1870837162, i32 1823135735, i32 1543936200, i32 -610498969], i8 15, [4 x i32] [i32 -1921196721, i32 1950556546, i32 1606969377, i32 722104181], [4 x i32] [i32 -937264655, i32 -1131376860, i32 455339413, i32 -651493751], [4 x i32] [i32 1856489150, i32 658780696, i32 1128336126, i32 -1164606153] }, %struct.anon.1 { [4 x i32] [i32 1583785691, i32 -372069944, i32 -2025285103, i32 -88976887], i8 -52, [4 x i32] [i32 1676722900, i32 1090038867, i32 -825682992, i32 -458579394], [4 x i32] [i32 -1297348600, i32 1975752154, i32 813583070, i32 -771982852], [4 x i32] [i32 1583785691, i32 -372069944, i32 992235331, i32 1252664302] }, %struct.anon.1 { [4 x i32] [i32 -1909134277, i32 1775119769, i32 2117572672, i32 1130619194], i8 -23, [4 x i32] [i32 -1513818865, i32 58931640, i32 822064055, i32 -1670590288], [4 x i32] [i32 842398213, i32 1634901705, i32 -1214516778, i32 1671552596], [4 x i32] [i32 2100176808, i32 1775119769, i32 2117572672, i32 -854914618] }, %struct.anon.1 { [4 x i32] [i32 -1945606701, i32 1435470750, i32 -276394433, i32 1686893151], i8 -20, [4 x i32] [i32 1605736129, i32 -113961464, i32 -1873941070, i32 -211504754], [4 x i32] [i32 1167192249, i32 226813567, i32 1584165740, i32 -1085550338], [4 x i32] [i32 -1945606701, i32 1435470750, i32 -618068770, i32 -846019013] }, %struct.anon.1 { [4 x i32] [i32 1864302694, i32 -915909609, i32 -816204223, i32 549633383], i8 -83, [4 x i32] [i32 975988051, i32 1554397929, i32 2002453926, i32 1356667472], [4 x i32] [i32 -1905832903, i32 1808740533, i32 1204985738, i32 -1242172831], [4 x i32] [i32 372418973, i32 -915909609, i32 1771951809, i32 678333736] }, %struct.anon.1 { [4 x i32] [i32 1106190680, i32 43947355, i32 -361104998, i32 1295734291], i8 -93, [4 x i32] [i32 -749151326, i32 1230881706, i32 -2018794347, i32 -1142988647], [4 x i32] [i32 -468311729, i32 -1199630145, i32 -389322351, i32 1200298148], [4 x i32] [i32 -1220172111, i32 -1833203884, i32 -361104998, i32 1295734291] }, %struct.anon.1 { [4 x i32] [i32 -1642404877, i32 1005025190, i32 -1245539813, i32 1097900786], i8 -61, [4 x i32] [i32 -1618860410, i32 238041765, i32 515053573, i32 -2045642077], [4 x i32] [i32 -1960005868, i32 698771351, i32 -870556886, i32 1385127371], [4 x i32] [i32 577268216, i32 1618299420, i32 -1245539813, i32 1097900786] }], align 16
@test_simde_mm_maskz_rorv_epi32.test_vec = internal constant [8 x %struct.anon.2] [%struct.anon.2 { i8 -125, [4 x i32] [i32 1260974353, i32 978335521, i32 -455250198, i32 804807808], [4 x i32] [i32 -121207920, i32 -2061307863, i32 1766911500, i32 -1897028995], [4 x i32] [i32 -250524888, i32 -1868748773, i32 0, i32 0] }, %struct.anon.2 { i8 -109, [4 x i32] [i32 1286986005, i32 -1741230295, i32 806886092, i32 -1782495470], [4 x i32] [i32 -20989682, i32 -922073893, i32 927363988, i32 1993004128], [4 x i32] [i32 1683305175, i32 115205427, i32 0, i32 0] }, %struct.anon.2 { i8 -83, [4 x i32] [i32 1859568255, i32 322662137, i32 -836342906, i32 -438518996], [4 x i32] [i32 -1094657414, i32 1465092580, i32 -1548186929, i32 -732942764], [4 x i32] [i32 -1246715941, i32 0, i32 -686973876, i32 -877474211] }, %struct.anon.2 { i8 -16, [4 x i32] [i32 -1779875289, i32 -383976067, i32 -568989149, i32 -1604715578], [4 x i32] [i32 1166284731, i32 -199959702, i32 -1052133229, i32 800201992], [4 x i32] zeroinitializer }, %struct.anon.2 { i8 95, [4 x i32] [i32 -1730296421, i32 -876886303, i32 -695100709, i32 177353203], [4 x i32] [i32 -1871325259, i32 -1557894677, i32 -810752590, i32 858774423], [4 x i32] [i32 -299049786, i32 -600213640, i32 1723266468, i32 610526741] }, %struct.anon.2 { i8 -96, [4 x i32] [i32 -763245812, i32 565005447, i32 236225757, i32 -305979882], [4 x i32] [i32 -36154221, i32 1571781752, i32 66420520, i32 -1163646802], [4 x i32] zeroinitializer }, %struct.anon.2 { i8 -13, [4 x i32] [i32 1920633893, i32 -1118856391, i32 -825008465, i32 1969340449], [4 x i32] [i32 367877785, i32 -1925362930, i32 1748713536, i32 173798884], [4 x i32] [i32 1028002489, i32 1827075390, i32 0, i32 0] }, %struct.anon.2 { i8 -127, [4 x i32] [i32 1908047062, i32 690059467, i32 206303051, i32 -1348091824], [4 x i32] [i32 -105006418, i32 926501623, i32 2048696709, i32 -755292420], [4 x i32] [i32 -212220183, i32 0, i32 0, i32 0] }], align 16
@test_simde_mm256_rorv_epi32.test_vec = internal constant [8 x %struct.anon.3] [%struct.anon.3 { [8 x i32] [i32 977838916, i32 -1754965992, i32 -522854253, i32 2096133933, i32 1162987586, i32 1027930881, i32 1330913981, i32 -542701157], [8 x i32] [i32 -988155987, i32 -614695096, i32 -1933889185, i32 -368530520, i32 1966037364, i32 313750613, i32 828442518, i32 -1122957296], [8 x i32] [i32 438424133, i32 412575064, i32 -1045708505, i32 763162743, i32 478422101, i32 668469738, i32 1351284029, i32 161210279] }, %struct.anon.3 { [8 x i32] [i32 1082272504, i32 152821417, i32 -1214917105, i32 -157114750, i32 1282134519, i32 -597811643, i32 906870821, i32 -1057808696], [8 x i32] [i32 -234850743, i32 1694178132, i32 1947963890, i32 644529455, i32 -730606193, i32 431018484, i32 1515175569, i32 622478300], [8 x i32] [i32 2082488597, i32 -1108701039, i32 1971580389, i32 1023798597, i32 -1544644393, i32 -505127483, i32 -535651578, i32 254930060] }, %struct.anon.3 { [8 x i32] [i32 219683769, i32 678499126, i32 -744714844, i32 -637925814, i32 -793874980, i32 -790012354, i32 -114673380, i32 891176060], [8 x i32] [i32 -1774045601, i32 -289491894, i32 -1950196927, i32 1030077537, i32 1728910121, i32 -1908934799, i32 -1400413904, i32 98674086], [8 x i32] [i32 439367538, i32 -846586812, i32 1775126226, i32 1828520741, i32 -295151818, i32 -1356896140, i32 958200106, i32 -254510831] }, %struct.anon.3 { [8 x i32] [i32 647701468, i32 403987159, i32 379901621, i32 -1152120430, i32 -1927061220, i32 -2011473320, i32 1647616700, i32 610735432], [8 x i32] [i32 273285945, i32 304701021, i32 -953627339, i32 -226263850, i32 914335454, i32 -1128293632, i32 -2061569219, i32 1118406153], [8 x i32] [i32 1301409299, i32 -1063070024, i32 649439413, i32 1344686829, i32 881689714, i32 -2011473320, i32 296031715, i32 -1542311030] }, %struct.anon.3 { [8 x i32] [i32 -430771319, i32 -2013758638, i32 508436552, i32 2064699805, i32 2024902775, i32 1748267051, i32 1844335460, i32 1655674841], [8 x i32] [i32 -582483573, i32 -983285635, i32 -35343776, i32 -75959164, i32 -1351406972, i32 -31938406, i32 -731183365, i32 674634397], [8 x i32] [i32 1899809374, i32 1069800084, i32 508436552, i32 -676262631, i32 2005604615, i32 219941594, i32 -1110807411, i32 360496843] }, %struct.anon.3 { [8 x i32] [i32 -1727693284, i32 509503934, i32 -1608760804, i32 -1147431881, i32 1500188606, i32 -1302887497, i32 646366089, i32 -112214819], [8 x i32] [i32 -124627910, i32 -636030530, i32 1786393139, i32 -2061101625, i32 -606170844, i32 -1651689964, i32 -691858439, i32 164631247], [8 x i32] [i32 1096779558, i32 2038015736, i32 -2008837117, i32 1870083880, i32 -443109125, i32 2017164069, i32 1130480787, i32 2042360479] }, %struct.anon.3 { [8 x i32] [i32 620847719, i32 -2013325229, i32 301037898, i32 -1281943666, i32 -1131514456, i32 -1537663829, i32 -8708817, i32 -1777841361], [8 x i32] [i32 29035181, i32 1820899874, i32 -1031898829, i32 963974545, i32 922092426, i32 1339707167, i32 -1672587924, i32 1311921824], [8 x i32] [i32 322512907, i32 -503331308, i32 791233086, i32 -1949869621, i32 1781474205, i32 1219639639, i32 -754976847, i32 -1777841361] }, %struct.anon.3 { [8 x i32] [i32 -2108690848, i32 -588261464, i32 -509711024, i32 203101058, i32 910299414, i32 -846914208, i32 325702514, i32 -1973314775], [8 x i32] [i32 839692425, i32 -686883961, i32 -356930456, i32 -705178433, i32 1158363621, i32 -921530282, i32 -1914930333, i32 -1609089769], [8 x i32] [i32 809576439, i32 1371135919, i32 1356963437, i32 406202116, i32 -1313730424, i32 343245622, i32 1114454638, i32 -1019849964] }], align 16
@.str.25 = private unnamed_addr constant [41 x i8] c"simde_x_mm256_loadu_epi32(test_vec[i].r)\00", align 1
@test_simde_mm256_mask_rorv_epi32.test_vec = internal constant [8 x %struct.anon.4] [%struct.anon.4 { [8 x i32] [i32 1992212670, i32 -1795293304, i32 1402052118, i32 -240989426, i32 -943632715, i32 -1882549633, i32 -1641953554, i32 -181191625], i8 -4, [8 x i32] [i32 -259757071, i32 101128552, i32 1964268202, i32 1244268284, i32 1506406855, i32 -2109253444, i32 -1229331078, i32 179482136], [8 x i32] [i32 -2097531367, i32 -108527281, i32 1466867035, i32 1789040803, i32 1187212170, i32 1053297348, i32 133464815, i32 1242670640], [8 x i32] [i32 1992212670, i32 -1795293304, i32 -1567926962, i32 -1991950113, i32 1909879420, i32 -937134709, i32 -889885325, i32 -1374156110] }, %struct.anon.4 { [8 x i32] [i32 751570140, i32 1764054029, i32 -1799318287, i32 -1224842708, i32 -1828929074, i32 -1160722997, i32 2009252935, i32 1187107690], i8 -33, [8 x i32] [i32 -487755123, i32 752047768, i32 2035836950, i32 675745638, i32 -789325557, i32 1830268585, i32 1138200432, i32 -568124080], [8 x i32] [i32 683675792, i32 2085917542, i32 1660267771, i32 -947241797, i32 -1097368299, i32 -1691635925, i32 -1897987522, i32 -1335098848], [8 x i32] [i32 1921901293, i32 1622363482, i32 722272975, i32 149023941, i32 -1631035769, i32 -1160722997, i32 257834433, i32 -568124080] }, %struct.anon.4 { [8 x i32] [i32 2027432978, i32 -1141625664, i32 -1809978664, i32 1012639526, i32 1358623269, i32 -538171743, i32 1215220520, i32 -537339187], i8 7, [8 x i32] [i32 -54044720, i32 903184971, i32 1197238688, i32 -1234396988, i32 -1202143854, i32 1960916905, i32 -2143213147, i32 -226025438], [8 x i32] [i32 -1024504201, i32 1895351504, i32 -239578067, i32 2124883180, i32 -1976041503, i32 -587327433, i32 1666989889, i32 -698948769], [8 x i32] [i32 -1901092359, i32 -2109000235, i32 1291991779, i32 1012639526, i32 1358623269, i32 -538171743, i32 1215220520, i32 -537339187] }, %struct.anon.4 { [8 x i32] [i32 43599153, i32 913477897, i32 -785962267, i32 810536527, i32 96175822, i32 -522077794, i32 1480802041, i32 1395628321], i8 -34, [8 x i32] [i32 1508333000, i32 -230810169, i32 323030852, i32 -438210210, i32 -427563476, i32 98526151, i32 1076311975, i32 773814886], [8 x i32] [i32 -1769535793, i32 1753793828, i32 863750612, i32 1729649723, i32 172858178, i32 -1508954881, i32 -890882460, i32 2147026352], [8 x i32] [i32 43599153, i32 2133058012, i32 284442932, i32 -1137824804, i32 966850955, i32 -522077794, i32 1946317690, i32 2053516831] }, %struct.anon.4 { [8 x i32] [i32 806780940, i32 446209606, i32 -1555229592, i32 -1291164304, i32 12408833, i32 -391721852, i32 -1280078845, i32 -1640780654], i8 44, [8 x i32] [i32 -411906487, i32 2052033894, i32 1089204954, i32 1430363901, i32 668549467, i32 1932182247, i32 554032757, i32 1515037457], [8 x i32] [i32 -666779535, i32 659722573, i32 -2140717693, i32 919972059, i32 -799100951, i32 -431716239, i32 1996966246, i32 1590777069], [8 x i32] [i32 806780940, i32 446209606, i32 1209892443, i32 -1472995414, i32 12408833, i32 1634974101, i32 -1280078845, i32 -1640780654] }, %struct.anon.4 { [8 x i32] [i32 1630933780, i32 663325092, i32 -1565986618, i32 -2099741287, i32 -1655491028, i32 629381055, i32 -845313312, i32 -215191841], i8 -127, [8 x i32] [i32 -349874846, i32 -827175458, i32 1919374581, i32 1671424556, i32 -735953859, i32 1253328832, i32 1395229412, i32 282336686], [8 x i32] [i32 1358756466, i32 1008643655, i32 783189506, i32 -1382986384, i32 1250014090, i32 -543934981, i32 1697824439, i32 1299580891], [8 x i32] [i32 1431878345, i32 663325092, i32 -1565986618, i32 -2099741287, i32 -1655491028, i32 629381055, i32 -845313312, i32 444839362] }, %struct.anon.4 { [8 x i32] [i32 1218277889, i32 579124000, i32 -1320144319, i32 173990528, i32 -1873485931, i32 -865015787, i32 -2127387994, i32 -1429296983], i8 26, [8 x i32] [i32 658174571, i32 -1452778378, i32 -1909908820, i32 1478767480, i32 1869460615, i32 -954844892, i32 326145899, i32 -785573018], [8 x i32] [i32 -2064095475, i32 1882022339, i32 -201435525, i32 273359497, i32 -75515689, i32 1573033458, i32 -1821297875, i32 1533320782], [8 x i32] [i32 1218277889, i32 -718468210, i32 -1320144319, i32 -1137962471, i32 -613871906, i32 -865015787, i32 -2127387994, i32 -1429296983] }, %struct.anon.4 { [8 x i32] [i32 -908108538, i32 960040126, i32 -349423518, i32 838563930, i32 573406000, i32 1031859984, i32 1892741410, i32 -1781779057], i8 -110, [8 x i32] [i32 -1202692181, i32 -803567208, i32 757794485, i32 2086558721, i32 2039316617, i32 -241448448, i32 -796848997, i32 -2090723624], [8 x i32] [i32 238793333, i32 -253864389, i32 1562249564, i32 -270893978, i32 -43489284, i32 -856816591, i32 -392401136, i32 -76808570], [8 x i32] [i32 -908108538, i32 55653146, i32 -349423518, i32 838563930, i32 -1730672489, i32 1031859984, i32 1892741410, i32 1645054043] }], align 16
@test_simde_mm256_maskz_rorv_epi32.test_vec = internal constant [8 x %struct.anon.5] [%struct.anon.5 { i8 -80, [8 x i32] [i32 -34928217, i32 -245768984, i32 1985459962, i32 -143505520, i32 -1289130065, i32 -842795682, i32 -1873564782, i32 -1103016169], [8 x i32] [i32 1086008408, i32 36836360, i32 1534626250, i32 -2142049328, i32 -1204585638, i32 59176817, i32 -1181492830, i32 -2122853336], [8 x i32] [i32 0, i32 0, i32 0, i32 0, i32 -899945492, i32 -89168159, i32 0, i32 398344527] }, %struct.anon.5 { i8 1, [8 x i32] [i32 1175044402, i32 2098269427, i32 1867345028, i32 986369470, i32 -122977791, i32 -493179384, i32 369775681, i32 -32011317], [8 x i32] [i32 1078206541, i32 -1312991956, i32 -2145383487, i32 -642061608, i32 1976657261, i32 1415015443, i32 -1955962176, i32 982090221], [8 x i32] [i32 160575566, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0] }, %struct.anon.5 { i8 -94, [8 x i32] [i32 600734670, i32 1139113784, i32 -1977850464, i32 -2064124641, i32 865562055, i32 653519812, i32 -686522794, i32 -696693240], [8 x i32] [i32 49891529, i32 1732632263, i32 1660051779, i32 518449495, i32 458325334, i32 -1086241687, i32 -896117310, i32 1839206564], [8 x i32] [i32 0, i32 1887947518, i32 0, i32 0, i32 0, i32 -502040075, i32 0, i32 -1922591520] }, %struct.anon.5 { i8 88, [8 x i32] [i32 2015326106, i32 381454261, i32 1651318393, i32 -2101769467, i32 552326364, i32 1810082325, i32 1359981889, i32 -391545778], [8 x i32] [i32 -1587492628, i32 -927523761, i32 1076569403, i32 -1916607312, i32 -844255560, i32 -1724346280, i32 -1930803394, i32 -1334537276], [8 x i32] [i32 0, i32 0, i32 0, i32 -1962573127, i32 -338371552, i32 0, i32 1144960261, i32 0] }, %struct.anon.5 { i8 92, [8 x i32] [i32 -240430636, i32 757888008, i32 -2082575201, i32 -600085714, i32 -1456142312, i32 -1998074303, i32 1280078777, i32 -1146553113], [8 x i32] [i32 1454134349, i32 1736693960, i32 1944740164, i32 -447797812, i32 1854833709, i32 217544019, i32 -816299032, i32 -1920335552], [8 x i32] [i32 0, i32 0, i32 -130160951, i32 -1293040714, i32 1086671272, i32 0, i32 -1186182029, i32 0] }, %struct.anon.5 { i8 85, [8 x i32] [i32 253616951, i32 -933985177, i32 -1818900626, i32 -1681884650, i32 2112761608, i32 1768290854, i32 1403597906, i32 -173525058], [8 x i32] [i32 -2130328294, i32 -1219864247, i32 910876448, i32 1641089881, i32 1625210682, i32 214516665, i32 895447927, i32 -1003812694], [8 x i32] [i32 -948384317, i32 0, i32 -1818900626, i32 0, i32 2072756767, i32 0, i32 1382589607, i32 0] }, %struct.anon.5 { i8 -51, [8 x i32] [i32 -1994963408, i32 1873399440, i32 617144089, i32 1885219249, i32 1244315143, i32 -88000889, i32 -1650133355, i32 1365993761], [8 x i32] [i32 1071284911, i32 1773044560, i32 344815203, i32 -1501238369, i32 837856937, i32 2049683940, i32 -921186137, i32 -400915911], [8 x i32] [i32 -1939795410, i32 0, i32 614013923, i32 -524528798, i32 0, i32 0, i32 725305837, i32 -1246457688] }, %struct.anon.5 { i8 4, [8 x i32] [i32 2018846709, i32 1272692437, i32 938143564, i32 585207924, i32 822547072, i32 232292669, i32 457613720, i32 -1323356484], [8 x i32] [i32 707359829, i32 2138375475, i32 1756782580, i32 1871419375, i32 -408907095, i32 -1410041581, i32 -691651814, i32 -1081612695], [8 x i32] [i32 0, i32 0, i32 -1359690882, i32 0, i32 0, i32 0, i32 0, i32 0] }], align 16
@test_simde_mm512_rorv_epi32.test_vec = internal constant [8 x %struct.anon.6] [%struct.anon.6 { [16 x i32] [i32 905140135, i32 -1203783225, i32 -373183298, i32 -2086456397, i32 -2069725447, i32 1028941064, i32 144779901, i32 426948722, i32 -682662384, i32 -577794529, i32 -288993221, i32 2087807363, i32 -285207321, i32 -164866951, i32 -234959490, i32 -1794477947], [16 x i32] [i32 -177382954, i32 601029864, i32 -804153267, i32 -397573631, i32 265768342, i32 537199522, i32 1443955664, i32 1256922228, i32 1564498037, i32 -1568665003, i32 -1401777749, i32 -1433026796, i32 -1346737139, i32 1087356784, i32 932635075, i32 1921090301], [16 x i32] [i32 -849437481, i32 -944226375, i32 1710706189, i32 -1043228199, i32 -1979980270, i32 257235266, i32 712837281, i32 730276247, i32 2066777786, i32 2087780076, i32 125688010, i32 379074503, i32 -1489012736, i32 1417279020, i32 -566240849, i32 -1470921684] }, %struct.anon.6 { [16 x i32] [i32 802210266, i32 2144424148, i32 -164936478, i32 278970371, i32 -1648403923, i32 -572682470, i32 1830057072, i32 -790653450, i32 721465175, i32 -492121856, i32 433640725, i32 -1020692330, i32 -312415789, i32 -389399176, i32 -1487544655, i32 -898091917], [16 x i32] [i32 -453674780, i32 1606852425, i32 192454261, i32 -372334314, i32 47591050, i32 501915755, i32 -222019714, i32 1488731252, i32 -29576524, i32 -966983087, i32 -1227762272, i32 27303798, i32 956528333, i32 -1789465065, i32 -1584981459, i32 200885335], [16 x i32] [i32 -1560474595, i32 1782573224, i32 1512511409, i32 -2097148862, i32 -1956155434, i32 -480527439, i32 -1269706303, i32 -111186675, i32 183857840, i32 1753248085, i32 433640725, i32 -1511892212, i32 1319070471, i32 -1803882031, i32 -175293778, i32 -261560428] }, %struct.anon.6 { [16 x i32] [i32 1191785974, i32 -686922185, i32 -1299259589, i32 1286811263, i32 -1148864860, i32 -766387292, i32 1299437814, i32 307784988, i32 -631610718, i32 78735560, i32 -961134777, i32 303262061, i32 -993159137, i32 1788223092, i32 330762743, i32 421924726], [16 x i32] [i32 989036657, i32 792634600, i32 1375139044, i32 2086865245, i32 356528545, i32 1182783055, i32 1448752864, i32 -1217429434, i32 -386833920, i32 -350802169, i32 -2143548125, i32 -1191337962, i32 550321617, i32 -194556652, i32 -917847677, i32 1099020865], [16 x i32] [i32 -1694817404, i32 936840806, i32 -1154945549, i32 1704555514, i32 1573051218, i32 -1219910493, i32 1299437814, i32 1883857332, i32 -631610718, i32 -1878433071, i32 -120141848, i32 1302705224, i32 -871374234, i32 1642546857, i32 -495525570, i32 210962363] }, %struct.anon.6 { [16 x i32] [i32 589918748, i32 -988921694, i32 1682328398, i32 -1138998293, i32 -1797461376, i32 -1165475017, i32 1166332676, i32 -1450834547, i32 432910199, i32 1054858224, i32 295839014, i32 -389169304, i32 -528635223, i32 -224786963, i32 1698111192, i32 -1693467101], [16 x i32] [i32 1572133997, i32 -560229449, i32 552550072, i32 -1509310979, i32 1418102375, i32 1682317451, i32 1657372223, i32 -1442981828, i32 1812443828, i32 -28663227, i32 -585221664, i32 1568876534, i32 967969197, i32 1771960362, i32 -1295292810, i32 -212022977], [16 x i32] [i32 -1864296117, i32 478233994, i32 1179340388, i32 -522051747, i32 19511765, i32 1727484168, i32 -1962301944, i32 -1738516262, i32 -621317732, i32 -2114519329, i32 295839014, i32 922592163, i32 1431241709, i32 2071766657, i32 -595893868, i32 908033095] }, %struct.anon.6 { [16 x i32] [i32 -1067490437, i32 -423712507, i32 -641475101, i32 -1305000188, i32 2062281040, i32 1491306721, i32 755675118, i32 -215914888, i32 -810319671, i32 229995050, i32 1407613007, i32 268770751, i32 -393547770, i32 1732275832, i32 -1785443811, i32 2055779761], [16 x i32] [i32 1615412022, i32 -59900243, i32 911233911, i32 2001098097, i32 -1101016762, i32 1545969471, i32 -1678656790, i32 -1525319313, i32 1644519348, i32 -732007843, i32 923512518, i32 1252937988, i32 1627917858, i32 -1749209427, i32 1462939368, i32 -587380697], [16 x i32] [i32 2106453761, i32 1211053557, i32 -2017736781, i32 -1551738597, i32 1105964965, i32 -1312353854, i32 -74759509, i32 -856562110, i32 940350715, i32 1839960400, i32 1028626913, i32 -251637285, i32 -1172128767, i32 1942174211, i32 496342090, i32 1660227947] }, %struct.anon.6 { [16 x i32] [i32 71172775, i32 1004117109, i32 1332929611, i32 1486430261, i32 -591814354, i32 -1217169457, i32 1292871205, i32 -1792471826, i32 -2087098610, i32 1321103875, i32 -1935855530, i32 2145662545, i32 -1487168040, i32 979357460, i32 1669820021, i32 -1996967814], [16 x i32] [i32 437031191, i32 1516882436, i32 1290143483, i32 365677117, i32 2092705640, i32 1807096822, i32 63847817, i32 76334829, i32 1528797271, i32 1572243554, i32 -878076786, i32 -807373465, i32 -1840538212, i32 1123877560, i32 759548735, i32 -399388271], [16 x i32] [i32 2080722440, i32 1404934599, i32 -295925399, i32 -993459798, i32 786217377, i32 -841007395, i32 312903635, i32 1735698760, i32 852368647, i32 -743465856, i32 -1051053452, i32 -1560295316, i32 1975115146, i32 1607406650, i32 -955327254, i32 1480410236] }, %struct.anon.6 { [16 x i32] [i32 -867938199, i32 1730804440, i32 -47000682, i32 -456387768, i32 1752570032, i32 1504342810, i32 -813240258, i32 733460673, i32 -503842040, i32 -1941430027, i32 998865651, i32 1025463949, i32 -2002348690, i32 1189171208, i32 34957376, i32 674090272], [16 x i32] [i32 -1106697016, i32 944394564, i32 1500763084, i32 -1751674071, i32 824130856, i32 -831061619, i32 -1982821015, i32 582090074, i32 1709226785, i32 -660788724, i32 657592830, i32 -859846236, i32 -1812079098, i32 1214346719, i32 1557213442, i32 1333691182], [16 x i32] [i32 1774994512, i32 -2039308371, i32 963629869, i32 -1536006647, i32 -1335331304, i32 -1731015341, i32 526893944, i32 -303157174, i32 1895562628, i32 257475714, i32 -299504692, i32 -741214872, i32 -1172137387, i32 -1916624880, i32 8739344, i32 880844983] }, %struct.anon.6 { [16 x i32] [i32 1253400382, i32 -2027728247, i32 128931171, i32 617901598, i32 750244172, i32 1215568198, i32 2040809034, i32 130556873, i32 189889922, i32 865301712, i32 -415546679, i32 -66383952, i32 656983008, i32 644849116, i32 -1398860573, i32 -1179424713], [16 x i32] [i32 -1245444891, i32 1122588537, i32 1227498649, i32 323368243, i32 -734368008, i32 -285496821, i32 -174417218, i32 -391230206, i32 -878874030, i32 1661830858, i32 -575850582, i32 1710355309, i32 1832528737, i32 -1822738987, i32 -762775857, i32 -1782958525], [16 x i32] [i32 -229266695, i32 -1851177789, i32 -676679293, i32 -1916549990, i32 -1211020244, i32 684265091, i32 -426698455, i32 1106381042, i32 1600160468, i32 873260253, i32 -1300640048, i32 2106056792, i32 328491504, i32 2096030003, i32 700930366, i32 -147428090] }], align 16
@.str.26 = private unnamed_addr constant [39 x i8] c"simde_mm512_loadu_epi32(test_vec[i].r)\00", align 1
@test_simde_mm512_mask_rorv_epi32.test_vec = internal constant [8 x %struct.anon.7] [%struct.anon.7 { [16 x i32] [i32 1184851916, i32 -1348346192, i32 338407473, i32 504908348, i32 541493486, i32 1262965618, i32 -469153697, i32 -1754933301, i32 -287439554, i32 345931747, i32 1797835055, i32 25837587, i32 992071881, i32 -2105120733, i32 2087096240, i32 -1542206362], i16 -3631, [16 x i32] [i32 829469843, i32 -235233080, i32 -1791947253, i32 828832271, i32 -1130788555, i32 1917536780, i32 -650202426, i32 -372568234, i32 -1944437821, i32 -411232805, i32 847031843, i32 -563879255, i32 2023423340, i32 233498183, i32 -286905960, i32 -52907720], [16 x i32] [i32 -930549011, i32 716113159, i32 1549610163, i32 2050736142, i32 83023293, i32 1393679803, i32 1044576262, i32 -1774576983, i32 341819916, i32 2067664583, i32 1238866746, i32 432214620, i32 -1558268184, i32 -1711853677, i32 -774424281, i32 1600590419], [16 x i32] [i32 -1533441147, i32 -1348346192, i32 338407473, i32 504908348, i32 -456373843, i32 1262965618, i32 459602635, i32 -1418402425, i32 -1137131101, i32 345931747, i32 1797835055, i32 25837587, i32 1819843325, i32 1556668861, i32 836619347, i32 371662747] }, %struct.anon.7 { [16 x i32] [i32 -1670134060, i32 253211349, i32 -1453789619, i32 -373089279, i32 1703731666, i32 956203792, i32 252302780, i32 -1133547289, i32 207151671, i32 -501518444, i32 1586197597, i32 1648840336, i32 1086837807, i32 343459159, i32 -2111602278, i32 675189489], i16 -27019, [16 x i32] [i32 1342507316, i32 2009359083, i32 147150017, i32 2111632822, i32 -1388170187, i32 1798233160, i32 -1661067426, i32 2083681096, i32 1758214012, i32 1541378202, i32 -1704745756, i32 -837336935, i32 -1132766860, i32 -1809340106, i32 288433609, i32 361587608], [16 x i32] [i32 897407643, i32 -812622614, i32 -1704332544, i32 -1486323405, i32 274982106, i32 1453689741, i32 1231541936, i32 -731974343, i32 956947279, i32 923310391, i32 -1060015475, i32 -848807181, i32 -1411462370, i32 117605206, i32 -1840223911, i32 -1385714082], [16 x i32] [i32 10561162, i32 253211349, i32 147150017, i32 -373089279, i32 1351421291, i32 -498902666, i32 526294270, i32 -1133547289, i32 207151671, i32 -1088342857, i32 656724765, i32 1648840336, i32 -236100142, i32 343459159, i32 -2111602278, i32 1446350432] }, %struct.anon.7 { [16 x i32] [i32 -1058574199, i32 -1745359094, i32 1415039329, i32 555925251, i32 -506724213, i32 -588722557, i32 -1771161544, i32 1866782182, i32 1345268550, i32 2095523610, i32 -204456208, i32 -1995115778, i32 1969938674, i32 -414100561, i32 1920843915, i32 -605961835], i16 4588, [16 x i32] [i32 305661739, i32 1397827715, i32 793136923, i32 1108293848, i32 -6963538, i32 599728549, i32 1961121171, i32 1552273712, i32 1533984216, i32 11452389, i32 -433064946, i32 -618053843, i32 -1545945347, i32 1925618399, i32 535276271, i32 1400597627], [16 x i32] [i32 263121450, i32 -1206886999, i32 2124300113, i32 2086258558, i32 1696543878, i32 -1109858866, i32 199016335, i32 1432246315, i32 -345699006, i32 -1146915478, i32 859456180, i32 -1884318967, i32 -1779052857, i32 1112722867, i32 -1219678324, i32 -921850745], [16 x i32] [i32 -1058574199, i32 -1745359094, i32 663590819, i32 138208097, i32 -506724213, i32 -2037084420, i32 -1423513144, i32 638292154, i32 383496054, i32 2095523610, i32 -204456208, i32 -1995115778, i32 -79186563, i32 -414100561, i32 1920843915, i32 -605961835] }, %struct.anon.7 { [16 x i32] [i32 599028409, i32 -1679927065, i32 -1546774374, i32 1932754348, i32 -32954293, i32 -2126423051, i32 288919178, i32 -203799238, i32 -1642688585, i32 -2126842393, i32 -1188820979, i32 -785557626, i32 1959802495, i32 485822865, i32 -634573153, i32 734857331], i16 -7017, [16 x i32] [i32 64585417, i32 588048127, i32 -847539552, i32 855898723, i32 1682216047, i32 -560798544, i32 -1947859266, i32 -93356751, i32 -83998469, i32 -820180433, i32 -6514532, i32 36937619, i32 -463046861, i32 432208219, i32 816163071, i32 539628581], [16 x i32] [i32 -1944442787, i32 -832882894, i32 1674508240, i32 -916127338, i32 -726807688, i32 -1007849532, i32 1022595607, i32 73146023, i32 2039510598, i32 2118642606, i32 2028017122, i32 -1891547626, i32 -698093807, i32 1989759070, i32 -1968009757, i32 -242348117], [16 x i32] [i32 516683336, i32 968870083, i32 -1834955397, i32 1932754348, i32 1150578532, i32 -2126423051, i32 288919178, i32 1676992250, i32 -1642688585, i32 -2126842393, i32 1072113191, i32 -785557626, i32 1959802495, i32 1728832876, i32 -434850529, i32 -2069625534] }, %struct.anon.7 { [16 x i32] [i32 862592645, i32 -340676087, i32 -563899705, i32 -361913128, i32 -222244717, i32 57170208, i32 -1853023514, i32 -1350362327, i32 1122168121, i32 1731040415, i32 -12218330, i32 -924208587, i32 -1564825214, i32 -374988286, i32 1719284541, i32 -2011824817], i16 -1813, [16 x i32] [i32 -125007157, i32 914993905, i32 -1696022863, i32 1094937222, i32 -1285339635, i32 -1444503505, i32 480720135, i32 -1995140418, i32 243376156, i32 71567955, i32 1335832008, i32 -1534008681, i32 1465381672, i32 -1694417260, i32 834119795, i32 1455082554], [16 x i32] [i32 -1083949972, i32 264546630, i32 1834902486, i32 1846734405, i32 1975871969, i32 454084263, i32 -1471362962, i32 16713620, i32 -1983880381, i32 -493321204, i32 743503591, i32 -962960668, i32 1933271243, i32 -1785836506, i32 -1472341484, i32 615005409], [16 x i32] [i32 -1396733752, i32 -992336181, i32 -563899705, i32 839523156, i32 -222244717, i32 1599327552, i32 -736333156, i32 1227614353, i32 1122168121, i32 1731040415, i32 -12218330, i32 2051608105, i32 1695214334, i32 1382810874, i32 2055680795, i32 727541277] }, %struct.anon.7 { [16 x i32] [i32 -1397856096, i32 -745584916, i32 553705277, i32 216504897, i32 561980410, i32 -2085221009, i32 -919866392, i32 -789654736, i32 679255100, i32 536611810, i32 725744874, i32 -1858590570, i32 -1162692789, i32 -1388484411, i32 -1955174309, i32 2019255356], i16 -10240, [16 x i32] [i32 -1662786656, i32 1134087682, i32 829173753, i32 1927919552, i32 -1344622990, i32 -786942629, i32 473322689, i32 1827944140, i32 470407193, i32 -1621122650, i32 -1865298992, i32 -184370557, i32 -1012605848, i32 -745227246, i32 -588264944, i32 441050113], [16 x i32] [i32 1647727292, i32 -1006528781, i32 -464203167, i32 -187082868, i32 1169653299, i32 1259883578, i32 388433942, i32 -1473089300, i32 -1240831806, i32 1618611198, i32 1782894302, i32 1499405861, i32 -694282596, i32 2032252770, i32 -1416607297, i32 2085864121], [16 x i32] [i32 -1397856096, i32 -745584916, i32 553705277, i32 216504897, i32 561980410, i32 -2085221009, i32 -919866392, i32 -789654736, i32 679255100, i32 536611810, i32 725744874, i32 531109332, i32 978175628, i32 -1388484411, i32 -1176529887, i32 619839629] }, %struct.anon.7 { [16 x i32] [i32 691166507, i32 1183427688, i32 -1598960006, i32 -1996943124, i32 -1990289626, i32 218267726, i32 -2101833015, i32 -2130834603, i32 -777441176, i32 1461138396, i32 -302528511, i32 -9047848, i32 -695676025, i32 484674131, i32 1906285596, i32 284269991], i16 -25650, [16 x i32] [i32 -120673567, i32 -121516287, i32 837327292, i32 537161880, i32 699029574, i32 331728756, i32 716270904, i32 1590001533, i32 727094057, i32 505616226, i32 1229917361, i32 -1033219204, i32 552277163, i32 338932187, i32 -1690377186, i32 -1913060509], [16 x i32] [i32 -122138730, i32 404151143, i32 1667327463, i32 1680198584, i32 -1148972576, i32 -523257918, i32 -8712804, i32 -1500744688, i32 715015363, i32 121812000, i32 -764697575, i32 1328975983, i32 1661713057, i32 222550641, i32 -133316888, i32 -157312718], [16 x i32] [i32 691166507, i32 66159518, i32 2019807539, i32 74487840, i32 -1990289626, i32 218267726, i32 -1424567422, i32 2138922693, i32 627757669, i32 505616226, i32 -302528511, i32 -1493596972, i32 -1871345067, i32 484674131, i32 1906285596, i32 1087955838] }, %struct.anon.7 { [16 x i32] [i32 -31441442, i32 184902642, i32 1994223623, i32 -1564077311, i32 1057411533, i32 -1823716949, i32 982276360, i32 -785372173, i32 1523536232, i32 -1150888780, i32 1177633605, i32 619247447, i32 1952706248, i32 1074245688, i32 -59075831, i32 667790270], i16 -25348, [16 x i32] [i32 -411979647, i32 -1674856853, i32 -460029188, i32 181623974, i32 -658895920, i32 -982793397, i32 -1922028864, i32 -768971695, i32 -2017813732, i32 1294263633, i32 221362279, i32 -451476460, i32 1522389263, i32 1428170901, i32 -1545433006, i32 427166973], [16 x i32] [i32 -123653977, i32 2084947221, i32 -1853261955, i32 -1955159685, i32 132461426, i32 -1369701028, i32 -1823326314, i32 -206780341, i32 233524728, i32 -1886834414, i32 589370024, i32 648976307, i32 657298635, i32 802523801, i32 348268489, i32 -418942993], [16 x i32] [i32 -31441442, i32 184902642, i32 614733799, i32 1516999873, i32 -2097924562, i32 1455174844, i32 -1062534603, i32 -1975892659, i32 1523536232, i32 -1150888780, i32 1728917944, i32 -528311134, i32 569071546, i32 1074245688, i32 -59075831, i32 435827436] }], align 16
@test_simde_mm512_maskz_rorv_epi32.test_vec = internal constant [8 x %struct.anon.8] [%struct.anon.8 { i16 -3140, [16 x i32] [i32 2099564532, i32 2140195934, i32 -1642642449, i32 -1758272919, i32 -568210679, i32 -1123620101, i32 103609854, i32 -772150819, i32 374283704, i32 -661200919, i32 -1938379486, i32 -1742493553, i32 1870021748, i32 741112878, i32 1328699762, i32 -98555070], [16 x i32] [i32 823160648, i32 1896523342, i32 -486703021, i32 -1652940759, i32 -1844645532, i32 -541181843, i32 -751898223, i32 1707953948, i32 227991230, i32 -662790012, i32 1253735201, i32 -1624677, i32 -1819151578, i32 -1116516565, i32 1569759552, i32 -1346216208], [16 x i32] [i32 0, i32 0, i32 -394398782, i32 885758321, i32 -1646125904, i32 1474160695, i32 0, i32 530488797, i32 1497134816, i32 -1651937794, i32 0, i32 0, i32 -776087279, i32 -2050652785, i32 1328699762, i32 725809696] }, %struct.anon.8 { i16 22588, [16 x i32] [i32 989446332, i32 1404377752, i32 1267224676, i32 -532763057, i32 -1271961279, i32 -1219071962, i32 -1894431027, i32 -1310240267, i32 -1427382255, i32 1593680122, i32 1068074480, i32 1948247859, i32 1999195985, i32 -1943109697, i32 -1155841083, i32 -1502870892], [16 x i32] [i32 -581936925, i32 -381923848, i32 86566354, i32 511264973, i32 1452647063, i32 -404569055, i32 -1667039993, i32 -498987265, i32 1606455910, i32 -1320616737, i32 -1363775263, i32 1338781624, i32 -207265070, i32 769296166, i32 -2067170172, i32 -244970613], [16 x i32] [i32 0, i32 0, i32 337187554, i32 1920926197, i32 1590854504, i32 1537947667, i32 0, i32 0, i32 0, i32 0, i32 0, i32 535245684, i32 1406426570, i32 0, i32 1538372668, i32 0] }, %struct.anon.8 { i16 9885, [16 x i32] [i32 -1742570416, i32 -485948371, i32 2132001202, i32 -1226709743, i32 -1287780392, i32 -30424524, i32 -1391871418, i32 -53237844, i32 1368782371, i32 -1405837574, i32 1881884511, i32 86445100, i32 1220044051, i32 1850140455, i32 1310412706, i32 441118454], [16 x i32] [i32 -563355676, i32 -578052227, i32 323860199, i32 -703040317, i32 18796761, i32 1517249720, i32 -1431795020, i32 1573188216, i32 1329278930, i32 -1238579505, i32 1086945917, i32 -938024210, i32 1791571378, i32 1304705177, i32 989359298, i32 832027743], [16 x i32] [i32 159524805, i32 0, i32 1694377859, i32 920403106, i32 -1627132839, i32 0, i32 0, i32 -743985924, i32 0, i32 1039489129, i32 -2124793093, i32 0, i32 0, i32 594777015, i32 0, i32 0] }, %struct.anon.8 { i16 -11284, [16 x i32] [i32 -1382433920, i32 975640177, i32 1830557014, i32 -1499279395, i32 -18990279, i32 -2123718519, i32 1916651995, i32 2068130298, i32 1428742116, i32 1284526069, i32 1119464548, i32 -1243063429, i32 531875734, i32 1117789543, i32 -508174617, i32 -329451001], [16 x i32] [i32 -817789735, i32 941347283, i32 -109390722, i32 -978427345, i32 -1847238359, i32 1725138303, i32 1799850083, i32 1549247619, i32 -64251864, i32 -399227286, i32 1239526938, i32 974098448, i32 1892414705, i32 -573137287, i32 -1438114265, i32 -368664638], [16 x i32] [i32 0, i32 0, i32 -1267706535, i32 -1615114939, i32 0, i32 47530259, i32 1850194235, i32 1332258111, i32 -464181025, i32 -44882925, i32 0, i32 0, i32 -473231399, i32 0, i32 -809276483, i32 -82362751] }, %struct.anon.8 { i16 12855, [16 x i32] [i32 444113382, i32 1808307081, i32 -335816228, i32 -555750381, i32 863787357, i32 2119279414, i32 1411191629, i32 -460958466, i32 2147483382, i32 1860880273, i32 -1285954144, i32 798046674, i32 -933097838, i32 -12143439, i32 -984390713, i32 -1381312073], [16 x i32] [i32 1764600279, i32 299308912, i32 -809225987, i32 -67217815, i32 365125732, i32 -602666732, i32 614557548, i32 416369472, i32 1703018228, i32 326522902, i32 -220054904, i32 -185737072, i32 1426764096, i32 657530554, i32 -968109434, i32 316546078], [16 x i32] [i32 -247215052, i32 -1819710520, i32 1608437479, i32 0, i32 -751319659, i32 439576549, i32 0, i32 0, i32 0, i32 -1424079429, i32 0, i32 0, i32 -933097838, i32 -777180033, i32 0, i32 0] }, %struct.anon.8 { i16 24347, [16 x i32] [i32 -306761353, i32 640172100, i32 520534066, i32 -1211087187, i32 -858420325, i32 -39887950, i32 1686818, i32 1197487311, i32 -1456203931, i32 -1982899113, i32 -1029057259, i32 -1216775908, i32 -1232843260, i32 -860675158, i32 -1345532448, i32 1744186369], [16 x i32] [i32 -1693439164, i32 -1675239289, i32 -782315851, i32 1284101959, i32 -805171930, i32 278705712, i32 -2067830653, i32 -638863723, i32 1752497377, i32 -1861903908, i32 -1352440985, i32 1643899963, i32 691142137, i32 909757875, i32 -893650891, i32 -1885100370], [16 x i32] [i32 2128311063, i32 -2008264576, i32 0, i32 1534042253, i32 1865635374, i32 0, i32 0, i32 0, i32 -728101966, i32 -1661614728, i32 730157994, i32 -282123370, i32 1109852763, i32 0, i32 1718551934, i32 0] }, %struct.anon.8 { i16 6306, [16 x i32] [i32 -38699272, i32 1935677712, i32 -1017144376, i32 767580412, i32 -1157991295, i32 1706176682, i32 -1643355654, i32 -390680848, i32 1038444333, i32 1219511936, i32 -569700383, i32 -401879961, i32 -358480320, i32 810570806, i32 -1496425291, i32 932086794], [16 x i32] [i32 1819571436, i32 -1682627398, i32 -1703296973, i32 -863861364, i32 -1044962165, i32 787548025, i32 1842659427, i32 816145220, i32 -1851975209, i32 1898730046, i32 -1626561006, i32 -1234465237, i32 746005171, i32 -1940232151, i32 1845112616, i32 1771937682], [16 x i32] [i32 0, i32 -670677988, i32 0, i32 0, i32 0, i32 -652716750, i32 0, i32 244017903, i32 0, i32 0, i32 0, i32 -1929576071, i32 1086856532, i32 0, i32 0, i32 0] }, %struct.anon.8 { i16 15032, [16 x i32] [i32 646772474, i32 1959567208, i32 -1459423426, i32 617395629, i32 1015936481, i32 2087433602, i32 -1071907550, i32 1627050854, i32 847677386, i32 1688621862, i32 -133322678, i32 1058855262, i32 1367058895, i32 -2117212577, i32 1229056227, i32 -2052506437], [16 x i32] [i32 -373870397, i32 -850567805, i32 1690655238, i32 61071924, i32 -363585653, i32 -378789627, i32 -1003311863, i32 -1404379927, i32 -1886060276, i32 1700586079, i32 1909006909, i32 -1888195580, i32 -1854224245, i32 -226826519, i32 2109123731, i32 -1809252216], [16 x i32] [i32 0, i32 0, i32 0, i32 -883240372, i32 -1138257474, i32 333667756, i32 0, i32 -1288667799, i32 0, i32 -917723572, i32 0, i32 -470692459, i32 971648885, i32 801171187, i32 0, i32 0] }], align 16
@test_simde_mm_rorv_epi64.test_vec = internal constant [8 x %struct.anon.9] [%struct.anon.9 { [2 x i64] [i64 7152693782144456081, i64 2020249513474868575], [2 x i64] [i64 -2755166252928422419, i64 2732664164436416460], [2 x i64] [i64 -3978579609577121253, i64 6192942712613307700] }, %struct.anon.9 { [2 x i64] [i64 -6741449653343172108, i64 1165091049881912532], [2 x i64] [i64 -5501487897388893719, i64 -6441578264795393311], [2 x i64] [i64 -6843599631116322617, i64 -8675794999610860015] }, %struct.anon.9 { [2 x i64] [i64 5375087343847138995, i64 -1216671162808284439], [2 x i64] [i64 -3650340204444900419, i64 -860789784606255436], [2 x i64] [i64 6107210603358008730, i64 -2864182961154121999] }, %struct.anon.9 { [2 x i64] [i64 -3494086435577085502, i64 2036464169349077836], [2 x i64] [i64 1573470821043731996, i64 -5214454829765945235], [2 x i64] [i64 -8166121044862030237, i64 -3820566619526995433] }, %struct.anon.9 { [2 x i64] [i64 6557083888222440521, i64 -1096643188037395636], [2 x i64] [i64 893065809763010542, i64 -5651071501970251801], [2 x i64] [i64 -4307482219990651907, i64 -6244421518502031391] }, %struct.anon.9 { [2 x i64] [i64 4706790428297495528, i64 -2486069532575334725], [2 x i64] [i64 3307771085309376315, i64 -1834762754833407633], [2 x i64] [i64 3043341115843443976, i64 7628288364956334847] }, %struct.anon.9 { [2 x i64] [i64 384264238922557983, i64 3600649845533327660], [2 x i64] [i64 2593495818833699978, i64 -4433647995065792876], [2 x i64] [i64 -8664550425015011494, i64 4905197484239704505] }, %struct.anon.9 { [2 x i64] [i64 -5747389706860603922, i64 7967927551426023789], [2 x i64] [i64 2719677821050920935, i64 3145817382140229955], [2 x i64] [i64 464342090749344343, i64 -5921538083712828883] }], align 16
@.str.27 = private unnamed_addr constant [38 x i8] c"simde_x_mm_loadu_epi64(test_vec[i].r)\00", align 1
@.str.28 = private unnamed_addr constant [58 x i8] c"%s:%d: assertion failed: %s[%zu] == %s[%zu] (%ld == %ld)\0A\00", align 1
@test_simde_mm_mask_rorv_epi64.test_vec = internal constant [8 x %struct.anon.10] [%struct.anon.10 { [2 x i64] [i64 -5712674991527148950, i64 -8507325428741836261], i8 71, [2 x i64] [i64 7494458157836846923, i64 -6731928852836825039], [2 x i64] [i64 -449604565365469401, i64 -6624764979414144543], [2 x i64] [i64 -471811921691016365, i64 1493686652924178736] }, %struct.anon.10 { [2 x i64] [i64 -3582789846887959325, i64 5019695121268456615], i8 -39, [2 x i64] [i64 1745666772933143720, i64 462486556078309996], [2 x i64] [i64 5582336609227065970, i64 -3328809755821244567], [2 x i64] [i64 8551093486821705230, i64 5019695121268456615] }, %struct.anon.10 { [2 x i64] [i64 -764377699213267299, i64 6664457642309440868], i8 50, [2 x i64] [i64 2808575625215028767, i64 7550883709219499387], [2 x i64] [i64 5697588418162267722, i64 2557364009090778979], [2 x i64] [i64 -764377699213267299, i64 5010814990317863959] }, %struct.anon.10 { [2 x i64] [i64 -3778328426953031485, i64 5314180487252074396], i8 -40, [2 x i64] [i64 -8144301397163968848, i64 86613759766971610], [2 x i64] [i64 915669079263649130, i64 8840097448237665044], [2 x i64] [i64 -3778328426953031485, i64 5314180487252074396] }, %struct.anon.10 { [2 x i64] [i64 8926145049919488075, i64 -7850022463790681267], i8 -69, [2 x i64] [i64 7895360321318595680, i64 1702274993141278975], [2 x i64] [i64 4979068943017243074, i64 -7424182648954804193], [2 x i64] [i64 1973840080329648920, i64 -6309875138254904276] }, %struct.anon.10 { [2 x i64] [i64 -3207505404878266194, i64 2899411501643772942], i8 -71, [2 x i64] [i64 3911323560622945524, i64 6696014252168021054], [2 x i64] [i64 3300861972864630042, i64 2714751593828578348], [2 x i64] [i64 2521238494889902986, i64 2899411501643772942] }, %struct.anon.10 { [2 x i64] [i64 5040817743424468912, i64 -9011014115182419431], i8 111, [2 x i64] [i64 527789848567300899, i64 3032713599542314666], [2 x i64] [i64 3123378047813866922, i64 350741878965268220], [2 x i64] [i64 -8896304364021230395, i64 -6816814628451620190] }, %struct.anon.10 { [2 x i64] [i64 -8614965118453954728, i64 -5773047349728335420], i8 -39, [2 x i64] [i64 3857559887523606036, i64 -7075688460440897695], [2 x i64] [i64 6019064933939624261, i64 3877326746132496369], [2 x i64] [i64 -6796980281155969168, i64 -5773047349728335420] }], align 16
@test_simde_mm_maskz_rorv_epi64.test_vec = internal constant [8 x %struct.anon.11] [%struct.anon.11 { i8 -9, [2 x i64] [i64 4657411723102175602, i64 2371904861724022922], [2 x i64] [i64 8440060390469709101, i64 6374507612944602999], [2 x i64] [i64 -7329043287324359405, i64 -3069819662130670527] }, %struct.anon.11 { i8 -115, [2 x i64] [i64 6030907290051582132, i64 -1293841233286113749], [2 x i64] [i64 8410921305400097828, i64 7244236469531457839], [2 x i64] [i64 -6733609820966149789, i64 0] }, %struct.anon.11 { i8 75, [2 x i64] [i64 -7737227872044741538, i64 -4210369181610836718], [2 x i64] [i64 -4130197174272994330, i64 -8074996799616210447], [2 x i64] [i64 -445269011394822304, i64 -2178415750161014072] }, %struct.anon.11 { i8 101, [2 x i64] [i64 2332645401739592564, i64 3510114308793682957], [2 x i64] [i64 -8351499022334347888, i64 2321689913063226873], [2 x i64] [i64 248859472756362659, i64 0] }, %struct.anon.11 { i8 79, [2 x i64] [i64 -7412904314639585829, i64 -2541958015268491077], [2 x i64] [i64 -5233098128638287388, i64 5090900925823005450], [2 x i64] [i64 -3368931262506860244, i64 3384224538908327356] }, %struct.anon.11 { i8 -15, [2 x i64] [i64 7738687719068293784, i64 2907054075131629133], [2 x i64] [i64 5910368817374216110, i64 -7372106709453677764], [2 x i64] [i64 6767409378285956501, i64 0] }, %struct.anon.11 { i8 94, [2 x i64] [i64 3896532494775239535, i64 -7065401391828793771], [2 x i64] [i64 5683278789551648201, i64 -4670539230235090996], [2 x i64] [i64 0, i64 7303113644083267560] }, %struct.anon.11 { i8 44, [2 x i64] [i64 2206776566129984775, i64 -4253199227850791799], [2 x i64] [i64 1815237048546007894, i64 3992766732294488660], [2 x i64] zeroinitializer }], align 16
@test_simde_mm256_rorv_epi64.test_vec = internal constant [8 x %struct.anon.12] [%struct.anon.12 { [4 x i64] [i64 1489263881975555604, i64 -8859794338791044252, i64 1338588315493512040, i64 2044618873627689261], [4 x i64] [i64 -6230452709232650280, i64 -627924979889020985, i64 -8076749209848724260, i64 6198446769142992096], [4 x i64] [i64 -511699428660372427, i64 -3960327221319913578, i64 6317202830687596465, i64 6891423516812374536] }, %struct.anon.12 { [4 x i64] [i64 1915247361442600870, i64 -5208368044738366926, i64 4962535107812312300, i64 -4479056210683900669], [4 x i64] [i64 2879841907145220489, i64 -1475877761633954062, i64 -8355558803135458716, i64 -810115309736478492], [4 x i64] [i64 -3238851014203939541, i64 736039986982071790, i64 3812556907614168950, i64 -5182837434230148319] }, %struct.anon.12 { [4 x i64] [i64 -6799933310642327930, i64 -8248356832462075490, i64 -4820152492936019707, i64 -7784333361530721895], [4 x i64] [i64 3403788458291808748, i64 -6633710315684189639, i64 4515506951436780820, i64 -3308109544327846026], [4 x i64] [i64 -8437585062955181540, i64 -4325262353701220538, i64 6633903207377373429, i64 -2163922364932921777] }, %struct.anon.12 { [4 x i64] [i64 1064443621759853828, i64 -462638320997854893, i64 -8464075612113942875, i64 841932371045305591], [4 x i64] [i64 1742444202192608331, i64 -6568607809245962504, i64 4972388841520348515, i64 9176032788336480069], [4 x i64] [i64 -6880980482759930460, i64 -7754945733193542663, i64 7601188679114109442, i64 -5161836384135645593] }, %struct.anon.12 { [4 x i64] [i64 6398433510807304685, i64 -3094239633904053140, i64 -4801314974531256374, i64 4544237931753734236], [4 x i64] [i64 -1652049765603299239, i64 2294975801412831377, i64 -3487872487055153821, i64 6604653104398901526], [4 x i64] [i64 5763752843431817305, i64 7653421747076150683, i64 218881950170728879, i64 2738594277151033924] }, %struct.anon.12 { [4 x i64] [i64 -1691059502321460703, i64 -6637244543858320274, i64 -4094591535176344598, i64 2239653503250238903], [4 x i64] [i64 -4777960421162342286, i64 5550233964519726370, i64 6050541685931935103, i64 8179417629485442917], [4 x i64] [i64 690712676934384162, i64 3529475324913447248, i64 -8189183070352689195, i64 -735911457308760377] }, %struct.anon.12 { [4 x i64] [i64 -6244825241177407160, i64 -5100023959231080823, i64 2343807750727394200, i64 -326222136307641848], [4 x i64] [i64 2988393026311861063, i64 3436332930276099261, i64 -9075622434897159887, i64 -2438414879195295620], [4 x i64] [i64 -7975123041368771454, i64 -3906703526429543347, i64 8096796982389772355, i64 -5219554180922269553] }, %struct.anon.12 { [4 x i64] [i64 7025092752680205494, i64 1400630347164062633, i64 4079712314524160930, i64 -2301180898677675876], [4 x i64] [i64 -8479797740871172788, i64 6141849628217944392, i64 -2016750303311741938, i64 5134991956473440824], [4 x i64] [i64 -3790315775710635317, i64 -6263539469006120813, i64 5659021937669600255, i64 1193500297220627680] }], align 16
@.str.29 = private unnamed_addr constant [41 x i8] c"simde_x_mm256_loadu_epi64(test_vec[i].r)\00", align 1
@test_simde_mm256_mask_rorv_epi64.test_vec = internal constant [8 x %struct.anon.13] [%struct.anon.13 { [4 x i64] [i64 4006496326016145118, i64 -1006581310255347185, i64 -187369632019841945, i64 -7604050106431226227], i8 -109, [4 x i64] [i64 6598046757928695953, i64 4104448579282417062, i64 -7885375976160891216, i64 -938472342692370327], [4 x i64] [i64 6468299029619129048, i64 6822351652379934776, i64 2500048344083281098, i64 -5535062638384841763], [4 x i64] [i64 -4469662807704956543, i64 -725575905145674184, i64 -187369632019841945, i64 -7604050106431226227] }, %struct.anon.13 { [4 x i64] [i64 -2429726466379046341, i64 -3122120397410849120, i64 -2229102573981135052, i64 6137366267807307934], i8 -16, [4 x i64] [i64 -5131722539141807288, i64 -3243551863982647608, i64 -7868993638777820535, i64 -5110456992188840746], [4 x i64] [i64 -1690914602157429947, i64 7662501900611242945, i64 -5034071224652190314, i64 1716421012379062182], [4 x i64] [i64 -2429726466379046341, i64 -3122120397410849120, i64 -2229102573981135052, i64 6137366267807307934] }, %struct.anon.13 { [4 x i64] [i64 2208575115697304478, i64 -7419969546433177926, i64 -6429648234730644186, i64 3748277568763962140], i8 65, [4 x i64] [i64 -1290917256101891349, i64 6160795339653755232, i64 -1000648704751466061, i64 -465914692405556808], [4 x i64] [i64 4987291170352932783, i64 7289390121472632603, i64 3595985188286725798, i64 -2552976747717431414], [4 x i64] [i64 8876796350614199339, i64 -7419969546433177926, i64 -6429648234730644186, i64 3748277568763962140] }, %struct.anon.13 { [4 x i64] [i64 7805400404050896424, i64 -5433478544518811518, i64 689491090409651686, i64 3677245214539450879], i8 26, [4 x i64] [i64 -9004711525823659988, i64 -3286143574138078186, i64 6880754029418300654, i64 -2501577308202489349], [4 x i64] [i64 -6921068864786353187, i64 -5237822940197780312, i64 -793561549658284217, i64 -2311636327153375908], [4 x i64] [i64 7805400404050896424, i64 -3134908603336334011, i64 689491090409651686, i64 -1829974660909249774] }, %struct.anon.13 { [4 x i64] [i64 7225817505167527710, i64 3407026893527016903, i64 -8233204431893791280, i64 7498359557796388654], i8 -42, [4 x i64] [i64 -4870653615761387426, i64 -4766827933595273000, i64 4509927722275742112, i64 3707291343035876886], [4 x i64] [i64 -3236896281459424255, i64 3112467328526956595, i64 -5696443734727319723, i64 7852799369883187953], [4 x i64] [i64 7225817505167527710, i64 1902772030644361147, i64 8434399827635925831, i64 7498359557796388654] }, %struct.anon.13 { [4 x i64] [i64 4436564644303523523, i64 8523028352153447824, i64 -627658383382881536, i64 1832885153404131223], i8 -123, [4 x i64] [i64 -2982284101671725005, i64 -2639551383720183684, i64 -2716558689885357672, i64 -1021390513578684778], [4 x i64] [i64 -6169200114347974110, i64 6930309507365493074, i64 9042772749307940704, i64 1900130882628071087], [4 x i64] [i64 4837980960247460634, i64 8523028352153447824, i64 -5340713248191883197, i64 1832885153404131223] }, %struct.anon.13 { [4 x i64] [i64 5104840022472153856, i64 -6302288190290468511, i64 -5892175062247956779, i64 -6662097480897067656], i8 -44, [4 x i64] [i64 -8459431730568638159, i64 -1566273776699391064, i64 4469708528183541702, i64 3747421514138482867], [4 x i64] [i64 -9040686139799909803, i64 -7205139459221726005, i64 4011075057675463474, i64 7413599058924965035], [4 x i64] [i64 5104840022472153856, i64 -6302288190290468511, i64 -1869446867772665983, i64 -6662097480897067656] }, %struct.anon.13 { [4 x i64] [i64 2489626751633018672, i64 -2180521021214720950, i64 -3971620590069094105, i64 -2595663641760545404], i8 -87, [4 x i64] [i64 -1326272220225280673, i64 6971147225814317403, i64 -8122446116018100021, i64 3872838213802056637], [4 x i64] [i64 4420314788761157626, i64 4444369426897499349, i64 3302342974272187130, i64 2174679127385443874], [4 x i64] [i64 7352298274129795067, i64 -2180521021214720950, i64 -3971620590069094105, i64 -8822913481059613323] }], align 16
@test_simde_mm256_maskz_rorv_epi64.test_vec = internal constant [8 x %struct.anon.14] [%struct.anon.14 { i8 -61, [4 x i64] [i64 -2908232570122237263, i64 -4088557505929941067, i64 7633431334080710278, i64 -4075851023874398039], [4 x i64] [i64 -6057560348459461579, i64 4939099410294519847, i64 -3423298498897788229, i64 -1385159560377070616], [4 x i64] [i64 2238032197843259069, i64 4075357300608369933, i64 0, i64 0] }, %struct.anon.14 { i8 0, [4 x i64] [i64 3151008956830581851, i64 -3710072147974455661, i64 2461151325517486142, i64 5129255743305360961], [4 x i64] [i64 6406815521942676682, i64 4605109839853572883, i64 -2200670734886446020, i64 -2306339895203967029], [4 x i64] zeroinitializer }, %struct.anon.14 { i8 96, [4 x i64] [i64 6521351380549344728, i64 7025221266367487134, i64 -7671633171779038953, i64 1697164634247282928], [4 x i64] [i64 -3528565696616942809, i64 1479027840754213792, i64 6502170272338118496, i64 -7426694781314013287], [4 x i64] zeroinitializer }, %struct.anon.14 { i8 -57, [4 x i64] [i64 -5613798166853302413, i64 5461111267222568409, i64 -7744204894060121964, i64 -4507648790835667051], [4 x i64] [i64 857459856103729892, i64 -1397454710340545140, i64 -869369145163362386, i64 8561078536639476928], [4 x i64] [i64 -612625376671073148, i64 -2480150115563169037, i64 4231051386962465308, i64 0] }, %struct.anon.14 { i8 121, [4 x i64] [i64 2802284128495184391, i64 2096262685841634091, i64 6297843598414803781, i64 5374024997195576332], [4 x i64] [i64 2432371468464635658, i64 -1035087201994915657, i64 -7363668457153880556, i64 2306204846093875059], [4 x i64] [i64 -9094534641694168342, i64 0, i64 0, i64 -8365326918538393262] }, %struct.anon.14 { i8 -119, [4 x i64] [i64 -4765476371310855262, i64 2513108668223414826, i64 -2565845460376922125, i64 -4697233399160366082], [4 x i64] [i64 1804186359253192654, i64 -4590639385222483421, i64 4619873266577897756, i64 -1077670781472207055], [4 x i64] [i64 -1257921057538139650, i64 0, i64 0, i64 688527345622933352] }, %struct.anon.14 { i8 -88, [4 x i64] [i64 -5128560637771301649, i64 4501143616282295190, i64 -1999385113736922888, i64 -8625808797542675127], [4 x i64] [i64 2896391333608022324, i64 -753232546837055737, i64 1687799609881267378, i64 -6921184442451397679], [4 x i64] [i64 0, i64 0, i64 0, i64 -4132962892741029629] }, %struct.anon.14 { i8 -28, [4 x i64] [i64 234362326041958700, i64 2580833165614550051, i64 3895341837366417402, i64 -7374572450113029439], [4 x i64] [i64 -2114139035238588582, i64 -7360623831100184162, i64 -7844734182833534425, i64 6802686153978266209], [4 x i64] [i64 0, i64 0, i64 -8755592855190495727, i64 0] }], align 16
@test_simde_mm512_rorv_epi64.test_vec = internal constant [8 x %struct.anon.15] [%struct.anon.15 { [8 x i64] [i64 -4031222765621492941, i64 -4450970416159848894, i64 -1625311065313362393, i64 1326347335033401858, i64 -8363776830626917916, i64 1345420615588967147, i64 -1856316595130324958, i64 -5283558186717040453], [8 x i64] [i64 6191545042178114584, i64 -7081372226062215493, i64 1719019754786738705, i64 -7392554877203678497, i64 -3989654854368082974, i64 -2696485433278210180, i64 -7715321793429404294, i64 -2359694899797451227], [8 x i64] [i64 -6214066126516109116, i64 5142899272561248344, i64 2239402514570625854, i64 8279696408904221631, i64 5293352961600878930, i64 3079985775713922737, i64 -8123797646083487559, i64 -7722268709641426882] }, %struct.anon.15 { [8 x i64] [i64 -7005969198951482383, i64 -2932360826006981461, i64 -1227342187978744402, i64 -2659984802977596359, i64 -5057368602012270320, i64 4325561817719727570, i64 -8624509493706771304, i64 -3848093086882274093], [8 x i64] [i64 -2171918034187554796, i64 2016231112792082481, i64 334334209130535884, i64 5274657670228435375, i64 3222685055841939402, i64 -5914098353080382898, i64 -1965984838225204863, i64 -7184788616062862900], [8 x i64] [i64 -5494644517409513518, i64 1490333356285881255, i64 -2670934223119566127, i64 -6065102768984312277, i64 4912991956563179024, i64 -7545517164317852491, i64 4911117290001390156, i64 5565509663578643438] }, %struct.anon.15 { [8 x i64] [i64 5320491668216329647, i64 2992367795399475704, i64 -8608468253584633745, i64 323084164063155468, i64 1714890829009449096, i64 6635343684494812741, i64 -7994865131462790711, i64 -1101433124431030947], [8 x i64] [i64 3248010026147865820, i64 5075046044314174501, i64 5996498883210604064, i64 8126388821245142893, i64 -7046868458647373537, i64 -7113683568472076925, i64 6257041301120881292, i64 -5465977322934052319], [8 x i64] [i64 -6387411639835889734, i64 4526352988663199797, i64 -6567285716650781765, i64 -7300620531158473762, i64 530827790733871167, i64 -6088111067079230264, i64 2060696757965701135, i64 6428970583422891572] }, %struct.anon.15 { [8 x i64] [i64 -7979271268598050773, i64 -7037198693273767107, i64 3687311280661699051, i64 8366294242169477073, i64 233163289060300444, i64 -7926313734551843249, i64 -1661104681869958740, i64 -8960356871687906583], [8 x i64] [i64 7712812501149073216, i64 -8830489208191924679, i64 6191663800765373165, i64 -1767331183642330097, i64 5364903233664690157, i64 -424571962960166723, i64 -6685052047613534600, i64 -2686939315080413143], [8 x i64] [i64 -7979271268598050773, i64 3129026872725839567, i64 -5722209200137201313, i64 -5790810851806884400, i64 -1858481626399368734, i64 -8070277655286091140, i64 -967684863389750040, i64 8293704089599071029] }, %struct.anon.15 { [8 x i64] [i64 6347074476989195449, i64 6241155510443065494, i64 -5647668375531643801, i64 358941391130277939, i64 -3760816621018423589, i64 3267937420421544997, i64 4387006350017205671, i64 8453072445310329344], [8 x i64] [i64 2970047007444180791, i64 6442831036730418807, i64 6440545873230926365, i64 5682685211194998477, i64 -414065620376958957, i64 1414870212598460055, i64 7126271952460196658, i64 -8017068703973013160], [8 x i64] [i64 3075175245586985648, i64 4184896595097103533, i64 -2750323618918720441, i64 -4496800411841655799, i64 -298511385990091047, i64 -2488157040693245432, i64 8197127509484621624, i64 6728941297087322699] }, %struct.anon.15 { [8 x i64] [i64 66402161250498414, i64 -837691785931578794, i64 -8498745282291329258, i64 -1370018433022174994, i64 -2190779617330158802, i64 -2044197940847844885, i64 8349566529671471396, i64 -4692509396089972362], [8 x i64] [i64 8353032201945136766, i64 -3926924858522265137, i64 2584220306950262755, i64 1524178848769883095, i64 4157396857441451190, i64 8760159426525451043, i64 -8703559566389759643, i64 -277792411337404806], [8 x i64] [i64 265608645001993656, i64 4948867476202231954, i64 3859570461667085446, i64 -886683723352834857, i64 7144448846482684806, i64 -5357669209420320359, i64 3074965725746494708, i64 -5172696170405405265] }, %struct.anon.15 { [8 x i64] [i64 8229463346885903505, i64 -4121129695855310144, i64 -1605797771915710337, i64 5521448033926620765, i64 -8636360608498328733, i64 -5860119697674116986, i64 -957977449631742628, i64 3477120645523222074], [8 x i64] [i64 -8475484206806104047, i64 5135543843486187112, i64 -1068822371830193502, i64 536536343760060533, i64 -4161535659927906895, i64 8048393007929339775, i64 -41147528377875516, i64 3282478150344332432], [8 x i64] [i64 -6752944117931049571, i64 6941519318031453902, i64 -3749690755138075685, i64 71456297764186725, i64 -4763584495004564462, i64 6726504678361317645, i64 -3518638104422524843, i64 -5892344105810397802] }, %struct.anon.15 { [8 x i64] [i64 3327352732647582985, i64 -1149463348914910511, i64 1483612286469583628, i64 -7649600857459468243, i64 -6020703730108941931, i64 6904113146987350707, i64 4800992326475725833, i64 -538529370907919515], [8 x i64] [i64 6918565507792405372, i64 -6094760482068017992, i64 6026617769703268683, i64 -3715527621115343341, i64 1322411612772215630, i64 -738157504615245197, i64 -1932896559870641686, i64 -8456693312628493946], [8 x i64] [i64 -2102588498767327086, i64 885287857135735280, i64 7026339838759726486, i64 6558844948111791411, i64 -1849095121628490766, i64 777570126891740154, i64 4999907695739840547, i64 -7502404301364941587] }], align 16
@.str.30 = private unnamed_addr constant [39 x i8] c"simde_mm512_loadu_epi64(test_vec[i].r)\00", align 1
@test_simde_mm512_mask_rorv_epi64.test_vec = internal constant [8 x %struct.anon.16] [%struct.anon.16 { [8 x i64] [i64 5237100477281721135, i64 -6081791155903194878, i64 -3450607602809573641, i64 4884474943074533144, i64 2120053148466032640, i64 -3611796920684989686, i64 4015452885585569087, i64 2168738439701199553], i8 24, [8 x i64] [i64 6942670105351569757, i64 -7811208306202604023, i64 3903469947744060072, i64 8433679803169898505, i64 -7367575013743640908, i64 -6652786439921338453, i64 5800979673882910223, i64 -160356858945415624], [8 x i64] [i64 5958861159021906570, i64 4807055160401176088, i64 3822729236893844597, i64 2678600107762798565, i64 -4336419247321281577, i64 -3959353102068990825, i64 -8033695326109525167, i64 3216953686785657059], [8 x i64] [i64 5237100477281721135, i64 -6081791155903194878, i64 -3450607602809573641, i64 -4068263390246055016, i64 -8611611242513359165, i64 -3611796920684989686, i64 4015452885585569087, i64 2168738439701199553] }, %struct.anon.16 { [8 x i64] [i64 7846532606109344629, i64 -7361902939633894472, i64 -3235438375462347553, i64 4103614626410977393, i64 -3450816038242247206, i64 8564072529119695864, i64 -7291018653573595122, i64 -726395536451492623], i8 -16, [8 x i64] [i64 1475731253050844484, i64 6086088867732765622, i64 7577896008600613920, i64 1062140094267580025, i64 6193587069324936735, i64 -2256809462016925755, i64 -4803576889717674841, i64 8429126987431926562], [8 x i64] [i64 6485544741773806092, i64 -7311766675677462553, i64 616955657417367950, i64 7818792520115296696, i64 317249911317386616, i64 893176716483828696, i64 -9024247415617688364, i64 2184828177758533511], [8 x i64] [i64 7846532606109344629, i64 -7361902939633894472, i64 -3235438375462347553, i64 4103614626410977393, i64 -861700591837634731, i64 -4782886710458204070, i64 -6716419737829224751, i64 4965768949168411574] }, %struct.anon.16 { [8 x i64] [i64 6631711547006348006, i64 -4956337940408585043, i64 775808271733101944, i64 5455340622937412592, i64 2345908608183558318, i64 -4922854118624872949, i64 5559343395681150104, i64 631798461609809684], i8 121, [8 x i64] [i64 9184543648802159123, i64 4211846514139555928, i64 -3796563398610153863, i64 -6927892421302368055, i64 3292553356228806761, i64 7510170124306379496, i64 9118367257966399498, i64 5180754609217515706], [8 x i64] [i64 6234717387576962692, i64 1509986851519500189, i64 4869056990465464158, i64 -5606015963346931187, i64 8368131038153256029, i64 7007869314632021281, i64 9032257606134272908, i64 -5883219188202806663], [8 x i64] [i64 4032798491870675873, i64 -4956337940408585043, i64 775808271733101944, i64 5065703890798973238, i64 -8048421501414932823, i64 -70868522877796873, i64 47262160155044413, i64 631798461609809684] }, %struct.anon.16 { [8 x i64] [i64 1770929464662385992, i64 1401609624704291599, i64 7459230841666398359, i64 -3430782455251997596, i64 -8728395581142082354, i64 4445066741945999893, i64 -4662694167224985100, i64 -8066553028784334411], i8 -75, [8 x i64] [i64 6310582346184349436, i64 -5167251792030978230, i64 -3459376433781855104, i64 4887850659464952392, i64 -286729874872139400, i64 -4747748115387120764, i64 5336488491151208393, i64 4308327197756334143], [8 x i64] [i64 7273574948640688961, i64 -6274108158138432528, i64 4062519513074693139, i64 5590524094798810007, i64 6582065195131174164, i64 1656330718664073076, i64 8330968660116759660, i64 -527093898329367466], [8 x i64] [i64 3155291173092174718, i64 1401609624704291599, i64 7318377980612233474, i64 -3430782455251997596, i64 1159553485298674396, i64 -3908026935779243039, i64 -4662694167224985100, i64 -5872415809975678439] }, %struct.anon.16 { [8 x i64] [i64 -7591305212104740641, i64 1548647457857613924, i64 -8495732607647307573, i64 2905273969662551668, i64 -1854611672011752053, i64 -2448047160427729591, i64 950715379112837490, i64 4969078673004371333], i8 -12, [8 x i64] [i64 7046264472561185128, i64 4820351066500873129, i64 -2667000978852836136, i64 2880290276630579534, i64 8313488553818943177, i64 13735275044197420, i64 4823201218106428248, i64 2603994673857332029], [8 x i64] [i64 7488221997363808941, i64 -684681702566145450, i64 -6357118488598022512, i64 -432971955803320963, i64 -562002578990096496, i64 -7006487155627882449, i64 5115501798410604268, i64 -703938790743432970], [8 x i64] [i64 -7591305212104740641, i64 1548647457857613924, i64 -8297641533658794021, i64 2905273969662551668, i64 7983038668259131047, i64 -7470948630491824031, i64 4558020439468945143, i64 -8287344657976986480] }, %struct.anon.16 { [8 x i64] [i64 4167226081738403131, i64 3182577365754989438, i64 3145059782000528535, i64 1908587119579612191, i64 -5505145643658166698, i64 -35068475227529450, i64 -6551043634737838411, i64 -8952410394250804024], i8 -27, [8 x i64] [i64 1989408495578506169, i64 8875049456664572427, i64 -5788068713638849056, i64 -3504821859896240944, i64 5609776781295056194, i64 -4624654902650315552, i64 5322217336720314881, i64 6523776427760859300], [8 x i64] [i64 -6115339861758452591, i64 -3392103532550036657, i64 -8905911280997723995, i64 -3169470619322538095, i64 6780953257077906595, i64 -7760976567172654164, i64 -5662123002377910520, i64 1465742945848830528], [8 x i64] [i64 -1018783500221922804, i64 3182577365754989438, i64 6854488180662297905, i64 1908587119579612191, i64 -5505145643658166698, i64 -3610360616641102562, i64 92847505509491666, i64 6523776427760859300] }, %struct.anon.16 { [8 x i64] [i64 8423875112645951354, i64 -992134513390816584, i64 5067471000037944706, i64 -8901892384488837648, i64 5646938436767971616, i64 667712002511424615, i64 6154730076122062365, i64 8302998700565148331], i8 38, [8 x i64] [i64 406180177802713927, i64 6291129798048412672, i64 1002352025414693184, i64 2313675762368028360, i64 -2095018376624810193, i64 5585413572559796467, i64 1853922086474170322, i64 2092813657477880595], [8 x i64] [i64 6540899458023253761, i64 776036648919423082, i64 -2832356497643057080, i64 -1469915197354033011, i64 -434715494469099978, i64 -3553561629042836116, i64 7359753537605494662, i64 -1392321784415393832], [8 x i64] [i64 8423875112645951354, i64 5623908779580314533, i64 4615601456026664049, i64 -8901892384488837648, i64 5646938436767971616, i64 59322120759728182, i64 6154730076122062365, i64 8302998700565148331] }, %struct.anon.16 { [8 x i64] [i64 9052657539321789464, i64 -3507791425865379075, i64 -6307222214754518983, i64 -1385112157411452635, i64 -3521191684596280940, i64 5791809541927748936, i64 -2462102611711329700, i64 -1588503665864851917], i8 -47, [8 x i64] [i64 -718480607320830328, i64 8269838137238067396, i64 201545723801235647, i64 5769746400960566465, i64 -1552028666969475889, i64 -6982806068119043154, i64 994175445110375174, i64 3814936344678769625], [8 x i64] [i64 -4313275168639942636, i64 -7913242855518603602, i64 4980744157524682694, i64 -2097314248011649716, i64 8265022055219239384, i64 7482221295816482231, i64 -6392691054873070697, i64 -2470721349831086586], [8 x i64] [i64 2947763600591887338, i64 -3507791425865379075, i64 -6307222214754518983, i64 -1385112157411452635, i64 1131758012287297152, i64 5791809541927748936, i64 8108181491781638548, i64 7265367784178399375] }], align 16
@test_simde_mm512_maskz_rorv_epi64.test_vec = internal constant [8 x %struct.anon.17] [%struct.anon.17 { i8 -43, [8 x i64] [i64 -7148606243591303982, i64 1789236256454807309, i64 5601663334537811741, i64 1838929107309793651, i64 4042253531198857212, i64 1586756880992457991, i64 616864043336825122, i64 1115552481879319067], [8 x i64] [i64 -6358903863494662052, i64 -6771274735657142537, i64 8768072374901068818, i64 33309311368914517, i64 -7257752406890905089, i64 -8745547970192352386, i64 5565846575989425510, i64 7991122348410673217], [8 x i64] [i64 4151418535940245489, i64 0, i64 3875157741769584029, i64 0, i64 8084507062397714424, i64 0, i64 5838694697561898538, i64 -8665595795915116275] }, %struct.anon.17 { i8 44, [8 x i64] [i64 3401460530648386926, i64 6408386783278740214, i64 680780152926417750, i64 -6005015472054445998, i64 -2776303267357755148, i64 -7209048843606746168, i64 3818558678564095236, i64 5872793273137985430], [8 x i64] [i64 4724014843803919059, i64 4975863242344493101, i64 -5895994657246357226, i64 891153319840702383, i64 4080068892402317542, i64 7262257046490872898, i64 -1560344186818067823, i64 -4273821631652570262], [8 x i64] [i64 0, i64 0, i64 4813600496062809285, i64 -3711816081197409965, i64 0, i64 2809423807525701362, i64 0, i64 0] }, %struct.anon.17 { i8 78, [8 x i64] [i64 4541476440441889650, i64 6018200336354609467, i64 7008858341171342927, i64 725647539839166318, i64 3902603255541033511, i64 -720103529709456035, i64 8413309071524925147, i64 3286864695150510843], [8 x i64] [i64 -7140950616379593803, i64 -7453092634890203148, i64 8166359238784410073, i64 -8290667490933699394, i64 4316456453163190028, i64 6162446550901862705, i64 -454712674807873591, i64 7023555302951597077], [8 x i64] [i64 0, i64 5698495232519419192, i64 5086577943727817581, i64 2902590159356665272, i64 0, i64 0, i64 7906738791433431111, i64 0] }, %struct.anon.17 { i8 -75, [8 x i64] [i64 -4321424209332097868, i64 -486505881546984179, i64 -2132123271595524406, i64 -9057133787511040534, i64 -8170830988153632188, i64 4308048670361967445, i64 1644367107041722049, i64 -1973143297129052083], [8 x i64] [i64 -6028536116175702458, i64 6835415977274661425, i64 -5799195537046672572, i64 8622818995257095206, i64 -1413403799120353954, i64 7559690154710785774, i64 8856149808542922453, i64 8663212754577961361], [8 x i64] [i64 -3238056390939643214, i64 0, i64 -5897865227508955156, i64 0, i64 6729830376441479687, i64 991706795134480165, i64 0, i64 299192846354746839] }, %struct.anon.17 { i8 79, [8 x i64] [i64 7996975182592486775, i64 -6430019384792414588, i64 -7799541994602431789, i64 3814307806269179061, i64 8380983337317104210, i64 -5704330246088367423, i64 -318451252073541344, i64 -5253295695601123034], [8 x i64] [i64 6118958763767060613, i64 -7901746473203315510, i64 103064760166332460, i64 1839435213883836777, i64 -3297346277291909291, i64 5389068352540492485, i64 -1232813643452883703, i64 1937184206966540596], [8 x i64] [i64 -4938241296274796181, i64 -6833736350899133279, i64 6778779111322631207, i64 6832055477708945298, i64 0, i64 0, i64 -8035043710330671000, i64 0] }, %struct.anon.17 { i8 97, [8 x i64] [i64 193438458996917105, i64 976834376054597556, i64 2271081220308890150, i64 -6853916578406904515, i64 4126486403088009730, i64 -874175731280681952, i64 3329788437296607679, i64 2081946270736194069], [8 x i64] [i64 -3992542601107509543, i64 7190129454450562567, i64 -1582540461015757591, i64 2233806610355959753, i64 788714884278607746, i64 -1336822503487599509, i64 7238358392564608180, i64 4101733310593016455], [8 x i64] [i64 3783508027628167285, i64 0, i64 0, i64 0, i64 0, i64 -5063673342056301623, i64 6669568695546409699, i64 0] }, %struct.anon.17 { i8 -89, [8 x i64] [i64 -2240062164156456343, i64 6264174385903761554, i64 -8218692280174676071, i64 1480975830707584670, i64 8940344456068085469, i64 7004404503104910963, i64 1915080407926842907, i64 3330848779069871738], [8 x i64] [i64 -4960027486929826621, i64 -6876489184088301464, i64 -7959768093580436493, i64 -2697956247357454065, i64 -4053607592947618117, i64 1781041866250606482, i64 -6373700028178407708, i64 -1329804124790242662], [8 x i64] [i64 4331678247907830861, i64 7654682272927772369, i64 3088709848917029310, i64 0, i64 0, i64 -4783710878259071059, i64 0, i64 4626778514419569737] }, %struct.anon.17 { i8 -124, [8 x i64] [i64 384683585302687762, i64 -9074963100529496670, i64 -2849439810570286391, i64 -4331628654224661048, i64 1412403438050330342, i64 -3607017145122241718, i64 -7726737919198164137, i64 -6001655882239979711], [8 x i64] [i64 7142948810124180635, i64 247630551233683101, i64 8371829085775664845, i64 -7856780280283651707, i64 -5849122508911003817, i64 3804626237701268509, i64 -469222685859201579, i64 6099347228479250973], [8 x i64] [i64 0, i64 0, i64 6219123253390528720, i64 0, i64 0, i64 0, i64 0, i64 -7521440129703039441] }], align 16

; Function Attrs: nounwind uwtable
define dso_local i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %retval1 = alloca i32, align 4
  %i = alloca i64, align 8
  %res = alloca i32, align 4
  store i32 0, ptr %retval, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %retval1) #13
  store i32 0, ptr %retval1, align 4, !tbaa !5
  %0 = load ptr, ptr @stdout, align 8, !tbaa !9
  %call = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %0, ptr noundef @.str, i64 noundef 18)
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %1, 18
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  br label %for.end

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 4, ptr %res) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [18 x %struct.anon], ptr @test_suite_tests, i64 0, i64 %2
  %func = getelementptr inbounds %struct.anon, ptr %arrayidx, i32 0, i32 0
  %3 = load ptr, ptr %func, align 16, !tbaa !13
  %call2 = call i32 %3()
  store i32 %call2, ptr %res, align 4, !tbaa !5
  %4 = load i32, ptr %res, align 4, !tbaa !5
  %cmp3 = icmp ne i32 %4, 0
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  store i32 1, ptr %retval1, align 4, !tbaa !5
  %5 = load ptr, ptr @stdout, align 8, !tbaa !9
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %add = add i64 %6, 1
  %7 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx4 = getelementptr inbounds [18 x %struct.anon], ptr @test_suite_tests, i64 0, i64 %7
  %name = getelementptr inbounds %struct.anon, ptr %arrayidx4, i32 0, i32 1
  %8 = load ptr, ptr %name, align 8, !tbaa !15
  %call5 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %5, ptr noundef @.str.1, i64 noundef %add, ptr noundef %8)
  br label %if.end

if.else:                                          ; preds = %for.body
  %9 = load ptr, ptr @stdout, align 8, !tbaa !9
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %add6 = add i64 %10, 1
  %11 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx7 = getelementptr inbounds [18 x %struct.anon], ptr @test_suite_tests, i64 0, i64 %11
  %name8 = getelementptr inbounds %struct.anon, ptr %arrayidx7, i32 0, i32 1
  %12 = load ptr, ptr %name8, align 8, !tbaa !15
  %call9 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %9, ptr noundef @.str.2, i64 noundef %add6, ptr noundef %12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %res) #13
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %13 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %13, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.end:                                          ; preds = %for.cond.cleanup
  %14 = load i32, ptr %retval1, align 4, !tbaa !5
  call void @llvm.lifetime.end.p0(i64 4, ptr %retval1) #13
  ret i32 %14
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

declare i32 @fprintf(ptr noundef, ptr noundef, ...) #2

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_rorv_epi32() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <2 x i64>, align 16
  %b = alloca <2 x i64>, align 16
  %r = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup14

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %a) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.0], ptr @test_simde_mm_rorv_epi32.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.0, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [4 x i32], ptr %a1, i64 0, i64 0
  %call = call <2 x i64> @simde_mm_loadu_epi32(ptr noundef %arraydecay)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %b) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.0], ptr @test_simde_mm_rorv_epi32.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.0, ptr %arrayidx2, i32 0, i32 1
  %arraydecay4 = getelementptr inbounds [4 x i32], ptr %b3, i64 0, i64 0
  %call5 = call <2 x i64> @simde_mm_loadu_epi32(ptr noundef %arraydecay4)
  store <2 x i64> %call5, ptr %b, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #13
  %3 = load <2 x i64>, ptr %a, align 16, !tbaa !16
  %4 = load <2 x i64>, ptr %b, align 16, !tbaa !16
  %call6 = call <2 x i64> @simde_mm_rorv_epi32(<2 x i64> noundef %3, <2 x i64> noundef %4)
  store <2 x i64> %call6, ptr %r, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx7 = getelementptr inbounds [8 x %struct.anon.0], ptr @test_simde_mm_rorv_epi32.test_vec, i64 0, i64 %6
  %r8 = getelementptr inbounds %struct.anon.0, ptr %arrayidx7, i32 0, i32 2
  %arraydecay9 = getelementptr inbounds [4 x i32], ptr %r8, i64 0, i64 0
  %call10 = call <2 x i64> @simde_mm_loadu_epi32(ptr noundef %arraydecay9)
  %call11 = call i32 @simde_test_x86_assert_equal_i32x4_(<2 x i64> noundef %5, <2 x i64> noundef %call10, ptr noundef @.str.21, i32 noundef 44, ptr noundef @.str.22, ptr noundef @.str.23)
  %tobool = icmp ne i32 %call11, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup14 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %7 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %7, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup14:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest15 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest15, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup14
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup14
  %8 = load i32, ptr %retval, align 4
  ret i32 %8

unreachable:                                      ; preds = %cleanup14
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_mask_rorv_epi32() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %src = alloca <2 x i64>, align 16
  %a = alloca <2 x i64>, align 16
  %b = alloca <2 x i64>, align 16
  %r = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup20

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %src) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.1], ptr @test_simde_mm_mask_rorv_epi32.test_vec, i64 0, i64 %1
  %src1 = getelementptr inbounds %struct.anon.1, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [4 x i32], ptr %src1, i64 0, i64 0
  %call = call <2 x i64> @simde_mm_loadu_epi32(ptr noundef %arraydecay)
  store <2 x i64> %call, ptr %src, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %a) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.1], ptr @test_simde_mm_mask_rorv_epi32.test_vec, i64 0, i64 %2
  %a3 = getelementptr inbounds %struct.anon.1, ptr %arrayidx2, i32 0, i32 2
  %arraydecay4 = getelementptr inbounds [4 x i32], ptr %a3, i64 0, i64 0
  %call5 = call <2 x i64> @simde_mm_loadu_epi32(ptr noundef %arraydecay4)
  store <2 x i64> %call5, ptr %a, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %b) #13
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx6 = getelementptr inbounds [8 x %struct.anon.1], ptr @test_simde_mm_mask_rorv_epi32.test_vec, i64 0, i64 %3
  %b7 = getelementptr inbounds %struct.anon.1, ptr %arrayidx6, i32 0, i32 3
  %arraydecay8 = getelementptr inbounds [4 x i32], ptr %b7, i64 0, i64 0
  %call9 = call <2 x i64> @simde_mm_loadu_epi32(ptr noundef %arraydecay8)
  store <2 x i64> %call9, ptr %b, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #13
  %4 = load <2 x i64>, ptr %src, align 16, !tbaa !16
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx10 = getelementptr inbounds [8 x %struct.anon.1], ptr @test_simde_mm_mask_rorv_epi32.test_vec, i64 0, i64 %5
  %k = getelementptr inbounds %struct.anon.1, ptr %arrayidx10, i32 0, i32 1
  %6 = load i8, ptr %k, align 4, !tbaa !17
  %7 = load <2 x i64>, ptr %a, align 16, !tbaa !16
  %8 = load <2 x i64>, ptr %b, align 16, !tbaa !16
  %call11 = call <2 x i64> @simde_mm_mask_rorv_epi32(<2 x i64> noundef %4, i8 noundef zeroext %6, <2 x i64> noundef %7, <2 x i64> noundef %8)
  store <2 x i64> %call11, ptr %r, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %9 = load <2 x i64>, ptr %r, align 16, !tbaa !16
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx12 = getelementptr inbounds [8 x %struct.anon.1], ptr @test_simde_mm_mask_rorv_epi32.test_vec, i64 0, i64 %10
  %r13 = getelementptr inbounds %struct.anon.1, ptr %arrayidx12, i32 0, i32 4
  %arraydecay14 = getelementptr inbounds [4 x i32], ptr %r13, i64 0, i64 0
  %call15 = call <2 x i64> @simde_mm_loadu_epi32(ptr noundef %arraydecay14)
  %call16 = call i32 @simde_test_x86_assert_equal_i32x4_(<2 x i64> noundef %9, <2 x i64> noundef %call15, ptr noundef @.str.21, i32 noundef 120, ptr noundef @.str.22, ptr noundef @.str.23)
  %tobool = icmp ne i32 %call16, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %src) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup20 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %11 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %11, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup20:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest21 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest21, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup20
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup20
  %12 = load i32, ptr %retval, align 4
  ret i32 %12

unreachable:                                      ; preds = %cleanup20
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_maskz_rorv_epi32() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <2 x i64>, align 16
  %b = alloca <2 x i64>, align 16
  %r = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup15

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %a) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.2], ptr @test_simde_mm_maskz_rorv_epi32.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.2, ptr %arrayidx, i32 0, i32 1
  %arraydecay = getelementptr inbounds [4 x i32], ptr %a1, i64 0, i64 0
  %call = call <2 x i64> @simde_mm_loadu_epi32(ptr noundef %arraydecay)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %b) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.2], ptr @test_simde_mm_maskz_rorv_epi32.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.2, ptr %arrayidx2, i32 0, i32 2
  %arraydecay4 = getelementptr inbounds [4 x i32], ptr %b3, i64 0, i64 0
  %call5 = call <2 x i64> @simde_mm_loadu_epi32(ptr noundef %arraydecay4)
  store <2 x i64> %call5, ptr %b, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #13
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx6 = getelementptr inbounds [8 x %struct.anon.2], ptr @test_simde_mm_maskz_rorv_epi32.test_vec, i64 0, i64 %3
  %k = getelementptr inbounds %struct.anon.2, ptr %arrayidx6, i32 0, i32 0
  %4 = load i8, ptr %k, align 4, !tbaa !19
  %5 = load <2 x i64>, ptr %a, align 16, !tbaa !16
  %6 = load <2 x i64>, ptr %b, align 16, !tbaa !16
  %call7 = call <2 x i64> @simde_mm_maskz_rorv_epi32(i8 noundef zeroext %4, <2 x i64> noundef %5, <2 x i64> noundef %6)
  store <2 x i64> %call7, ptr %r, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %7 = load <2 x i64>, ptr %r, align 16, !tbaa !16
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx8 = getelementptr inbounds [8 x %struct.anon.2], ptr @test_simde_mm_maskz_rorv_epi32.test_vec, i64 0, i64 %8
  %r9 = getelementptr inbounds %struct.anon.2, ptr %arrayidx8, i32 0, i32 3
  %arraydecay10 = getelementptr inbounds [4 x i32], ptr %r9, i64 0, i64 0
  %call11 = call <2 x i64> @simde_mm_loadu_epi32(ptr noundef %arraydecay10)
  %call12 = call i32 @simde_test_x86_assert_equal_i32x4_(<2 x i64> noundef %7, <2 x i64> noundef %call11, ptr noundef @.str.21, i32 noundef 190, ptr noundef @.str.22, ptr noundef @.str.23)
  %tobool = icmp ne i32 %call12, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup15 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %9 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %9, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup15:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest16 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest16, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup15
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup15
  %10 = load i32, ptr %retval, align 4
  ret i32 %10

unreachable:                                      ; preds = %cleanup15
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm256_rorv_epi32() #4 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <4 x i64>, align 32
  %b = alloca <4 x i64>, align 32
  %r = alloca <4 x i64>, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %indirect-arg-temp6 = alloca <4 x i64>, align 32
  %indirect-arg-temp12 = alloca <4 x i64>, align 32
  %indirect-arg-temp13 = alloca <4 x i64>, align 32
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup17

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 32, ptr %a) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.3], ptr @test_simde_mm256_rorv_epi32.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.3, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [8 x i32], ptr %a1, i64 0, i64 0
  %call = call <4 x i64> @simde_mm256_loadu_epi32(ptr noundef %arraydecay)
  store <4 x i64> %call, ptr %a, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %b) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.3], ptr @test_simde_mm256_rorv_epi32.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.3, ptr %arrayidx2, i32 0, i32 1
  %arraydecay4 = getelementptr inbounds [8 x i32], ptr %b3, i64 0, i64 0
  %call5 = call <4 x i64> @simde_mm256_loadu_epi32(ptr noundef %arraydecay4)
  store <4 x i64> %call5, ptr %b, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %r) #13
  %3 = load <4 x i64>, ptr %a, align 32, !tbaa !16
  %4 = load <4 x i64>, ptr %b, align 32, !tbaa !16
  store <4 x i64> %3, ptr %indirect-arg-temp, align 32, !tbaa !16
  store <4 x i64> %4, ptr %indirect-arg-temp6, align 32, !tbaa !16
  %call7 = call <4 x i64> @simde_mm256_rorv_epi32(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp6)
  store <4 x i64> %call7, ptr %r, align 32, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <4 x i64>, ptr %r, align 32, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx8 = getelementptr inbounds [8 x %struct.anon.3], ptr @test_simde_mm256_rorv_epi32.test_vec, i64 0, i64 %6
  %r9 = getelementptr inbounds %struct.anon.3, ptr %arrayidx8, i32 0, i32 2
  %arraydecay10 = getelementptr inbounds [8 x i32], ptr %r9, i64 0, i64 0
  %call11 = call <4 x i64> @simde_mm256_loadu_epi32(ptr noundef %arraydecay10)
  store <4 x i64> %5, ptr %indirect-arg-temp12, align 32, !tbaa !16
  store <4 x i64> %call11, ptr %indirect-arg-temp13, align 32, !tbaa !16
  %call14 = call i32 @simde_test_x86_assert_equal_i32x8_(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp12, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp13, ptr noundef @.str.21, i32 noundef 249, ptr noundef @.str.22, ptr noundef @.str.25)
  %tobool = icmp ne i32 %call14, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 32, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup17 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %7 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %7, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup17:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest18 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest18, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup17
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup17
  %8 = load i32, ptr %retval, align 4
  ret i32 %8

unreachable:                                      ; preds = %cleanup17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm256_mask_rorv_epi32() #4 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %src = alloca <4 x i64>, align 32
  %k = alloca i8, align 1
  %a = alloca <4 x i64>, align 32
  %b = alloca <4 x i64>, align 32
  %r = alloca <4 x i64>, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %indirect-arg-temp12 = alloca <4 x i64>, align 32
  %indirect-arg-temp13 = alloca <4 x i64>, align 32
  %indirect-arg-temp19 = alloca <4 x i64>, align 32
  %indirect-arg-temp20 = alloca <4 x i64>, align 32
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup26

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 32, ptr %src) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.4], ptr @test_simde_mm256_mask_rorv_epi32.test_vec, i64 0, i64 %1
  %src1 = getelementptr inbounds %struct.anon.4, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [8 x i32], ptr %src1, i64 0, i64 0
  %call = call <4 x i64> @simde_mm256_loadu_epi32(ptr noundef %arraydecay)
  store <4 x i64> %call, ptr %src, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 1, ptr %k) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.4], ptr @test_simde_mm256_mask_rorv_epi32.test_vec, i64 0, i64 %2
  %k3 = getelementptr inbounds %struct.anon.4, ptr %arrayidx2, i32 0, i32 1
  %3 = load i8, ptr %k3, align 4, !tbaa !21
  store i8 %3, ptr %k, align 1, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %a) #13
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx4 = getelementptr inbounds [8 x %struct.anon.4], ptr @test_simde_mm256_mask_rorv_epi32.test_vec, i64 0, i64 %4
  %a5 = getelementptr inbounds %struct.anon.4, ptr %arrayidx4, i32 0, i32 2
  %arraydecay6 = getelementptr inbounds [8 x i32], ptr %a5, i64 0, i64 0
  %call7 = call <4 x i64> @simde_mm256_loadu_epi32(ptr noundef %arraydecay6)
  store <4 x i64> %call7, ptr %a, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %b) #13
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx8 = getelementptr inbounds [8 x %struct.anon.4], ptr @test_simde_mm256_mask_rorv_epi32.test_vec, i64 0, i64 %5
  %b9 = getelementptr inbounds %struct.anon.4, ptr %arrayidx8, i32 0, i32 3
  %arraydecay10 = getelementptr inbounds [8 x i32], ptr %b9, i64 0, i64 0
  %call11 = call <4 x i64> @simde_mm256_loadu_epi32(ptr noundef %arraydecay10)
  store <4 x i64> %call11, ptr %b, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %r) #13
  %6 = load <4 x i64>, ptr %src, align 32, !tbaa !16
  %7 = load i8, ptr %k, align 1, !tbaa !16
  %8 = load <4 x i64>, ptr %a, align 32, !tbaa !16
  %9 = load <4 x i64>, ptr %b, align 32, !tbaa !16
  store <4 x i64> %6, ptr %indirect-arg-temp, align 32, !tbaa !16
  store <4 x i64> %8, ptr %indirect-arg-temp12, align 32, !tbaa !16
  store <4 x i64> %9, ptr %indirect-arg-temp13, align 32, !tbaa !16
  %call14 = call <4 x i64> @simde_mm256_mask_rorv_epi32(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp, i8 noundef zeroext %7, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp12, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp13)
  store <4 x i64> %call14, ptr %r, align 32, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %10 = load <4 x i64>, ptr %r, align 32, !tbaa !16
  %11 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx15 = getelementptr inbounds [8 x %struct.anon.4], ptr @test_simde_mm256_mask_rorv_epi32.test_vec, i64 0, i64 %11
  %r16 = getelementptr inbounds %struct.anon.4, ptr %arrayidx15, i32 0, i32 4
  %arraydecay17 = getelementptr inbounds [8 x i32], ptr %r16, i64 0, i64 0
  %call18 = call <4 x i64> @simde_mm256_loadu_epi32(ptr noundef %arraydecay17)
  store <4 x i64> %10, ptr %indirect-arg-temp19, align 32, !tbaa !16
  store <4 x i64> %call18, ptr %indirect-arg-temp20, align 32, !tbaa !16
  %call21 = call i32 @simde_test_x86_assert_equal_i32x8_(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp19, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp20, ptr noundef @.str.21, i32 noundef 326, ptr noundef @.str.22, ptr noundef @.str.25)
  %tobool = icmp ne i32 %call21, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 32, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a) #13
  call void @llvm.lifetime.end.p0(i64 1, ptr %k) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %src) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup26 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %12 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %12, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup26:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest27 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest27, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup26
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup26
  %13 = load i32, ptr %retval, align 4
  ret i32 %13

unreachable:                                      ; preds = %cleanup26
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm256_maskz_rorv_epi32() #4 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %k = alloca i8, align 1
  %a = alloca <4 x i64>, align 32
  %b = alloca <4 x i64>, align 32
  %r = alloca <4 x i64>, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %indirect-arg-temp8 = alloca <4 x i64>, align 32
  %indirect-arg-temp14 = alloca <4 x i64>, align 32
  %indirect-arg-temp15 = alloca <4 x i64>, align 32
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup20

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %k) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.5], ptr @test_simde_mm256_maskz_rorv_epi32.test_vec, i64 0, i64 %1
  %k1 = getelementptr inbounds %struct.anon.5, ptr %arrayidx, i32 0, i32 0
  %2 = load i8, ptr %k1, align 4, !tbaa !23
  store i8 %2, ptr %k, align 1, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %a) #13
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.5], ptr @test_simde_mm256_maskz_rorv_epi32.test_vec, i64 0, i64 %3
  %a3 = getelementptr inbounds %struct.anon.5, ptr %arrayidx2, i32 0, i32 1
  %arraydecay = getelementptr inbounds [8 x i32], ptr %a3, i64 0, i64 0
  %call = call <4 x i64> @simde_mm256_loadu_epi32(ptr noundef %arraydecay)
  store <4 x i64> %call, ptr %a, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %b) #13
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx4 = getelementptr inbounds [8 x %struct.anon.5], ptr @test_simde_mm256_maskz_rorv_epi32.test_vec, i64 0, i64 %4
  %b5 = getelementptr inbounds %struct.anon.5, ptr %arrayidx4, i32 0, i32 2
  %arraydecay6 = getelementptr inbounds [8 x i32], ptr %b5, i64 0, i64 0
  %call7 = call <4 x i64> @simde_mm256_loadu_epi32(ptr noundef %arraydecay6)
  store <4 x i64> %call7, ptr %b, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %r) #13
  %5 = load i8, ptr %k, align 1, !tbaa !16
  %6 = load <4 x i64>, ptr %a, align 32, !tbaa !16
  %7 = load <4 x i64>, ptr %b, align 32, !tbaa !16
  store <4 x i64> %6, ptr %indirect-arg-temp, align 32, !tbaa !16
  store <4 x i64> %7, ptr %indirect-arg-temp8, align 32, !tbaa !16
  %call9 = call <4 x i64> @simde_mm256_maskz_rorv_epi32(i8 noundef zeroext %5, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp8)
  store <4 x i64> %call9, ptr %r, align 32, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %8 = load <4 x i64>, ptr %r, align 32, !tbaa !16
  %9 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx10 = getelementptr inbounds [8 x %struct.anon.5], ptr @test_simde_mm256_maskz_rorv_epi32.test_vec, i64 0, i64 %9
  %r11 = getelementptr inbounds %struct.anon.5, ptr %arrayidx10, i32 0, i32 3
  %arraydecay12 = getelementptr inbounds [8 x i32], ptr %r11, i64 0, i64 0
  %call13 = call <4 x i64> @simde_mm256_loadu_epi32(ptr noundef %arraydecay12)
  store <4 x i64> %8, ptr %indirect-arg-temp14, align 32, !tbaa !16
  store <4 x i64> %call13, ptr %indirect-arg-temp15, align 32, !tbaa !16
  %call16 = call i32 @simde_test_x86_assert_equal_i32x8_(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp14, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp15, ptr noundef @.str.21, i32 noundef 397, ptr noundef @.str.22, ptr noundef @.str.25)
  %tobool = icmp ne i32 %call16, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 32, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a) #13
  call void @llvm.lifetime.end.p0(i64 1, ptr %k) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup20 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %10, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup20:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest21 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest21, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup20
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup20
  %11 = load i32, ptr %retval, align 4
  ret i32 %11

unreachable:                                      ; preds = %cleanup20
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm512_rorv_epi32() #5 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <8 x i64>, align 64
  %b = alloca <8 x i64>, align 64
  %r = alloca <8 x i64>, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp6 = alloca <8 x i64>, align 64
  %indirect-arg-temp12 = alloca <8 x i64>, align 64
  %indirect-arg-temp13 = alloca <8 x i64>, align 64
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup17

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 64, ptr %a) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.6], ptr @test_simde_mm512_rorv_epi32.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.6, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i32], ptr %a1, i64 0, i64 0
  %call = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay)
  store <8 x i64> %call, ptr %a, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %b) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.6], ptr @test_simde_mm512_rorv_epi32.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.6, ptr %arrayidx2, i32 0, i32 1
  %arraydecay4 = getelementptr inbounds [16 x i32], ptr %b3, i64 0, i64 0
  %call5 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay4)
  store <8 x i64> %call5, ptr %b, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  %3 = load <8 x i64>, ptr %a, align 64, !tbaa !16
  %4 = load <8 x i64>, ptr %b, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %4, ptr %indirect-arg-temp6, align 64, !tbaa !16
  %call7 = call <8 x i64> @simde_mm512_rorv_epi32(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp6)
  store <8 x i64> %call7, ptr %r, align 64, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <8 x i64>, ptr %r, align 64, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx8 = getelementptr inbounds [8 x %struct.anon.6], ptr @test_simde_mm512_rorv_epi32.test_vec, i64 0, i64 %6
  %r9 = getelementptr inbounds %struct.anon.6, ptr %arrayidx8, i32 0, i32 2
  %arraydecay10 = getelementptr inbounds [16 x i32], ptr %r9, i64 0, i64 0
  %call11 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay10)
  store <8 x i64> %5, ptr %indirect-arg-temp12, align 64, !tbaa !16
  store <8 x i64> %call11, ptr %indirect-arg-temp13, align 64, !tbaa !16
  %call14 = call i32 @simde_test_x86_assert_equal_i32x16_(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp12, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp13, ptr noundef @.str.21, i32 noundef 480, ptr noundef @.str.22, ptr noundef @.str.26)
  %tobool = icmp ne i32 %call14, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup17 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %7 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %7, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup17:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest18 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest18, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup17
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup17
  %8 = load i32, ptr %retval, align 4
  ret i32 %8

unreachable:                                      ; preds = %cleanup17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm512_mask_rorv_epi32() #5 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %src = alloca <8 x i64>, align 64
  %a = alloca <8 x i64>, align 64
  %b = alloca <8 x i64>, align 64
  %r = alloca <8 x i64>, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp11 = alloca <8 x i64>, align 64
  %indirect-arg-temp12 = alloca <8 x i64>, align 64
  %indirect-arg-temp18 = alloca <8 x i64>, align 64
  %indirect-arg-temp19 = alloca <8 x i64>, align 64
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup24

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 64, ptr %src) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.7], ptr @test_simde_mm512_mask_rorv_epi32.test_vec, i64 0, i64 %1
  %src1 = getelementptr inbounds %struct.anon.7, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i32], ptr %src1, i64 0, i64 0
  %call = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay)
  store <8 x i64> %call, ptr %src, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %a) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.7], ptr @test_simde_mm512_mask_rorv_epi32.test_vec, i64 0, i64 %2
  %a3 = getelementptr inbounds %struct.anon.7, ptr %arrayidx2, i32 0, i32 2
  %arraydecay4 = getelementptr inbounds [16 x i32], ptr %a3, i64 0, i64 0
  %call5 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay4)
  store <8 x i64> %call5, ptr %a, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %b) #13
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx6 = getelementptr inbounds [8 x %struct.anon.7], ptr @test_simde_mm512_mask_rorv_epi32.test_vec, i64 0, i64 %3
  %b7 = getelementptr inbounds %struct.anon.7, ptr %arrayidx6, i32 0, i32 3
  %arraydecay8 = getelementptr inbounds [16 x i32], ptr %b7, i64 0, i64 0
  %call9 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay8)
  store <8 x i64> %call9, ptr %b, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  %4 = load <8 x i64>, ptr %src, align 64, !tbaa !16
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx10 = getelementptr inbounds [8 x %struct.anon.7], ptr @test_simde_mm512_mask_rorv_epi32.test_vec, i64 0, i64 %5
  %k = getelementptr inbounds %struct.anon.7, ptr %arrayidx10, i32 0, i32 1
  %6 = load i16, ptr %k, align 4, !tbaa !25
  %7 = load <8 x i64>, ptr %a, align 64, !tbaa !16
  %8 = load <8 x i64>, ptr %b, align 64, !tbaa !16
  store <8 x i64> %4, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %7, ptr %indirect-arg-temp11, align 64, !tbaa !16
  store <8 x i64> %8, ptr %indirect-arg-temp12, align 64, !tbaa !16
  %call13 = call <8 x i64> @simde_mm512_mask_rorv_epi32(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, i16 noundef zeroext %6, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp11, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp12)
  store <8 x i64> %call13, ptr %r, align 64, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %9 = load <8 x i64>, ptr %r, align 64, !tbaa !16
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx14 = getelementptr inbounds [8 x %struct.anon.7], ptr @test_simde_mm512_mask_rorv_epi32.test_vec, i64 0, i64 %10
  %r15 = getelementptr inbounds %struct.anon.7, ptr %arrayidx14, i32 0, i32 4
  %arraydecay16 = getelementptr inbounds [16 x i32], ptr %r15, i64 0, i64 0
  %call17 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay16)
  store <8 x i64> %9, ptr %indirect-arg-temp18, align 64, !tbaa !16
  store <8 x i64> %call17, ptr %indirect-arg-temp19, align 64, !tbaa !16
  %call20 = call i32 @simde_test_x86_assert_equal_i32x16_(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp18, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp19, ptr noundef @.str.21, i32 noundef 588, ptr noundef @.str.22, ptr noundef @.str.26)
  %tobool = icmp ne i32 %call20, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %src) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup24 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %11 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %11, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup24:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest25 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest25, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup24
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup24
  %12 = load i32, ptr %retval, align 4
  ret i32 %12

unreachable:                                      ; preds = %cleanup24
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm512_maskz_rorv_epi32() #5 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <8 x i64>, align 64
  %b = alloca <8 x i64>, align 64
  %r = alloca <8 x i64>, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp7 = alloca <8 x i64>, align 64
  %indirect-arg-temp13 = alloca <8 x i64>, align 64
  %indirect-arg-temp14 = alloca <8 x i64>, align 64
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup18

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 64, ptr %a) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.8], ptr @test_simde_mm512_maskz_rorv_epi32.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.8, ptr %arrayidx, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i32], ptr %a1, i64 0, i64 0
  %call = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay)
  store <8 x i64> %call, ptr %a, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %b) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.8], ptr @test_simde_mm512_maskz_rorv_epi32.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.8, ptr %arrayidx2, i32 0, i32 2
  %arraydecay4 = getelementptr inbounds [16 x i32], ptr %b3, i64 0, i64 0
  %call5 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay4)
  store <8 x i64> %call5, ptr %b, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx6 = getelementptr inbounds [8 x %struct.anon.8], ptr @test_simde_mm512_maskz_rorv_epi32.test_vec, i64 0, i64 %3
  %k = getelementptr inbounds %struct.anon.8, ptr %arrayidx6, i32 0, i32 0
  %4 = load i16, ptr %k, align 4, !tbaa !28
  %5 = load <8 x i64>, ptr %a, align 64, !tbaa !16
  %6 = load <8 x i64>, ptr %b, align 64, !tbaa !16
  store <8 x i64> %5, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %6, ptr %indirect-arg-temp7, align 64, !tbaa !16
  %call8 = call <8 x i64> @simde_mm512_maskz_rorv_epi32(i16 noundef zeroext %4, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp7)
  store <8 x i64> %call8, ptr %r, align 64, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %7 = load <8 x i64>, ptr %r, align 64, !tbaa !16
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx9 = getelementptr inbounds [8 x %struct.anon.8], ptr @test_simde_mm512_maskz_rorv_epi32.test_vec, i64 0, i64 %8
  %r10 = getelementptr inbounds %struct.anon.8, ptr %arrayidx9, i32 0, i32 3
  %arraydecay11 = getelementptr inbounds [16 x i32], ptr %r10, i64 0, i64 0
  %call12 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay11)
  store <8 x i64> %7, ptr %indirect-arg-temp13, align 64, !tbaa !16
  store <8 x i64> %call12, ptr %indirect-arg-temp14, align 64, !tbaa !16
  %call15 = call i32 @simde_test_x86_assert_equal_i32x16_(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp13, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp14, ptr noundef @.str.21, i32 noundef 682, ptr noundef @.str.22, ptr noundef @.str.26)
  %tobool = icmp ne i32 %call15, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup18 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %9 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %9, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup18:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest19 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest19, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup18
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup18
  %10 = load i32, ptr %retval, align 4
  ret i32 %10

unreachable:                                      ; preds = %cleanup18
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_rorv_epi64() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <2 x i64>, align 16
  %b = alloca <2 x i64>, align 16
  %r = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup14

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %a) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.9], ptr @test_simde_mm_rorv_epi64.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.9, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [2 x i64], ptr %a1, i64 0, i64 0
  %call = call <2 x i64> @simde_mm_loadu_epi64(ptr noundef %arraydecay)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %b) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.9], ptr @test_simde_mm_rorv_epi64.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.9, ptr %arrayidx2, i32 0, i32 1
  %arraydecay4 = getelementptr inbounds [2 x i64], ptr %b3, i64 0, i64 0
  %call5 = call <2 x i64> @simde_mm_loadu_epi64(ptr noundef %arraydecay4)
  store <2 x i64> %call5, ptr %b, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #13
  %3 = load <2 x i64>, ptr %a, align 16, !tbaa !16
  %4 = load <2 x i64>, ptr %b, align 16, !tbaa !16
  %call6 = call <2 x i64> @simde_mm_rorv_epi64(<2 x i64> noundef %3, <2 x i64> noundef %4)
  store <2 x i64> %call6, ptr %r, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx7 = getelementptr inbounds [8 x %struct.anon.9], ptr @test_simde_mm_rorv_epi64.test_vec, i64 0, i64 %6
  %r8 = getelementptr inbounds %struct.anon.9, ptr %arrayidx7, i32 0, i32 2
  %arraydecay9 = getelementptr inbounds [2 x i64], ptr %r8, i64 0, i64 0
  %call10 = call <2 x i64> @simde_mm_loadu_epi64(ptr noundef %arraydecay9)
  %call11 = call i32 @simde_test_x86_assert_equal_i64x2_(<2 x i64> noundef %5, <2 x i64> noundef %call10, ptr noundef @.str.21, i32 noundef 741, ptr noundef @.str.22, ptr noundef @.str.27)
  %tobool = icmp ne i32 %call11, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup14 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %7 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %7, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup14:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest15 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest15, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup14
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup14
  %8 = load i32, ptr %retval, align 4
  ret i32 %8

unreachable:                                      ; preds = %cleanup14
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_mask_rorv_epi64() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %src = alloca <2 x i64>, align 16
  %a = alloca <2 x i64>, align 16
  %b = alloca <2 x i64>, align 16
  %r = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup20

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %src) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.10], ptr @test_simde_mm_mask_rorv_epi64.test_vec, i64 0, i64 %1
  %src1 = getelementptr inbounds %struct.anon.10, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [2 x i64], ptr %src1, i64 0, i64 0
  %call = call <2 x i64> @simde_mm_loadu_epi64(ptr noundef %arraydecay)
  store <2 x i64> %call, ptr %src, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %a) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.10], ptr @test_simde_mm_mask_rorv_epi64.test_vec, i64 0, i64 %2
  %a3 = getelementptr inbounds %struct.anon.10, ptr %arrayidx2, i32 0, i32 2
  %arraydecay4 = getelementptr inbounds [2 x i64], ptr %a3, i64 0, i64 0
  %call5 = call <2 x i64> @simde_mm_loadu_epi64(ptr noundef %arraydecay4)
  store <2 x i64> %call5, ptr %a, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %b) #13
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx6 = getelementptr inbounds [8 x %struct.anon.10], ptr @test_simde_mm_mask_rorv_epi64.test_vec, i64 0, i64 %3
  %b7 = getelementptr inbounds %struct.anon.10, ptr %arrayidx6, i32 0, i32 3
  %arraydecay8 = getelementptr inbounds [2 x i64], ptr %b7, i64 0, i64 0
  %call9 = call <2 x i64> @simde_mm_loadu_epi64(ptr noundef %arraydecay8)
  store <2 x i64> %call9, ptr %b, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #13
  %4 = load <2 x i64>, ptr %src, align 16, !tbaa !16
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx10 = getelementptr inbounds [8 x %struct.anon.10], ptr @test_simde_mm_mask_rorv_epi64.test_vec, i64 0, i64 %5
  %k = getelementptr inbounds %struct.anon.10, ptr %arrayidx10, i32 0, i32 1
  %6 = load i8, ptr %k, align 8, !tbaa !30
  %7 = load <2 x i64>, ptr %a, align 16, !tbaa !16
  %8 = load <2 x i64>, ptr %b, align 16, !tbaa !16
  %call11 = call <2 x i64> @simde_mm_mask_rorv_epi64(<2 x i64> noundef %4, i8 noundef zeroext %6, <2 x i64> noundef %7, <2 x i64> noundef %8)
  store <2 x i64> %call11, ptr %r, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %9 = load <2 x i64>, ptr %r, align 16, !tbaa !16
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx12 = getelementptr inbounds [8 x %struct.anon.10], ptr @test_simde_mm_mask_rorv_epi64.test_vec, i64 0, i64 %10
  %r13 = getelementptr inbounds %struct.anon.10, ptr %arrayidx12, i32 0, i32 4
  %arraydecay14 = getelementptr inbounds [2 x i64], ptr %r13, i64 0, i64 0
  %call15 = call <2 x i64> @simde_mm_loadu_epi64(ptr noundef %arraydecay14)
  %call16 = call i32 @simde_test_x86_assert_equal_i64x2_(<2 x i64> noundef %9, <2 x i64> noundef %call15, ptr noundef @.str.21, i32 noundef 817, ptr noundef @.str.22, ptr noundef @.str.27)
  %tobool = icmp ne i32 %call16, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %src) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup20 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %11 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %11, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup20:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest21 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest21, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup20
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup20
  %12 = load i32, ptr %retval, align 4
  ret i32 %12

unreachable:                                      ; preds = %cleanup20
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_maskz_rorv_epi64() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <2 x i64>, align 16
  %b = alloca <2 x i64>, align 16
  %r = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup15

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %a) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.11], ptr @test_simde_mm_maskz_rorv_epi64.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.11, ptr %arrayidx, i32 0, i32 1
  %arraydecay = getelementptr inbounds [2 x i64], ptr %a1, i64 0, i64 0
  %call = call <2 x i64> @simde_mm_loadu_epi64(ptr noundef %arraydecay)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %b) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.11], ptr @test_simde_mm_maskz_rorv_epi64.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.11, ptr %arrayidx2, i32 0, i32 2
  %arraydecay4 = getelementptr inbounds [2 x i64], ptr %b3, i64 0, i64 0
  %call5 = call <2 x i64> @simde_mm_loadu_epi64(ptr noundef %arraydecay4)
  store <2 x i64> %call5, ptr %b, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #13
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx6 = getelementptr inbounds [8 x %struct.anon.11], ptr @test_simde_mm_maskz_rorv_epi64.test_vec, i64 0, i64 %3
  %k = getelementptr inbounds %struct.anon.11, ptr %arrayidx6, i32 0, i32 0
  %4 = load i8, ptr %k, align 8, !tbaa !32
  %5 = load <2 x i64>, ptr %a, align 16, !tbaa !16
  %6 = load <2 x i64>, ptr %b, align 16, !tbaa !16
  %call7 = call <2 x i64> @simde_mm_maskz_rorv_epi64(i8 noundef zeroext %4, <2 x i64> noundef %5, <2 x i64> noundef %6)
  store <2 x i64> %call7, ptr %r, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %7 = load <2 x i64>, ptr %r, align 16, !tbaa !16
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx8 = getelementptr inbounds [8 x %struct.anon.11], ptr @test_simde_mm_maskz_rorv_epi64.test_vec, i64 0, i64 %8
  %r9 = getelementptr inbounds %struct.anon.11, ptr %arrayidx8, i32 0, i32 3
  %arraydecay10 = getelementptr inbounds [2 x i64], ptr %r9, i64 0, i64 0
  %call11 = call <2 x i64> @simde_mm_loadu_epi64(ptr noundef %arraydecay10)
  %call12 = call i32 @simde_test_x86_assert_equal_i64x2_(<2 x i64> noundef %7, <2 x i64> noundef %call11, ptr noundef @.str.21, i32 noundef 887, ptr noundef @.str.22, ptr noundef @.str.27)
  %tobool = icmp ne i32 %call12, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup15 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %9 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %9, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup15:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest16 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest16, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup15
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup15
  %10 = load i32, ptr %retval, align 4
  ret i32 %10

unreachable:                                      ; preds = %cleanup15
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm256_rorv_epi64() #4 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <4 x i64>, align 32
  %b = alloca <4 x i64>, align 32
  %r = alloca <4 x i64>, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %indirect-arg-temp6 = alloca <4 x i64>, align 32
  %indirect-arg-temp12 = alloca <4 x i64>, align 32
  %indirect-arg-temp13 = alloca <4 x i64>, align 32
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup17

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 32, ptr %a) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.12], ptr @test_simde_mm256_rorv_epi64.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.12, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [4 x i64], ptr %a1, i64 0, i64 0
  %call = call <4 x i64> @simde_mm256_loadu_epi64(ptr noundef %arraydecay)
  store <4 x i64> %call, ptr %a, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %b) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.12], ptr @test_simde_mm256_rorv_epi64.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.12, ptr %arrayidx2, i32 0, i32 1
  %arraydecay4 = getelementptr inbounds [4 x i64], ptr %b3, i64 0, i64 0
  %call5 = call <4 x i64> @simde_mm256_loadu_epi64(ptr noundef %arraydecay4)
  store <4 x i64> %call5, ptr %b, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %r) #13
  %3 = load <4 x i64>, ptr %a, align 32, !tbaa !16
  %4 = load <4 x i64>, ptr %b, align 32, !tbaa !16
  store <4 x i64> %3, ptr %indirect-arg-temp, align 32, !tbaa !16
  store <4 x i64> %4, ptr %indirect-arg-temp6, align 32, !tbaa !16
  %call7 = call <4 x i64> @simde_mm256_rorv_epi64(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp6)
  store <4 x i64> %call7, ptr %r, align 32, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <4 x i64>, ptr %r, align 32, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx8 = getelementptr inbounds [8 x %struct.anon.12], ptr @test_simde_mm256_rorv_epi64.test_vec, i64 0, i64 %6
  %r9 = getelementptr inbounds %struct.anon.12, ptr %arrayidx8, i32 0, i32 2
  %arraydecay10 = getelementptr inbounds [4 x i64], ptr %r9, i64 0, i64 0
  %call11 = call <4 x i64> @simde_mm256_loadu_epi64(ptr noundef %arraydecay10)
  store <4 x i64> %5, ptr %indirect-arg-temp12, align 32, !tbaa !16
  store <4 x i64> %call11, ptr %indirect-arg-temp13, align 32, !tbaa !16
  %call14 = call i32 @simde_test_x86_assert_equal_i64x4_(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp12, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp13, ptr noundef @.str.21, i32 noundef 946, ptr noundef @.str.22, ptr noundef @.str.29)
  %tobool = icmp ne i32 %call14, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 32, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup17 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %7 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %7, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup17:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest18 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest18, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup17
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup17
  %8 = load i32, ptr %retval, align 4
  ret i32 %8

unreachable:                                      ; preds = %cleanup17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm256_mask_rorv_epi64() #4 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %src = alloca <4 x i64>, align 32
  %k = alloca i8, align 1
  %a = alloca <4 x i64>, align 32
  %b = alloca <4 x i64>, align 32
  %r = alloca <4 x i64>, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %indirect-arg-temp12 = alloca <4 x i64>, align 32
  %indirect-arg-temp13 = alloca <4 x i64>, align 32
  %indirect-arg-temp19 = alloca <4 x i64>, align 32
  %indirect-arg-temp20 = alloca <4 x i64>, align 32
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup26

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 32, ptr %src) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.13], ptr @test_simde_mm256_mask_rorv_epi64.test_vec, i64 0, i64 %1
  %src1 = getelementptr inbounds %struct.anon.13, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [4 x i64], ptr %src1, i64 0, i64 0
  %call = call <4 x i64> @simde_mm256_loadu_epi64(ptr noundef %arraydecay)
  store <4 x i64> %call, ptr %src, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 1, ptr %k) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.13], ptr @test_simde_mm256_mask_rorv_epi64.test_vec, i64 0, i64 %2
  %k3 = getelementptr inbounds %struct.anon.13, ptr %arrayidx2, i32 0, i32 1
  %3 = load i8, ptr %k3, align 8, !tbaa !34
  store i8 %3, ptr %k, align 1, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %a) #13
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx4 = getelementptr inbounds [8 x %struct.anon.13], ptr @test_simde_mm256_mask_rorv_epi64.test_vec, i64 0, i64 %4
  %a5 = getelementptr inbounds %struct.anon.13, ptr %arrayidx4, i32 0, i32 2
  %arraydecay6 = getelementptr inbounds [4 x i64], ptr %a5, i64 0, i64 0
  %call7 = call <4 x i64> @simde_mm256_loadu_epi64(ptr noundef %arraydecay6)
  store <4 x i64> %call7, ptr %a, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %b) #13
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx8 = getelementptr inbounds [8 x %struct.anon.13], ptr @test_simde_mm256_mask_rorv_epi64.test_vec, i64 0, i64 %5
  %b9 = getelementptr inbounds %struct.anon.13, ptr %arrayidx8, i32 0, i32 3
  %arraydecay10 = getelementptr inbounds [4 x i64], ptr %b9, i64 0, i64 0
  %call11 = call <4 x i64> @simde_mm256_loadu_epi64(ptr noundef %arraydecay10)
  store <4 x i64> %call11, ptr %b, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %r) #13
  %6 = load <4 x i64>, ptr %src, align 32, !tbaa !16
  %7 = load i8, ptr %k, align 1, !tbaa !16
  %8 = load <4 x i64>, ptr %a, align 32, !tbaa !16
  %9 = load <4 x i64>, ptr %b, align 32, !tbaa !16
  store <4 x i64> %6, ptr %indirect-arg-temp, align 32, !tbaa !16
  store <4 x i64> %8, ptr %indirect-arg-temp12, align 32, !tbaa !16
  store <4 x i64> %9, ptr %indirect-arg-temp13, align 32, !tbaa !16
  %call14 = call <4 x i64> @simde_mm256_mask_rorv_epi64(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp, i8 noundef zeroext %7, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp12, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp13)
  store <4 x i64> %call14, ptr %r, align 32, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %10 = load <4 x i64>, ptr %r, align 32, !tbaa !16
  %11 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx15 = getelementptr inbounds [8 x %struct.anon.13], ptr @test_simde_mm256_mask_rorv_epi64.test_vec, i64 0, i64 %11
  %r16 = getelementptr inbounds %struct.anon.13, ptr %arrayidx15, i32 0, i32 4
  %arraydecay17 = getelementptr inbounds [4 x i64], ptr %r16, i64 0, i64 0
  %call18 = call <4 x i64> @simde_mm256_loadu_epi64(ptr noundef %arraydecay17)
  store <4 x i64> %10, ptr %indirect-arg-temp19, align 32, !tbaa !16
  store <4 x i64> %call18, ptr %indirect-arg-temp20, align 32, !tbaa !16
  %call21 = call i32 @simde_test_x86_assert_equal_i64x4_(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp19, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp20, ptr noundef @.str.21, i32 noundef 1023, ptr noundef @.str.22, ptr noundef @.str.29)
  %tobool = icmp ne i32 %call21, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 32, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a) #13
  call void @llvm.lifetime.end.p0(i64 1, ptr %k) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %src) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup26 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %12 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %12, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup26:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest27 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest27, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup26
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup26
  %13 = load i32, ptr %retval, align 4
  ret i32 %13

unreachable:                                      ; preds = %cleanup26
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm256_maskz_rorv_epi64() #4 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %k = alloca i8, align 1
  %a = alloca <4 x i64>, align 32
  %b = alloca <4 x i64>, align 32
  %r = alloca <4 x i64>, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %indirect-arg-temp8 = alloca <4 x i64>, align 32
  %indirect-arg-temp14 = alloca <4 x i64>, align 32
  %indirect-arg-temp15 = alloca <4 x i64>, align 32
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup20

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %k) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.14], ptr @test_simde_mm256_maskz_rorv_epi64.test_vec, i64 0, i64 %1
  %k1 = getelementptr inbounds %struct.anon.14, ptr %arrayidx, i32 0, i32 0
  %2 = load i8, ptr %k1, align 8, !tbaa !36
  store i8 %2, ptr %k, align 1, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %a) #13
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.14], ptr @test_simde_mm256_maskz_rorv_epi64.test_vec, i64 0, i64 %3
  %a3 = getelementptr inbounds %struct.anon.14, ptr %arrayidx2, i32 0, i32 1
  %arraydecay = getelementptr inbounds [4 x i64], ptr %a3, i64 0, i64 0
  %call = call <4 x i64> @simde_mm256_loadu_epi64(ptr noundef %arraydecay)
  store <4 x i64> %call, ptr %a, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %b) #13
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx4 = getelementptr inbounds [8 x %struct.anon.14], ptr @test_simde_mm256_maskz_rorv_epi64.test_vec, i64 0, i64 %4
  %b5 = getelementptr inbounds %struct.anon.14, ptr %arrayidx4, i32 0, i32 2
  %arraydecay6 = getelementptr inbounds [4 x i64], ptr %b5, i64 0, i64 0
  %call7 = call <4 x i64> @simde_mm256_loadu_epi64(ptr noundef %arraydecay6)
  store <4 x i64> %call7, ptr %b, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %r) #13
  %5 = load i8, ptr %k, align 1, !tbaa !16
  %6 = load <4 x i64>, ptr %a, align 32, !tbaa !16
  %7 = load <4 x i64>, ptr %b, align 32, !tbaa !16
  store <4 x i64> %6, ptr %indirect-arg-temp, align 32, !tbaa !16
  store <4 x i64> %7, ptr %indirect-arg-temp8, align 32, !tbaa !16
  %call9 = call <4 x i64> @simde_mm256_maskz_rorv_epi64(i8 noundef zeroext %5, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp8)
  store <4 x i64> %call9, ptr %r, align 32, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %8 = load <4 x i64>, ptr %r, align 32, !tbaa !16
  %9 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx10 = getelementptr inbounds [8 x %struct.anon.14], ptr @test_simde_mm256_maskz_rorv_epi64.test_vec, i64 0, i64 %9
  %r11 = getelementptr inbounds %struct.anon.14, ptr %arrayidx10, i32 0, i32 3
  %arraydecay12 = getelementptr inbounds [4 x i64], ptr %r11, i64 0, i64 0
  %call13 = call <4 x i64> @simde_mm256_loadu_epi64(ptr noundef %arraydecay12)
  store <4 x i64> %8, ptr %indirect-arg-temp14, align 32, !tbaa !16
  store <4 x i64> %call13, ptr %indirect-arg-temp15, align 32, !tbaa !16
  %call16 = call i32 @simde_test_x86_assert_equal_i64x4_(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp14, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp15, ptr noundef @.str.21, i32 noundef 1094, ptr noundef @.str.22, ptr noundef @.str.29)
  %tobool = icmp ne i32 %call16, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 32, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a) #13
  call void @llvm.lifetime.end.p0(i64 1, ptr %k) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup20 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %10, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup20:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest21 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest21, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup20
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup20
  %11 = load i32, ptr %retval, align 4
  ret i32 %11

unreachable:                                      ; preds = %cleanup20
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm512_rorv_epi64() #5 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <8 x i64>, align 64
  %b = alloca <8 x i64>, align 64
  %r = alloca <8 x i64>, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp6 = alloca <8 x i64>, align 64
  %indirect-arg-temp12 = alloca <8 x i64>, align 64
  %indirect-arg-temp13 = alloca <8 x i64>, align 64
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup17

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 64, ptr %a) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.15], ptr @test_simde_mm512_rorv_epi64.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.15, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [8 x i64], ptr %a1, i64 0, i64 0
  %call = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay)
  store <8 x i64> %call, ptr %a, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %b) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.15], ptr @test_simde_mm512_rorv_epi64.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.15, ptr %arrayidx2, i32 0, i32 1
  %arraydecay4 = getelementptr inbounds [8 x i64], ptr %b3, i64 0, i64 0
  %call5 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay4)
  store <8 x i64> %call5, ptr %b, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  %3 = load <8 x i64>, ptr %a, align 64, !tbaa !16
  %4 = load <8 x i64>, ptr %b, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %4, ptr %indirect-arg-temp6, align 64, !tbaa !16
  %call7 = call <8 x i64> @simde_mm512_rorv_epi64(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp6)
  store <8 x i64> %call7, ptr %r, align 64, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <8 x i64>, ptr %r, align 64, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx8 = getelementptr inbounds [8 x %struct.anon.15], ptr @test_simde_mm512_rorv_epi64.test_vec, i64 0, i64 %6
  %r9 = getelementptr inbounds %struct.anon.15, ptr %arrayidx8, i32 0, i32 2
  %arraydecay10 = getelementptr inbounds [8 x i64], ptr %r9, i64 0, i64 0
  %call11 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay10)
  store <8 x i64> %5, ptr %indirect-arg-temp12, align 64, !tbaa !16
  store <8 x i64> %call11, ptr %indirect-arg-temp13, align 64, !tbaa !16
  %call14 = call i32 @simde_test_x86_assert_equal_i64x8_(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp12, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp13, ptr noundef @.str.21, i32 noundef 1177, ptr noundef @.str.22, ptr noundef @.str.30)
  %tobool = icmp ne i32 %call14, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup17 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %7 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %7, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup17:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest18 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest18, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup17
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup17
  %8 = load i32, ptr %retval, align 4
  ret i32 %8

unreachable:                                      ; preds = %cleanup17
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm512_mask_rorv_epi64() #5 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %src = alloca <8 x i64>, align 64
  %a = alloca <8 x i64>, align 64
  %b = alloca <8 x i64>, align 64
  %r = alloca <8 x i64>, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp11 = alloca <8 x i64>, align 64
  %indirect-arg-temp12 = alloca <8 x i64>, align 64
  %indirect-arg-temp18 = alloca <8 x i64>, align 64
  %indirect-arg-temp19 = alloca <8 x i64>, align 64
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup24

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 64, ptr %src) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.16], ptr @test_simde_mm512_mask_rorv_epi64.test_vec, i64 0, i64 %1
  %src1 = getelementptr inbounds %struct.anon.16, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [8 x i64], ptr %src1, i64 0, i64 0
  %call = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay)
  store <8 x i64> %call, ptr %src, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %a) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.16], ptr @test_simde_mm512_mask_rorv_epi64.test_vec, i64 0, i64 %2
  %a3 = getelementptr inbounds %struct.anon.16, ptr %arrayidx2, i32 0, i32 2
  %arraydecay4 = getelementptr inbounds [8 x i64], ptr %a3, i64 0, i64 0
  %call5 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay4)
  store <8 x i64> %call5, ptr %a, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %b) #13
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx6 = getelementptr inbounds [8 x %struct.anon.16], ptr @test_simde_mm512_mask_rorv_epi64.test_vec, i64 0, i64 %3
  %b7 = getelementptr inbounds %struct.anon.16, ptr %arrayidx6, i32 0, i32 3
  %arraydecay8 = getelementptr inbounds [8 x i64], ptr %b7, i64 0, i64 0
  %call9 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay8)
  store <8 x i64> %call9, ptr %b, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  %4 = load <8 x i64>, ptr %src, align 64, !tbaa !16
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx10 = getelementptr inbounds [8 x %struct.anon.16], ptr @test_simde_mm512_mask_rorv_epi64.test_vec, i64 0, i64 %5
  %k = getelementptr inbounds %struct.anon.16, ptr %arrayidx10, i32 0, i32 1
  %6 = load i8, ptr %k, align 8, !tbaa !38
  %7 = load <8 x i64>, ptr %a, align 64, !tbaa !16
  %8 = load <8 x i64>, ptr %b, align 64, !tbaa !16
  store <8 x i64> %4, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %7, ptr %indirect-arg-temp11, align 64, !tbaa !16
  store <8 x i64> %8, ptr %indirect-arg-temp12, align 64, !tbaa !16
  %call13 = call <8 x i64> @simde_mm512_mask_rorv_epi64(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, i8 noundef zeroext %6, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp11, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp12)
  store <8 x i64> %call13, ptr %r, align 64, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %9 = load <8 x i64>, ptr %r, align 64, !tbaa !16
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx14 = getelementptr inbounds [8 x %struct.anon.16], ptr @test_simde_mm512_mask_rorv_epi64.test_vec, i64 0, i64 %10
  %r15 = getelementptr inbounds %struct.anon.16, ptr %arrayidx14, i32 0, i32 4
  %arraydecay16 = getelementptr inbounds [8 x i64], ptr %r15, i64 0, i64 0
  %call17 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay16)
  store <8 x i64> %9, ptr %indirect-arg-temp18, align 64, !tbaa !16
  store <8 x i64> %call17, ptr %indirect-arg-temp19, align 64, !tbaa !16
  %call20 = call i32 @simde_test_x86_assert_equal_i64x8_(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp18, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp19, ptr noundef @.str.21, i32 noundef 1285, ptr noundef @.str.22, ptr noundef @.str.30)
  %tobool = icmp ne i32 %call20, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %src) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup24 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %11 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %11, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup24:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest25 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest25, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup24
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup24
  %12 = load i32, ptr %retval, align 4
  ret i32 %12

unreachable:                                      ; preds = %cleanup24
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm512_maskz_rorv_epi64() #5 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <8 x i64>, align 64
  %b = alloca <8 x i64>, align 64
  %r = alloca <8 x i64>, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp7 = alloca <8 x i64>, align 64
  %indirect-arg-temp13 = alloca <8 x i64>, align 64
  %indirect-arg-temp14 = alloca <8 x i64>, align 64
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup18

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 64, ptr %a) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.17], ptr @test_simde_mm512_maskz_rorv_epi64.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.17, ptr %arrayidx, i32 0, i32 1
  %arraydecay = getelementptr inbounds [8 x i64], ptr %a1, i64 0, i64 0
  %call = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay)
  store <8 x i64> %call, ptr %a, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %b) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.17], ptr @test_simde_mm512_maskz_rorv_epi64.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.17, ptr %arrayidx2, i32 0, i32 2
  %arraydecay4 = getelementptr inbounds [8 x i64], ptr %b3, i64 0, i64 0
  %call5 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay4)
  store <8 x i64> %call5, ptr %b, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx6 = getelementptr inbounds [8 x %struct.anon.17], ptr @test_simde_mm512_maskz_rorv_epi64.test_vec, i64 0, i64 %3
  %k = getelementptr inbounds %struct.anon.17, ptr %arrayidx6, i32 0, i32 0
  %4 = load i8, ptr %k, align 8, !tbaa !40
  %5 = load <8 x i64>, ptr %a, align 64, !tbaa !16
  %6 = load <8 x i64>, ptr %b, align 64, !tbaa !16
  store <8 x i64> %5, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %6, ptr %indirect-arg-temp7, align 64, !tbaa !16
  %call8 = call <8 x i64> @simde_mm512_maskz_rorv_epi64(i8 noundef zeroext %4, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp7)
  store <8 x i64> %call8, ptr %r, align 64, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %7 = load <8 x i64>, ptr %r, align 64, !tbaa !16
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx9 = getelementptr inbounds [8 x %struct.anon.17], ptr @test_simde_mm512_maskz_rorv_epi64.test_vec, i64 0, i64 %8
  %r10 = getelementptr inbounds %struct.anon.17, ptr %arrayidx9, i32 0, i32 3
  %arraydecay11 = getelementptr inbounds [8 x i64], ptr %r10, i64 0, i64 0
  %call12 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay11)
  store <8 x i64> %7, ptr %indirect-arg-temp13, align 64, !tbaa !16
  store <8 x i64> %call12, ptr %indirect-arg-temp14, align 64, !tbaa !16
  %call15 = call i32 @simde_test_x86_assert_equal_i64x8_(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp13, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp14, ptr noundef @.str.21, i32 noundef 1379, ptr noundef @.str.22, ptr noundef @.str.30)
  %tobool = icmp ne i32 %call15, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup18 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %9 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %9, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup18:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest19 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest19, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup18
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup18
  %10 = load i32, ptr %retval, align 4
  ret i32 %10

unreachable:                                      ; preds = %cleanup18
  unreachable
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_loadu_epi32(ptr noundef %mem_addr) #6 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %simde_r_ = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_) #13
  %0 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  store ptr %0, ptr %simde_r_, align 8, !tbaa !9
  %1 = load ptr, ptr %simde_r_, align 8, !tbaa !9
  store ptr %1, ptr %tmp, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_) #13
  %2 = load ptr, ptr %tmp, align 8, !tbaa !9
  %call = call <2 x i64> @_mm_loadu_si128(ptr noundef %2)
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_rorv_epi32(<2 x i64> noundef %a, <2 x i64> noundef %b) #6 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %count1 = alloca <2 x i64>, align 16
  %count2 = alloca <2 x i64>, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %count1) #13
  %0 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call = call <2 x i64> @simde_mm_set1_epi32(i32 noundef 31)
  %call1 = call <2 x i64> @simde_mm_and_si128(<2 x i64> noundef %0, <2 x i64> noundef %call)
  store <2 x i64> %call1, ptr %count1, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %count2) #13
  %call2 = call <2 x i64> @simde_mm_set1_epi32(i32 noundef 32)
  %1 = load <2 x i64>, ptr %count1, align 16, !tbaa !16
  %call3 = call <2 x i64> @simde_mm_sub_epi32(<2 x i64> noundef %call2, <2 x i64> noundef %1)
  store <2 x i64> %call3, ptr %count2, align 16, !tbaa !16
  %2 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %3 = load <2 x i64>, ptr %count1, align 16, !tbaa !16
  %call4 = call <2 x i64> @simde_mm_srlv_epi32(<2 x i64> noundef %2, <2 x i64> noundef %3)
  %4 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %5 = load <2 x i64>, ptr %count2, align 16, !tbaa !16
  %call5 = call <2 x i64> @simde_mm_sllv_epi32(<2 x i64> noundef %4, <2 x i64> noundef %5)
  %call6 = call <2 x i64> @simde_mm_or_si128(<2 x i64> noundef %call4, <2 x i64> noundef %call5)
  call void @llvm.lifetime.end.p0(i64 16, ptr %count2) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %count1) #13
  ret <2 x i64> %call6
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_x86_assert_equal_i32x4_(<2 x i64> noundef %a, <2 x i64> noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #3 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %a_ = alloca [4 x i32], align 16
  %b_ = alloca [4 x i32], align 16
  %simde_r_ = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %simde_r_1 = alloca ptr, align 8
  %tmp3 = alloca ptr, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #13
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #13
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_) #13
  %arraydecay = getelementptr inbounds [4 x i32], ptr %a_, i64 0, i64 0
  store ptr %arraydecay, ptr %simde_r_, align 8, !tbaa !9
  %0 = load ptr, ptr %simde_r_, align 8, !tbaa !9
  store ptr %0, ptr %tmp, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_) #13
  %1 = load ptr, ptr %tmp, align 8, !tbaa !9
  %2 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_si128(ptr noundef %1, <2 x i64> noundef %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_1) #13
  %arraydecay2 = getelementptr inbounds [4 x i32], ptr %b_, i64 0, i64 0
  store ptr %arraydecay2, ptr %simde_r_1, align 8, !tbaa !9
  %3 = load ptr, ptr %simde_r_1, align 8, !tbaa !9
  store ptr %3, ptr %tmp3, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_1) #13
  %4 = load ptr, ptr %tmp3, align 8, !tbaa !9
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_si128(ptr noundef %4, <2 x i64> noundef %5)
  %arraydecay4 = getelementptr inbounds [4 x i32], ptr %a_, i64 0, i64 0
  %arraydecay5 = getelementptr inbounds [4 x i32], ptr %b_, i64 0, i64 0
  %6 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %7 = load i32, ptr %line.addr, align 4, !tbaa !5
  %8 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %9 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %call = call i32 @simde_assert_equal_vi32_(i64 noundef 4, ptr noundef %arraydecay4, ptr noundef %arraydecay5, ptr noundef %6, i32 noundef %7, ptr noundef %8, ptr noundef %9)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #13
  ret i32 %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @_mm_loadu_si128(ptr noundef %__p) #6 {
entry:
  %__p.addr = alloca ptr, align 8
  store ptr %__p, ptr %__p.addr, align 8, !tbaa !9
  %0 = load ptr, ptr %__p.addr, align 8, !tbaa !9
  %__v = getelementptr inbounds %struct.__loadu_si128, ptr %0, i32 0, i32 0
  %1 = load <2 x i64>, ptr %__v, align 1, !tbaa !16
  ret <2 x i64> %1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_and_si128(<2 x i64> noundef %a, <2 x i64> noundef %b) #6 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %1 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call = call <2 x i64> @_mm_and_si128(<2 x i64> noundef %0, <2 x i64> noundef %1)
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_set1_epi32(i32 noundef %a) #6 {
entry:
  %a.addr = alloca i32, align 4
  store i32 %a, ptr %a.addr, align 4, !tbaa !5
  %0 = load i32, ptr %a.addr, align 4, !tbaa !5
  %call = call <2 x i64> @_mm_set1_epi32(i32 noundef %0)
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_sub_epi32(<2 x i64> noundef %a, <2 x i64> noundef %b) #6 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %1 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call = call <2 x i64> @_mm_sub_epi32(<2 x i64> noundef %0, <2 x i64> noundef %1)
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_or_si128(<2 x i64> noundef %a, <2 x i64> noundef %b) #6 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %1 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call = call <2 x i64> @_mm_or_si128(<2 x i64> noundef %0, <2 x i64> noundef %1)
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_srlv_epi32(<2 x i64> noundef %a, <2 x i64> noundef %b) #6 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #13
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #13
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #13
  %10 = load <4 x i32>, ptr %b_, align 16, !tbaa !16
  %cmp = icmp ult <4 x i32> %10, <i32 32, i32 32, i32 32, i32 32>
  %sext = sext <4 x i1> %cmp to <4 x i32>
  %11 = load <4 x i32>, ptr %a_, align 16, !tbaa !16
  %12 = load <4 x i32>, ptr %b_, align 16, !tbaa !16
  %shr = lshr <4 x i32> %11, %12
  %and = and <4 x i32> %sext, %shr
  store <4 x i32> %and, ptr %r_, align 16, !tbaa !16
  %13 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %14 = load double, ptr %13, align 16
  %15 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %16 = load double, ptr %15, align 8
  %call3 = call <2 x i64> @simde__m128i_from_private(double %14, double %16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #13
  ret <2 x i64> %call3
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_sllv_epi32(<2 x i64> noundef %a, <2 x i64> noundef %b) #6 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #13
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #13
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #13
  %10 = load <4 x i32>, ptr %b_, align 16, !tbaa !16
  %cmp = icmp ult <4 x i32> %10, <i32 32, i32 32, i32 32, i32 32>
  %sext = sext <4 x i1> %cmp to <4 x i32>
  %11 = load <4 x i32>, ptr %a_, align 16, !tbaa !16
  %12 = load <4 x i32>, ptr %b_, align 16, !tbaa !16
  %shl = shl <4 x i32> %11, %12
  %and = and <4 x i32> %sext, %shl
  store <4 x i32> %and, ptr %r_, align 16, !tbaa !16
  %13 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %14 = load double, ptr %13, align 16
  %15 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %16 = load double, ptr %15, align 8
  %call3 = call <2 x i64> @simde__m128i_from_private(double %14, double %16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #13
  ret <2 x i64> %call3
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @_mm_and_si128(<2 x i64> noundef %__a, <2 x i64> noundef %__b) #6 {
entry:
  %__a.addr = alloca <2 x i64>, align 16
  %__b.addr = alloca <2 x i64>, align 16
  store <2 x i64> %__a, ptr %__a.addr, align 16, !tbaa !16
  store <2 x i64> %__b, ptr %__b.addr, align 16, !tbaa !16
  %0 = load <2 x i64>, ptr %__a.addr, align 16, !tbaa !16
  %1 = load <2 x i64>, ptr %__b.addr, align 16, !tbaa !16
  %and = and <2 x i64> %0, %1
  ret <2 x i64> %and
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @_mm_set1_epi32(i32 noundef %__i) #6 {
entry:
  %__i.addr = alloca i32, align 4
  store i32 %__i, ptr %__i.addr, align 4, !tbaa !5
  %0 = load i32, ptr %__i.addr, align 4, !tbaa !5
  %1 = load i32, ptr %__i.addr, align 4, !tbaa !5
  %2 = load i32, ptr %__i.addr, align 4, !tbaa !5
  %3 = load i32, ptr %__i.addr, align 4, !tbaa !5
  %call = call <2 x i64> @_mm_set_epi32(i32 noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3)
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @_mm_set_epi32(i32 noundef %__i3, i32 noundef %__i2, i32 noundef %__i1, i32 noundef %__i0) #6 {
entry:
  %__i3.addr = alloca i32, align 4
  %__i2.addr = alloca i32, align 4
  %__i1.addr = alloca i32, align 4
  %__i0.addr = alloca i32, align 4
  %.compoundliteral = alloca <4 x i32>, align 16
  store i32 %__i3, ptr %__i3.addr, align 4, !tbaa !5
  store i32 %__i2, ptr %__i2.addr, align 4, !tbaa !5
  store i32 %__i1, ptr %__i1.addr, align 4, !tbaa !5
  store i32 %__i0, ptr %__i0.addr, align 4, !tbaa !5
  %0 = load i32, ptr %__i0.addr, align 4, !tbaa !5
  %vecinit = insertelement <4 x i32> undef, i32 %0, i32 0
  %1 = load i32, ptr %__i1.addr, align 4, !tbaa !5
  %vecinit1 = insertelement <4 x i32> %vecinit, i32 %1, i32 1
  %2 = load i32, ptr %__i2.addr, align 4, !tbaa !5
  %vecinit2 = insertelement <4 x i32> %vecinit1, i32 %2, i32 2
  %3 = load i32, ptr %__i3.addr, align 4, !tbaa !5
  %vecinit3 = insertelement <4 x i32> %vecinit2, i32 %3, i32 3
  store <4 x i32> %vecinit3, ptr %.compoundliteral, align 16, !tbaa !16
  %4 = load <4 x i32>, ptr %.compoundliteral, align 16, !tbaa !16
  %5 = bitcast <4 x i32> %4 to <2 x i64>
  ret <2 x i64> %5
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @_mm_sub_epi32(<2 x i64> noundef %__a, <2 x i64> noundef %__b) #6 {
entry:
  %__a.addr = alloca <2 x i64>, align 16
  %__b.addr = alloca <2 x i64>, align 16
  store <2 x i64> %__a, ptr %__a.addr, align 16, !tbaa !16
  store <2 x i64> %__b, ptr %__b.addr, align 16, !tbaa !16
  %0 = load <2 x i64>, ptr %__a.addr, align 16, !tbaa !16
  %1 = bitcast <2 x i64> %0 to <4 x i32>
  %2 = load <2 x i64>, ptr %__b.addr, align 16, !tbaa !16
  %3 = bitcast <2 x i64> %2 to <4 x i32>
  %sub = sub <4 x i32> %1, %3
  %4 = bitcast <4 x i32> %sub to <2 x i64>
  ret <2 x i64> %4
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @_mm_or_si128(<2 x i64> noundef %__a, <2 x i64> noundef %__b) #6 {
entry:
  %__a.addr = alloca <2 x i64>, align 16
  %__b.addr = alloca <2 x i64>, align 16
  store <2 x i64> %__a, ptr %__a.addr, align 16, !tbaa !16
  store <2 x i64> %__b, ptr %__b.addr, align 16, !tbaa !16
  %0 = load <2 x i64>, ptr %__a.addr, align 16, !tbaa !16
  %1 = load <2 x i64>, ptr %__b.addr, align 16, !tbaa !16
  %or = or <2 x i64> %0, %1
  ret <2 x i64> %or
}

; Function Attrs: alwaysinline nounwind uwtable
define internal { double, double } @simde__m128i_to_private(<2 x i64> noundef %v) #6 {
entry:
  %retval = alloca %union.simde__m128i_private, align 16
  %v.addr = alloca <2 x i64>, align 16
  store <2 x i64> %v, ptr %v.addr, align 16, !tbaa !16
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %retval, ptr align 16 %v.addr, i64 16, i1 false)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %retval, i32 0, i32 0
  %0 = load { double, double }, ptr %coerce.dive, align 16
  ret { double, double } %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde__m128i_from_private(double %v.coerce0, double %v.coerce1) #6 {
entry:
  %v = alloca %union.simde__m128i_private, align 16
  %r = alloca <2 x i64>, align 16
  %0 = getelementptr inbounds { double, double }, ptr %v, i32 0, i32 0
  store double %v.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { double, double }, ptr %v, i32 0, i32 1
  store double %v.coerce1, ptr %1, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #13
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %r, ptr align 16 %v, i64 16, i1 false)
  %2 = load <2 x i64>, ptr %r, align 16, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #13
  ret <2 x i64> %2
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #7

; Function Attrs: alwaysinline nounwind uwtable
define internal void @simde_mm_storeu_si128(ptr noundef %mem_addr, <2 x i64> noundef %a) #6 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %a.addr = alloca <2 x i64>, align 16
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  %0 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  %1 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  call void @_mm_storeu_si128(ptr noundef %0, <2 x i64> noundef %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_vi32_(i64 noundef %vec_len, ptr noundef %a, ptr noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %vec_len.addr = alloca i64, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i64 %vec_len, ptr %vec_len.addr, align 8, !tbaa !11
  store ptr %a, ptr %a.addr, align 8, !tbaa !9
  store ptr %b, ptr %b.addr, align 8, !tbaa !9
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %1 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %3 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds i32, ptr %4, i64 %5
  %6 = load i32, ptr %arrayidx, align 4, !tbaa !5
  %7 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx1 = getelementptr inbounds i32, ptr %7, i64 %8
  %9 = load i32, ptr %arrayidx1, align 4, !tbaa !5
  %cmp2 = icmp ne i32 %6, %9
  %lnot = xor i1 %cmp2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %10 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %11 = load i32, ptr %line.addr, align 4, !tbaa !5
  %12 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %13 = load i64, ptr %i, align 8, !tbaa !11
  %14 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %15 = load i64, ptr %i, align 8, !tbaa !11
  %16 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %17 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx4 = getelementptr inbounds i32, ptr %16, i64 %17
  %18 = load i32, ptr %arrayidx4, align 4, !tbaa !5
  %19 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %20 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx5 = getelementptr inbounds i32, ptr %19, i64 %20
  %21 = load i32, ptr %arrayidx5, align 4, !tbaa !5
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.24, ptr noundef %10, i32 noundef %11, ptr noundef %12, i64 noundef %13, ptr noundef %14, i64 noundef %15, i32 noundef %18, i32 noundef %21)
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %22 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %22, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup
  %23 = load i32, ptr %retval, align 4
  ret i32 %23

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @_mm_storeu_si128(ptr noundef %__p, <2 x i64> noundef %__b) #6 {
entry:
  %__p.addr = alloca ptr, align 8
  %__b.addr = alloca <2 x i64>, align 16
  store ptr %__p, ptr %__p.addr, align 8, !tbaa !9
  store <2 x i64> %__b, ptr %__b.addr, align 16, !tbaa !16
  %0 = load <2 x i64>, ptr %__b.addr, align 16, !tbaa !16
  %1 = load ptr, ptr %__p.addr, align 8, !tbaa !9
  %__v = getelementptr inbounds %struct.__storeu_si128, ptr %1, i32 0, i32 0
  store <2 x i64> %0, ptr %__v, align 1, !tbaa !16
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(none)
declare i64 @llvm.expect.i64(i64, i64) #8

; Function Attrs: nounwind uwtable
define internal void @simde_test_debug_printf_(ptr noundef %format, ...) #0 {
entry:
  %format.addr = alloca ptr, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  store ptr %format, ptr %format.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 24, ptr %ap) #13
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_start.p0(ptr %arraydecay)
  %0 = load ptr, ptr @stderr, align 8, !tbaa !9
  %1 = load ptr, ptr %format.addr, align 8, !tbaa !9
  %arraydecay1 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %call = call i32 @vfprintf(ptr noundef %0, ptr noundef %1, ptr noundef %arraydecay1)
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_end.p0(ptr %arraydecay2)
  %2 = load ptr, ptr @stderr, align 8, !tbaa !9
  %call3 = call i32 @fflush(ptr noundef %2)
  call void @llvm.lifetime.end.p0(i64 24, ptr %ap) #13
  ret void
}

declare i32 @vfprintf(ptr noundef, ptr noundef, ptr noundef) #2

declare i32 @fflush(ptr noundef) #2

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_mask_rorv_epi32(<2 x i64> noundef %src, i8 noundef zeroext %k, <2 x i64> noundef %a, <2 x i64> noundef %b) #6 {
entry:
  %src.addr = alloca <2 x i64>, align 16
  %k.addr = alloca i8, align 1
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  store <2 x i64> %src, ptr %src.addr, align 16, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  %0 = load <2 x i64>, ptr %src.addr, align 16, !tbaa !16
  %1 = load i8, ptr %k.addr, align 1, !tbaa !16
  %2 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %3 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call = call <2 x i64> @simde_mm_rorv_epi32(<2 x i64> noundef %2, <2 x i64> noundef %3)
  %call1 = call <2 x i64> @simde_mm_mask_mov_epi32(<2 x i64> noundef %0, i8 noundef zeroext %1, <2 x i64> noundef %call)
  ret <2 x i64> %call1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_mask_mov_epi32(<2 x i64> noundef %src, i8 noundef zeroext %k, <2 x i64> noundef %a) #6 {
entry:
  %src.addr = alloca <2 x i64>, align 16
  %k.addr = alloca i8, align 1
  %a.addr = alloca <2 x i64>, align 16
  %src_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store <2 x i64> %src, ptr %src.addr, align 16, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %src_) #13
  %0 = load <2 x i64>, ptr %src.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %src_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #13
  %5 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #13
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #13
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %10 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !42
  %cmp = icmp ult i64 %10, 4
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !42
  %mul = mul i64 %11, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !42
  %12 = load i8, ptr %k.addr, align 1, !tbaa !16, !llvm.access.group !42
  %conv = zext i8 %12 to i32
  %13 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !42
  %sh_prom = trunc i64 %13 to i32
  %shr = ashr i32 %conv, %sh_prom
  %and = and i32 %shr, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %omp.inner.for.body
  %14 = load <4 x i32>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !42
  %15 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !42
  %vecext = extractelement <4 x i32> %14, i64 %15
  br label %cond.end

cond.false:                                       ; preds = %omp.inner.for.body
  %16 = load <4 x i32>, ptr %src_, align 16, !tbaa !16, !llvm.access.group !42
  %17 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !42
  %vecext3 = extractelement <4 x i32> %16, i64 %17
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %vecext, %cond.true ], [ %vecext3, %cond.false ]
  %18 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !42
  %19 = load <4 x i32>, ptr %r_, align 16, !llvm.access.group !42
  %vecins = insertelement <4 x i32> %19, i32 %cond, i64 %18
  store <4 x i32> %vecins, ptr %r_, align 16, !llvm.access.group !42
  br label %omp.body.continue

omp.body.continue:                                ; preds = %cond.end
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %20 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !42
  %add4 = add i64 %20, 1
  store i64 %add4, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !42
  br label %omp.inner.for.cond, !llvm.loop !43

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 4, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #13
  %21 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %22 = load double, ptr %21, align 16
  %23 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %24 = load double, ptr %23, align 8
  %call5 = call <2 x i64> @simde__m128i_from_private(double %22, double %24)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %src_) #13
  ret <2 x i64> %call5
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_maskz_rorv_epi32(i8 noundef zeroext %k, <2 x i64> noundef %a, <2 x i64> noundef %b) #6 {
entry:
  %k.addr = alloca i8, align 1
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  %0 = load i8, ptr %k.addr, align 1, !tbaa !16
  %1 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %2 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call = call <2 x i64> @simde_mm_rorv_epi32(<2 x i64> noundef %1, <2 x i64> noundef %2)
  %call1 = call <2 x i64> @simde_mm_maskz_mov_epi32(i8 noundef zeroext %0, <2 x i64> noundef %call)
  ret <2 x i64> %call1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_maskz_mov_epi32(i8 noundef zeroext %k, <2 x i64> noundef %a) #6 {
entry:
  %k.addr = alloca i8, align 1
  %a.addr = alloca <2 x i64>, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #13
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #13
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #13
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %5 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !46
  %cmp = icmp ult i64 %5, 4
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %6 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !46
  %mul = mul i64 %6, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !46
  %7 = load i8, ptr %k.addr, align 1, !tbaa !16, !llvm.access.group !46
  %conv = zext i8 %7 to i32
  %8 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !46
  %sh_prom = trunc i64 %8 to i32
  %shr = ashr i32 %conv, %sh_prom
  %and = and i32 %shr, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %omp.inner.for.body
  %9 = load <4 x i32>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !46
  %10 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !46
  %vecext = extractelement <4 x i32> %9, i64 %10
  br label %cond.end

cond.false:                                       ; preds = %omp.inner.for.body
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %vecext, %cond.true ], [ 0, %cond.false ]
  %11 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !46
  %12 = load <4 x i32>, ptr %r_, align 16, !llvm.access.group !46
  %vecins = insertelement <4 x i32> %12, i32 %cond, i64 %11
  store <4 x i32> %vecins, ptr %r_, align 16, !llvm.access.group !46
  br label %omp.body.continue

omp.body.continue:                                ; preds = %cond.end
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %13 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !46
  %add1 = add i64 %13, 1
  store i64 %add1, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !46
  br label %omp.inner.for.cond, !llvm.loop !47

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 4, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #13
  %14 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %15 = load double, ptr %14, align 16
  %16 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %17 = load double, ptr %16, align 8
  %call2 = call <2 x i64> @simde__m128i_from_private(double %15, double %17)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #13
  ret <2 x i64> %call2
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x i64> @simde_mm256_loadu_epi32(ptr noundef %mem_addr) #9 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %r = alloca <4 x i64>, align 32
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 32, ptr %r) #13
  %0 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.memcpy.p0.p0.i64(ptr align 32 %r, ptr align 1 %0, i64 32, i1 false)
  %1 = load <4 x i64>, ptr %r, align 32, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 32, ptr %r) #13
  ret <4 x i64> %1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x i64> @simde_mm256_rorv_epi32(ptr noundef byval(<4 x i64>) align 32 %0, ptr noundef byval(<4 x i64>) align 32 %1) #9 {
entry:
  %a.addr = alloca <4 x i64>, align 32
  %b.addr = alloca <4 x i64>, align 32
  %r_ = alloca %union.simde__m256i_private, align 32
  %a_ = alloca %union.simde__m256i_private, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %b_ = alloca %union.simde__m256i_private, align 32
  %indirect-arg-temp1 = alloca <4 x i64>, align 32
  %a = load <4 x i64>, ptr %0, align 32, !tbaa !16
  %b = load <4 x i64>, ptr %1, align 32, !tbaa !16
  store <4 x i64> %a, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %b, ptr %b.addr, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %r_) #13
  call void @llvm.lifetime.start.p0(i64 32, ptr %a_) #13
  %2 = load <4 x i64>, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %2, ptr %indirect-arg-temp, align 32, !tbaa !16
  call void @simde__m256i_to_private(ptr sret(%union.simde__m256i_private) align 32 %a_, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 32, ptr %b_) #13
  %3 = load <4 x i64>, ptr %b.addr, align 32, !tbaa !16
  store <4 x i64> %3, ptr %indirect-arg-temp1, align 32, !tbaa !16
  call void @simde__m256i_to_private(ptr sret(%union.simde__m256i_private) align 32 %b_, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp1)
  %arrayidx = getelementptr inbounds [2 x <2 x i64>], ptr %a_, i64 0, i64 0
  %4 = load <2 x i64>, ptr %arrayidx, align 32, !tbaa !16
  %arrayidx2 = getelementptr inbounds [2 x <2 x i64>], ptr %b_, i64 0, i64 0
  %5 = load <2 x i64>, ptr %arrayidx2, align 32, !tbaa !16
  %call = call <2 x i64> @simde_mm_rorv_epi32(<2 x i64> noundef %4, <2 x i64> noundef %5)
  %arrayidx3 = getelementptr inbounds [2 x <2 x i64>], ptr %r_, i64 0, i64 0
  store <2 x i64> %call, ptr %arrayidx3, align 32, !tbaa !16
  %arrayidx4 = getelementptr inbounds [2 x <2 x i64>], ptr %a_, i64 0, i64 1
  %6 = load <2 x i64>, ptr %arrayidx4, align 16, !tbaa !16
  %arrayidx5 = getelementptr inbounds [2 x <2 x i64>], ptr %b_, i64 0, i64 1
  %7 = load <2 x i64>, ptr %arrayidx5, align 16, !tbaa !16
  %call6 = call <2 x i64> @simde_mm_rorv_epi32(<2 x i64> noundef %6, <2 x i64> noundef %7)
  %arrayidx7 = getelementptr inbounds [2 x <2 x i64>], ptr %r_, i64 0, i64 1
  store <2 x i64> %call6, ptr %arrayidx7, align 16, !tbaa !16
  %call8 = call <4 x i64> @simde__m256i_from_private(ptr noundef byval(%union.simde__m256i_private) align 32 %r_)
  call void @llvm.lifetime.end.p0(i64 32, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %r_) #13
  ret <4 x i64> %call8
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_x86_assert_equal_i32x8_(ptr noundef byval(<4 x i64>) align 32 %0, ptr noundef byval(<4 x i64>) align 32 %1, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %a.addr = alloca <4 x i64>, align 32
  %b.addr = alloca <4 x i64>, align 32
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %a_ = alloca [8 x i32], align 16
  %b_ = alloca [8 x i32], align 16
  %simde_r_ = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %simde_r_1 = alloca ptr, align 8
  %tmp3 = alloca ptr, align 8
  %indirect-arg-temp4 = alloca <4 x i64>, align 32
  %a = load <4 x i64>, ptr %0, align 32, !tbaa !16
  %b = load <4 x i64>, ptr %1, align 32, !tbaa !16
  store <4 x i64> %a, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %b, ptr %b.addr, align 32, !tbaa !16
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 32, ptr %a_) #13
  call void @llvm.lifetime.start.p0(i64 32, ptr %b_) #13
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_) #13
  %arraydecay = getelementptr inbounds [8 x i32], ptr %a_, i64 0, i64 0
  store ptr %arraydecay, ptr %simde_r_, align 8, !tbaa !9
  %2 = load ptr, ptr %simde_r_, align 8, !tbaa !9
  store ptr %2, ptr %tmp, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_) #13
  %3 = load ptr, ptr %tmp, align 8, !tbaa !9
  %4 = load <4 x i64>, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %4, ptr %indirect-arg-temp, align 32, !tbaa !16
  call void @simde_mm256_storeu_si256(ptr noundef %3, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_1) #13
  %arraydecay2 = getelementptr inbounds [8 x i32], ptr %b_, i64 0, i64 0
  store ptr %arraydecay2, ptr %simde_r_1, align 8, !tbaa !9
  %5 = load ptr, ptr %simde_r_1, align 8, !tbaa !9
  store ptr %5, ptr %tmp3, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_1) #13
  %6 = load ptr, ptr %tmp3, align 8, !tbaa !9
  %7 = load <4 x i64>, ptr %b.addr, align 32, !tbaa !16
  store <4 x i64> %7, ptr %indirect-arg-temp4, align 32, !tbaa !16
  call void @simde_mm256_storeu_si256(ptr noundef %6, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp4)
  %arraydecay5 = getelementptr inbounds [8 x i32], ptr %a_, i64 0, i64 0
  %arraydecay6 = getelementptr inbounds [8 x i32], ptr %b_, i64 0, i64 0
  %8 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %9 = load i32, ptr %line.addr, align 4, !tbaa !5
  %10 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %11 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %call = call i32 @simde_assert_equal_vi32_(i64 noundef 8, ptr noundef %arraydecay5, ptr noundef %arraydecay6, ptr noundef %8, i32 noundef %9, ptr noundef %10, ptr noundef %11)
  call void @llvm.lifetime.end.p0(i64 32, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a_) #13
  ret i32 %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @simde__m256i_to_private(ptr noalias sret(%union.simde__m256i_private) align 32 %agg.result, ptr noundef byval(<4 x i64>) align 32 %0) #10 {
entry:
  %v.addr = alloca <4 x i64>, align 32
  %v = load <4 x i64>, ptr %0, align 32, !tbaa !16
  store <4 x i64> %v, ptr %v.addr, align 32, !tbaa !16
  call void @llvm.memcpy.p0.p0.i64(ptr align 32 %agg.result, ptr align 32 %v.addr, i64 32, i1 false)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x i64> @simde__m256i_from_private(ptr noundef byval(%union.simde__m256i_private) align 32 %v) #9 {
entry:
  %r = alloca <4 x i64>, align 32
  call void @llvm.lifetime.start.p0(i64 32, ptr %r) #13
  call void @llvm.memcpy.p0.p0.i64(ptr align 32 %r, ptr align 32 %v, i64 32, i1 false)
  %0 = load <4 x i64>, ptr %r, align 32, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 32, ptr %r) #13
  ret <4 x i64> %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @simde_mm256_storeu_si256(ptr noundef %mem_addr, ptr noundef byval(<4 x i64>) align 32 %0) #10 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %a.addr = alloca <4 x i64>, align 32
  %a = load <4 x i64>, ptr %0, align 32, !tbaa !16
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  store <4 x i64> %a, ptr %a.addr, align 32, !tbaa !16
  %1 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %1, ptr align 32 %a.addr, i64 32, i1 false)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x i64> @simde_mm256_mask_rorv_epi32(ptr noundef byval(<4 x i64>) align 32 %0, i8 noundef zeroext %k, ptr noundef byval(<4 x i64>) align 32 %1, ptr noundef byval(<4 x i64>) align 32 %2) #9 {
entry:
  %src.addr = alloca <4 x i64>, align 32
  %k.addr = alloca i8, align 1
  %a.addr = alloca <4 x i64>, align 32
  %b.addr = alloca <4 x i64>, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %indirect-arg-temp1 = alloca <4 x i64>, align 32
  %indirect-arg-temp2 = alloca <4 x i64>, align 32
  %indirect-arg-temp3 = alloca <4 x i64>, align 32
  %src = load <4 x i64>, ptr %0, align 32, !tbaa !16
  %a = load <4 x i64>, ptr %1, align 32, !tbaa !16
  %b = load <4 x i64>, ptr %2, align 32, !tbaa !16
  store <4 x i64> %src, ptr %src.addr, align 32, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <4 x i64> %a, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %b, ptr %b.addr, align 32, !tbaa !16
  %3 = load <4 x i64>, ptr %src.addr, align 32, !tbaa !16
  %4 = load i8, ptr %k.addr, align 1, !tbaa !16
  %5 = load <4 x i64>, ptr %a.addr, align 32, !tbaa !16
  %6 = load <4 x i64>, ptr %b.addr, align 32, !tbaa !16
  store <4 x i64> %5, ptr %indirect-arg-temp, align 32, !tbaa !16
  store <4 x i64> %6, ptr %indirect-arg-temp1, align 32, !tbaa !16
  %call = call <4 x i64> @simde_mm256_rorv_epi32(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp1)
  store <4 x i64> %3, ptr %indirect-arg-temp2, align 32, !tbaa !16
  store <4 x i64> %call, ptr %indirect-arg-temp3, align 32, !tbaa !16
  %call4 = call <4 x i64> @simde_mm256_mask_mov_epi32(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp2, i8 noundef zeroext %4, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp3)
  ret <4 x i64> %call4
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x i64> @simde_mm256_mask_mov_epi32(ptr noundef byval(<4 x i64>) align 32 %0, i8 noundef zeroext %k, ptr noundef byval(<4 x i64>) align 32 %1) #9 {
entry:
  %src.addr = alloca <4 x i64>, align 32
  %k.addr = alloca i8, align 1
  %a.addr = alloca <4 x i64>, align 32
  %src_ = alloca %union.simde__m256i_private, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %a_ = alloca %union.simde__m256i_private, align 32
  %indirect-arg-temp1 = alloca <4 x i64>, align 32
  %r_ = alloca %union.simde__m256i_private, align 32
  %src = load <4 x i64>, ptr %0, align 32, !tbaa !16
  %a = load <4 x i64>, ptr %1, align 32, !tbaa !16
  store <4 x i64> %src, ptr %src.addr, align 32, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <4 x i64> %a, ptr %a.addr, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %src_) #13
  %2 = load <4 x i64>, ptr %src.addr, align 32, !tbaa !16
  store <4 x i64> %2, ptr %indirect-arg-temp, align 32, !tbaa !16
  call void @simde__m256i_to_private(ptr sret(%union.simde__m256i_private) align 32 %src_, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 32, ptr %a_) #13
  %3 = load <4 x i64>, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %3, ptr %indirect-arg-temp1, align 32, !tbaa !16
  call void @simde__m256i_to_private(ptr sret(%union.simde__m256i_private) align 32 %a_, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp1)
  call void @llvm.lifetime.start.p0(i64 32, ptr %r_) #13
  %arrayidx = getelementptr inbounds [2 x <2 x i64>], ptr %src_, i64 0, i64 0
  %4 = load <2 x i64>, ptr %arrayidx, align 32, !tbaa !16
  %5 = load i8, ptr %k.addr, align 1, !tbaa !16
  %arrayidx2 = getelementptr inbounds [2 x <2 x i64>], ptr %a_, i64 0, i64 0
  %6 = load <2 x i64>, ptr %arrayidx2, align 32, !tbaa !16
  %call = call <2 x i64> @simde_mm_mask_mov_epi32(<2 x i64> noundef %4, i8 noundef zeroext %5, <2 x i64> noundef %6)
  %arrayidx3 = getelementptr inbounds [2 x <2 x i64>], ptr %r_, i64 0, i64 0
  store <2 x i64> %call, ptr %arrayidx3, align 32, !tbaa !16
  %arrayidx4 = getelementptr inbounds [2 x <2 x i64>], ptr %src_, i64 0, i64 1
  %7 = load <2 x i64>, ptr %arrayidx4, align 16, !tbaa !16
  %8 = load i8, ptr %k.addr, align 1, !tbaa !16
  %conv = zext i8 %8 to i32
  %shr = ashr i32 %conv, 4
  %conv5 = trunc i32 %shr to i8
  %arrayidx6 = getelementptr inbounds [2 x <2 x i64>], ptr %a_, i64 0, i64 1
  %9 = load <2 x i64>, ptr %arrayidx6, align 16, !tbaa !16
  %call7 = call <2 x i64> @simde_mm_mask_mov_epi32(<2 x i64> noundef %7, i8 noundef zeroext %conv5, <2 x i64> noundef %9)
  %arrayidx8 = getelementptr inbounds [2 x <2 x i64>], ptr %r_, i64 0, i64 1
  store <2 x i64> %call7, ptr %arrayidx8, align 16, !tbaa !16
  %call9 = call <4 x i64> @simde__m256i_from_private(ptr noundef byval(%union.simde__m256i_private) align 32 %r_)
  call void @llvm.lifetime.end.p0(i64 32, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %src_) #13
  ret <4 x i64> %call9
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x i64> @simde_mm256_maskz_rorv_epi32(i8 noundef zeroext %k, ptr noundef byval(<4 x i64>) align 32 %0, ptr noundef byval(<4 x i64>) align 32 %1) #9 {
entry:
  %k.addr = alloca i8, align 1
  %a.addr = alloca <4 x i64>, align 32
  %b.addr = alloca <4 x i64>, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %indirect-arg-temp1 = alloca <4 x i64>, align 32
  %indirect-arg-temp2 = alloca <4 x i64>, align 32
  %a = load <4 x i64>, ptr %0, align 32, !tbaa !16
  %b = load <4 x i64>, ptr %1, align 32, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <4 x i64> %a, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %b, ptr %b.addr, align 32, !tbaa !16
  %2 = load i8, ptr %k.addr, align 1, !tbaa !16
  %3 = load <4 x i64>, ptr %a.addr, align 32, !tbaa !16
  %4 = load <4 x i64>, ptr %b.addr, align 32, !tbaa !16
  store <4 x i64> %3, ptr %indirect-arg-temp, align 32, !tbaa !16
  store <4 x i64> %4, ptr %indirect-arg-temp1, align 32, !tbaa !16
  %call = call <4 x i64> @simde_mm256_rorv_epi32(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp1)
  store <4 x i64> %call, ptr %indirect-arg-temp2, align 32, !tbaa !16
  %call3 = call <4 x i64> @simde_mm256_maskz_mov_epi32(i8 noundef zeroext %2, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp2)
  ret <4 x i64> %call3
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x i64> @simde_mm256_maskz_mov_epi32(i8 noundef zeroext %k, ptr noundef byval(<4 x i64>) align 32 %0) #9 {
entry:
  %k.addr = alloca i8, align 1
  %a.addr = alloca <4 x i64>, align 32
  %a_ = alloca %union.simde__m256i_private, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %r_ = alloca %union.simde__m256i_private, align 32
  %a = load <4 x i64>, ptr %0, align 32, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <4 x i64> %a, ptr %a.addr, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %a_) #13
  %1 = load <4 x i64>, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %1, ptr %indirect-arg-temp, align 32, !tbaa !16
  call void @simde__m256i_to_private(ptr sret(%union.simde__m256i_private) align 32 %a_, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 32, ptr %r_) #13
  %2 = load i8, ptr %k.addr, align 1, !tbaa !16
  %arrayidx = getelementptr inbounds [2 x <2 x i64>], ptr %a_, i64 0, i64 0
  %3 = load <2 x i64>, ptr %arrayidx, align 32, !tbaa !16
  %call = call <2 x i64> @simde_mm_maskz_mov_epi32(i8 noundef zeroext %2, <2 x i64> noundef %3)
  %arrayidx1 = getelementptr inbounds [2 x <2 x i64>], ptr %r_, i64 0, i64 0
  store <2 x i64> %call, ptr %arrayidx1, align 32, !tbaa !16
  %4 = load i8, ptr %k.addr, align 1, !tbaa !16
  %conv = zext i8 %4 to i32
  %shr = ashr i32 %conv, 4
  %conv2 = trunc i32 %shr to i8
  %arrayidx3 = getelementptr inbounds [2 x <2 x i64>], ptr %a_, i64 0, i64 1
  %5 = load <2 x i64>, ptr %arrayidx3, align 16, !tbaa !16
  %call4 = call <2 x i64> @simde_mm_maskz_mov_epi32(i8 noundef zeroext %conv2, <2 x i64> noundef %5)
  %arrayidx5 = getelementptr inbounds [2 x <2 x i64>], ptr %r_, i64 0, i64 1
  store <2 x i64> %call4, ptr %arrayidx5, align 16, !tbaa !16
  %call6 = call <4 x i64> @simde__m256i_from_private(ptr noundef byval(%union.simde__m256i_private) align 32 %r_)
  call void @llvm.lifetime.end.p0(i64 32, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a_) #13
  ret <4 x i64> %call6
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde_mm512_loadu_si512(ptr noundef %mem_addr) #11 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %r = alloca <8 x i64>, align 64
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  %0 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  %v = getelementptr inbounds %struct.simde_mm512_loadu_si512_s, ptr %0, i32 0, i32 0
  %1 = load <8 x i64>, ptr %v, align 1, !tbaa !16
  store <8 x i64> %1, ptr %r, align 64, !tbaa !16
  %2 = load <8 x i64>, ptr %r, align 64, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  ret <8 x i64> %2
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde_mm512_rorv_epi32(ptr noundef byval(<8 x i64>) align 64 %0, ptr noundef byval(<8 x i64>) align 64 %1) #11 {
entry:
  %a.addr = alloca <8 x i64>, align 64
  %b.addr = alloca <8 x i64>, align 64
  %r_ = alloca %union.simde__m512i_private, align 64
  %a_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %b_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp1 = alloca <8 x i64>, align 64
  %indirect-arg-temp3 = alloca <4 x i64>, align 32
  %indirect-arg-temp4 = alloca <4 x i64>, align 32
  %indirect-arg-temp8 = alloca <4 x i64>, align 32
  %indirect-arg-temp9 = alloca <4 x i64>, align 32
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %b = load <8 x i64>, ptr %1, align 64, !tbaa !16
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %b, ptr %b.addr, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %r_) #13
  call void @llvm.lifetime.start.p0(i64 64, ptr %a_) #13
  %2 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %2, ptr %indirect-arg-temp, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %a_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 64, ptr %b_) #13
  %3 = load <8 x i64>, ptr %b.addr, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp1, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %b_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp1)
  %arrayidx = getelementptr inbounds [2 x <4 x i64>], ptr %a_, i64 0, i64 0
  %4 = load <4 x i64>, ptr %arrayidx, align 64, !tbaa !16
  %arrayidx2 = getelementptr inbounds [2 x <4 x i64>], ptr %b_, i64 0, i64 0
  %5 = load <4 x i64>, ptr %arrayidx2, align 64, !tbaa !16
  store <4 x i64> %4, ptr %indirect-arg-temp3, align 32, !tbaa !16
  store <4 x i64> %5, ptr %indirect-arg-temp4, align 32, !tbaa !16
  %call = call <4 x i64> @simde_mm256_rorv_epi32(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp3, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp4)
  %arrayidx5 = getelementptr inbounds [2 x <4 x i64>], ptr %r_, i64 0, i64 0
  store <4 x i64> %call, ptr %arrayidx5, align 64, !tbaa !16
  %arrayidx6 = getelementptr inbounds [2 x <4 x i64>], ptr %a_, i64 0, i64 1
  %6 = load <4 x i64>, ptr %arrayidx6, align 32, !tbaa !16
  %arrayidx7 = getelementptr inbounds [2 x <4 x i64>], ptr %b_, i64 0, i64 1
  %7 = load <4 x i64>, ptr %arrayidx7, align 32, !tbaa !16
  store <4 x i64> %6, ptr %indirect-arg-temp8, align 32, !tbaa !16
  store <4 x i64> %7, ptr %indirect-arg-temp9, align 32, !tbaa !16
  %call10 = call <4 x i64> @simde_mm256_rorv_epi32(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp8, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp9)
  %arrayidx11 = getelementptr inbounds [2 x <4 x i64>], ptr %r_, i64 0, i64 1
  store <4 x i64> %call10, ptr %arrayidx11, align 32, !tbaa !16
  %call12 = call <8 x i64> @simde__m512i_from_private(ptr noundef byval(%union.simde__m512i_private) align 64 %r_)
  call void @llvm.lifetime.end.p0(i64 64, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %r_) #13
  ret <8 x i64> %call12
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_x86_assert_equal_i32x16_(ptr noundef byval(<8 x i64>) align 64 %0, ptr noundef byval(<8 x i64>) align 64 %1, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %a.addr = alloca <8 x i64>, align 64
  %b.addr = alloca <8 x i64>, align 64
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %a_ = alloca [16 x i32], align 16
  %b_ = alloca [16 x i32], align 16
  %simde_r_ = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %simde_r_1 = alloca ptr, align 8
  %tmp3 = alloca ptr, align 8
  %indirect-arg-temp4 = alloca <8 x i64>, align 64
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %b = load <8 x i64>, ptr %1, align 64, !tbaa !16
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %b, ptr %b.addr, align 64, !tbaa !16
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 64, ptr %a_) #13
  call void @llvm.lifetime.start.p0(i64 64, ptr %b_) #13
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_) #13
  %arraydecay = getelementptr inbounds [16 x i32], ptr %a_, i64 0, i64 0
  store ptr %arraydecay, ptr %simde_r_, align 8, !tbaa !9
  %2 = load ptr, ptr %simde_r_, align 8, !tbaa !9
  store ptr %2, ptr %tmp, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_) #13
  %3 = load ptr, ptr %tmp, align 8, !tbaa !9
  %4 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %4, ptr %indirect-arg-temp, align 64, !tbaa !16
  call void @simde_mm512_storeu_si512(ptr noundef %3, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_1) #13
  %arraydecay2 = getelementptr inbounds [16 x i32], ptr %b_, i64 0, i64 0
  store ptr %arraydecay2, ptr %simde_r_1, align 8, !tbaa !9
  %5 = load ptr, ptr %simde_r_1, align 8, !tbaa !9
  store ptr %5, ptr %tmp3, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_1) #13
  %6 = load ptr, ptr %tmp3, align 8, !tbaa !9
  %7 = load <8 x i64>, ptr %b.addr, align 64, !tbaa !16
  store <8 x i64> %7, ptr %indirect-arg-temp4, align 64, !tbaa !16
  call void @simde_mm512_storeu_si512(ptr noundef %6, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp4)
  %arraydecay5 = getelementptr inbounds [16 x i32], ptr %a_, i64 0, i64 0
  %arraydecay6 = getelementptr inbounds [16 x i32], ptr %b_, i64 0, i64 0
  %8 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %9 = load i32, ptr %line.addr, align 4, !tbaa !5
  %10 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %11 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %call = call i32 @simde_assert_equal_vi32_(i64 noundef 16, ptr noundef %arraydecay5, ptr noundef %arraydecay6, ptr noundef %8, i32 noundef %9, ptr noundef %10, ptr noundef %11)
  call void @llvm.lifetime.end.p0(i64 64, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a_) #13
  ret i32 %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @simde__m512i_to_private(ptr noalias sret(%union.simde__m512i_private) align 64 %agg.result, ptr noundef byval(<8 x i64>) align 64 %0) #10 {
entry:
  %v.addr = alloca <8 x i64>, align 64
  %v = load <8 x i64>, ptr %0, align 64, !tbaa !16
  store <8 x i64> %v, ptr %v.addr, align 64, !tbaa !16
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %agg.result, ptr align 64 %v.addr, i64 64, i1 false)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde__m512i_from_private(ptr noundef byval(%union.simde__m512i_private) align 64 %v) #11 {
entry:
  %r = alloca <8 x i64>, align 64
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %r, ptr align 64 %v, i64 64, i1 false)
  %0 = load <8 x i64>, ptr %r, align 64, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  ret <8 x i64> %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @simde_mm512_storeu_si512(ptr noundef %mem_addr, ptr noundef byval(<8 x i64>) align 64 %0) #10 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %a.addr = alloca <8 x i64>, align 64
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  %1 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %1, ptr align 64 %a.addr, i64 64, i1 false)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde_mm512_mask_rorv_epi32(ptr noundef byval(<8 x i64>) align 64 %0, i16 noundef zeroext %k, ptr noundef byval(<8 x i64>) align 64 %1, ptr noundef byval(<8 x i64>) align 64 %2) #11 {
entry:
  %src.addr = alloca <8 x i64>, align 64
  %k.addr = alloca i16, align 2
  %a.addr = alloca <8 x i64>, align 64
  %b.addr = alloca <8 x i64>, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp1 = alloca <8 x i64>, align 64
  %indirect-arg-temp2 = alloca <8 x i64>, align 64
  %indirect-arg-temp3 = alloca <8 x i64>, align 64
  %src = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %a = load <8 x i64>, ptr %1, align 64, !tbaa !16
  %b = load <8 x i64>, ptr %2, align 64, !tbaa !16
  store <8 x i64> %src, ptr %src.addr, align 64, !tbaa !16
  store i16 %k, ptr %k.addr, align 2, !tbaa !49
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %b, ptr %b.addr, align 64, !tbaa !16
  %3 = load <8 x i64>, ptr %src.addr, align 64, !tbaa !16
  %4 = load i16, ptr %k.addr, align 2, !tbaa !49
  %5 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  %6 = load <8 x i64>, ptr %b.addr, align 64, !tbaa !16
  store <8 x i64> %5, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %6, ptr %indirect-arg-temp1, align 64, !tbaa !16
  %call = call <8 x i64> @simde_mm512_rorv_epi32(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp1)
  store <8 x i64> %3, ptr %indirect-arg-temp2, align 64, !tbaa !16
  store <8 x i64> %call, ptr %indirect-arg-temp3, align 64, !tbaa !16
  %call4 = call <8 x i64> @simde_mm512_mask_mov_epi32(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp2, i16 noundef zeroext %4, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp3)
  ret <8 x i64> %call4
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde_mm512_mask_mov_epi32(ptr noundef byval(<8 x i64>) align 64 %0, i16 noundef zeroext %k, ptr noundef byval(<8 x i64>) align 64 %1) #11 {
entry:
  %src.addr = alloca <8 x i64>, align 64
  %k.addr = alloca i16, align 2
  %a.addr = alloca <8 x i64>, align 64
  %src_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %a_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp1 = alloca <8 x i64>, align 64
  %r_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp3 = alloca <4 x i64>, align 32
  %indirect-arg-temp4 = alloca <4 x i64>, align 32
  %indirect-arg-temp10 = alloca <4 x i64>, align 32
  %indirect-arg-temp11 = alloca <4 x i64>, align 32
  %src = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %a = load <8 x i64>, ptr %1, align 64, !tbaa !16
  store <8 x i64> %src, ptr %src.addr, align 64, !tbaa !16
  store i16 %k, ptr %k.addr, align 2, !tbaa !49
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %src_) #13
  %2 = load <8 x i64>, ptr %src.addr, align 64, !tbaa !16
  store <8 x i64> %2, ptr %indirect-arg-temp, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %src_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 64, ptr %a_) #13
  %3 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp1, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %a_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp1)
  call void @llvm.lifetime.start.p0(i64 64, ptr %r_) #13
  %arrayidx = getelementptr inbounds [2 x <4 x i64>], ptr %src_, i64 0, i64 0
  %4 = load <4 x i64>, ptr %arrayidx, align 64, !tbaa !16
  %5 = load i16, ptr %k.addr, align 2, !tbaa !49
  %conv = trunc i16 %5 to i8
  %arrayidx2 = getelementptr inbounds [2 x <4 x i64>], ptr %a_, i64 0, i64 0
  %6 = load <4 x i64>, ptr %arrayidx2, align 64, !tbaa !16
  store <4 x i64> %4, ptr %indirect-arg-temp3, align 32, !tbaa !16
  store <4 x i64> %6, ptr %indirect-arg-temp4, align 32, !tbaa !16
  %call = call <4 x i64> @simde_mm256_mask_mov_epi32(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp3, i8 noundef zeroext %conv, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp4)
  %arrayidx5 = getelementptr inbounds [2 x <4 x i64>], ptr %r_, i64 0, i64 0
  store <4 x i64> %call, ptr %arrayidx5, align 64, !tbaa !16
  %arrayidx6 = getelementptr inbounds [2 x <4 x i64>], ptr %src_, i64 0, i64 1
  %7 = load <4 x i64>, ptr %arrayidx6, align 32, !tbaa !16
  %8 = load i16, ptr %k.addr, align 2, !tbaa !49
  %conv7 = zext i16 %8 to i32
  %shr = ashr i32 %conv7, 8
  %conv8 = trunc i32 %shr to i8
  %arrayidx9 = getelementptr inbounds [2 x <4 x i64>], ptr %a_, i64 0, i64 1
  %9 = load <4 x i64>, ptr %arrayidx9, align 32, !tbaa !16
  store <4 x i64> %7, ptr %indirect-arg-temp10, align 32, !tbaa !16
  store <4 x i64> %9, ptr %indirect-arg-temp11, align 32, !tbaa !16
  %call12 = call <4 x i64> @simde_mm256_mask_mov_epi32(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp10, i8 noundef zeroext %conv8, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp11)
  %arrayidx13 = getelementptr inbounds [2 x <4 x i64>], ptr %r_, i64 0, i64 1
  store <4 x i64> %call12, ptr %arrayidx13, align 32, !tbaa !16
  %call14 = call <8 x i64> @simde__m512i_from_private(ptr noundef byval(%union.simde__m512i_private) align 64 %r_)
  call void @llvm.lifetime.end.p0(i64 64, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %src_) #13
  ret <8 x i64> %call14
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde_mm512_maskz_rorv_epi32(i16 noundef zeroext %k, ptr noundef byval(<8 x i64>) align 64 %0, ptr noundef byval(<8 x i64>) align 64 %1) #11 {
entry:
  %k.addr = alloca i16, align 2
  %a.addr = alloca <8 x i64>, align 64
  %b.addr = alloca <8 x i64>, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp1 = alloca <8 x i64>, align 64
  %indirect-arg-temp2 = alloca <8 x i64>, align 64
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %b = load <8 x i64>, ptr %1, align 64, !tbaa !16
  store i16 %k, ptr %k.addr, align 2, !tbaa !49
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %b, ptr %b.addr, align 64, !tbaa !16
  %2 = load i16, ptr %k.addr, align 2, !tbaa !49
  %3 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  %4 = load <8 x i64>, ptr %b.addr, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %4, ptr %indirect-arg-temp1, align 64, !tbaa !16
  %call = call <8 x i64> @simde_mm512_rorv_epi32(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp1)
  store <8 x i64> %call, ptr %indirect-arg-temp2, align 64, !tbaa !16
  %call3 = call <8 x i64> @simde_mm512_maskz_mov_epi32(i16 noundef zeroext %2, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp2)
  ret <8 x i64> %call3
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde_mm512_maskz_mov_epi32(i16 noundef zeroext %k, ptr noundef byval(<8 x i64>) align 64 %0) #11 {
entry:
  %k.addr = alloca i16, align 2
  %a.addr = alloca <8 x i64>, align 64
  %a_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %r_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp1 = alloca <4 x i64>, align 32
  %indirect-arg-temp6 = alloca <4 x i64>, align 32
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  store i16 %k, ptr %k.addr, align 2, !tbaa !49
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %a_) #13
  %1 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %1, ptr %indirect-arg-temp, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %a_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 64, ptr %r_) #13
  %2 = load i16, ptr %k.addr, align 2, !tbaa !49
  %conv = trunc i16 %2 to i8
  %arrayidx = getelementptr inbounds [2 x <4 x i64>], ptr %a_, i64 0, i64 0
  %3 = load <4 x i64>, ptr %arrayidx, align 64, !tbaa !16
  store <4 x i64> %3, ptr %indirect-arg-temp1, align 32, !tbaa !16
  %call = call <4 x i64> @simde_mm256_maskz_mov_epi32(i8 noundef zeroext %conv, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp1)
  %arrayidx2 = getelementptr inbounds [2 x <4 x i64>], ptr %r_, i64 0, i64 0
  store <4 x i64> %call, ptr %arrayidx2, align 64, !tbaa !16
  %4 = load i16, ptr %k.addr, align 2, !tbaa !49
  %conv3 = zext i16 %4 to i32
  %shr = ashr i32 %conv3, 8
  %conv4 = trunc i32 %shr to i8
  %arrayidx5 = getelementptr inbounds [2 x <4 x i64>], ptr %a_, i64 0, i64 1
  %5 = load <4 x i64>, ptr %arrayidx5, align 32, !tbaa !16
  store <4 x i64> %5, ptr %indirect-arg-temp6, align 32, !tbaa !16
  %call7 = call <4 x i64> @simde_mm256_maskz_mov_epi32(i8 noundef zeroext %conv4, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp6)
  %arrayidx8 = getelementptr inbounds [2 x <4 x i64>], ptr %r_, i64 0, i64 1
  store <4 x i64> %call7, ptr %arrayidx8, align 32, !tbaa !16
  %call9 = call <8 x i64> @simde__m512i_from_private(ptr noundef byval(%union.simde__m512i_private) align 64 %r_)
  call void @llvm.lifetime.end.p0(i64 64, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a_) #13
  ret <8 x i64> %call9
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_loadu_epi64(ptr noundef %mem_addr) #6 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %simde_r_ = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_) #13
  %0 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  store ptr %0, ptr %simde_r_, align 8, !tbaa !9
  %1 = load ptr, ptr %simde_r_, align 8, !tbaa !9
  store ptr %1, ptr %tmp, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_) #13
  %2 = load ptr, ptr %tmp, align 8, !tbaa !9
  %call = call <2 x i64> @_mm_loadu_si128(ptr noundef %2)
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_rorv_epi64(<2 x i64> noundef %a, <2 x i64> noundef %b) #6 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %count1 = alloca <2 x i64>, align 16
  %count2 = alloca <2 x i64>, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %count1) #13
  %0 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call = call <2 x i64> @simde_mm_set1_epi64x(i64 noundef 63)
  %call1 = call <2 x i64> @simde_mm_and_si128(<2 x i64> noundef %0, <2 x i64> noundef %call)
  store <2 x i64> %call1, ptr %count1, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %count2) #13
  %call2 = call <2 x i64> @simde_mm_set1_epi64x(i64 noundef 64)
  %1 = load <2 x i64>, ptr %count1, align 16, !tbaa !16
  %call3 = call <2 x i64> @simde_mm_sub_epi64(<2 x i64> noundef %call2, <2 x i64> noundef %1)
  store <2 x i64> %call3, ptr %count2, align 16, !tbaa !16
  %2 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %3 = load <2 x i64>, ptr %count1, align 16, !tbaa !16
  %call4 = call <2 x i64> @simde_mm_srlv_epi64(<2 x i64> noundef %2, <2 x i64> noundef %3)
  %4 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %5 = load <2 x i64>, ptr %count2, align 16, !tbaa !16
  %call5 = call <2 x i64> @simde_mm_sllv_epi64(<2 x i64> noundef %4, <2 x i64> noundef %5)
  %call6 = call <2 x i64> @simde_mm_or_si128(<2 x i64> noundef %call4, <2 x i64> noundef %call5)
  call void @llvm.lifetime.end.p0(i64 16, ptr %count2) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %count1) #13
  ret <2 x i64> %call6
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_x86_assert_equal_i64x2_(<2 x i64> noundef %a, <2 x i64> noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #3 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %a_ = alloca [2 x i64], align 16
  %b_ = alloca [2 x i64], align 16
  %simde_r_ = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %simde_r_1 = alloca ptr, align 8
  %tmp3 = alloca ptr, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #13
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #13
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_) #13
  %arraydecay = getelementptr inbounds [2 x i64], ptr %a_, i64 0, i64 0
  store ptr %arraydecay, ptr %simde_r_, align 8, !tbaa !9
  %0 = load ptr, ptr %simde_r_, align 8, !tbaa !9
  store ptr %0, ptr %tmp, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_) #13
  %1 = load ptr, ptr %tmp, align 8, !tbaa !9
  %2 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_si128(ptr noundef %1, <2 x i64> noundef %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_1) #13
  %arraydecay2 = getelementptr inbounds [2 x i64], ptr %b_, i64 0, i64 0
  store ptr %arraydecay2, ptr %simde_r_1, align 8, !tbaa !9
  %3 = load ptr, ptr %simde_r_1, align 8, !tbaa !9
  store ptr %3, ptr %tmp3, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_1) #13
  %4 = load ptr, ptr %tmp3, align 8, !tbaa !9
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_si128(ptr noundef %4, <2 x i64> noundef %5)
  %arraydecay4 = getelementptr inbounds [2 x i64], ptr %a_, i64 0, i64 0
  %arraydecay5 = getelementptr inbounds [2 x i64], ptr %b_, i64 0, i64 0
  %6 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %7 = load i32, ptr %line.addr, align 4, !tbaa !5
  %8 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %9 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %call = call i32 @simde_assert_equal_vi64_(i64 noundef 2, ptr noundef %arraydecay4, ptr noundef %arraydecay5, ptr noundef %6, i32 noundef %7, ptr noundef %8, ptr noundef %9)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #13
  ret i32 %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_set1_epi64x(i64 noundef %a) #6 {
entry:
  %a.addr = alloca i64, align 8
  store i64 %a, ptr %a.addr, align 8, !tbaa !11
  %0 = load i64, ptr %a.addr, align 8, !tbaa !11
  %call = call <2 x i64> @_mm_set1_epi64x(i64 noundef %0)
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_sub_epi64(<2 x i64> noundef %a, <2 x i64> noundef %b) #6 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %1 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call = call <2 x i64> @_mm_sub_epi64(<2 x i64> noundef %0, <2 x i64> noundef %1)
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_srlv_epi64(<2 x i64> noundef %a, <2 x i64> noundef %b) #6 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #13
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #13
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #13
  %10 = load <2 x i64>, ptr %b_, align 16, !tbaa !16
  %cmp = icmp ult <2 x i64> %10, <i64 64, i64 64>
  %sext = sext <2 x i1> %cmp to <2 x i64>
  %11 = load <2 x i64>, ptr %a_, align 16, !tbaa !16
  %12 = load <2 x i64>, ptr %b_, align 16, !tbaa !16
  %shr = lshr <2 x i64> %11, %12
  %and = and <2 x i64> %sext, %shr
  store <2 x i64> %and, ptr %r_, align 16, !tbaa !16
  %13 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %14 = load double, ptr %13, align 16
  %15 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %16 = load double, ptr %15, align 8
  %call3 = call <2 x i64> @simde__m128i_from_private(double %14, double %16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #13
  ret <2 x i64> %call3
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_sllv_epi64(<2 x i64> noundef %a, <2 x i64> noundef %b) #6 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #13
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #13
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #13
  %10 = load <2 x i64>, ptr %b_, align 16, !tbaa !16
  %cmp = icmp ult <2 x i64> %10, <i64 64, i64 64>
  %sext = sext <2 x i1> %cmp to <2 x i64>
  %11 = load <2 x i64>, ptr %a_, align 16, !tbaa !16
  %12 = load <2 x i64>, ptr %b_, align 16, !tbaa !16
  %shl = shl <2 x i64> %11, %12
  %and = and <2 x i64> %sext, %shl
  store <2 x i64> %and, ptr %r_, align 16, !tbaa !16
  %13 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %14 = load double, ptr %13, align 16
  %15 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %16 = load double, ptr %15, align 8
  %call3 = call <2 x i64> @simde__m128i_from_private(double %14, double %16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #13
  ret <2 x i64> %call3
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @_mm_set1_epi64x(i64 noundef %__q) #6 {
entry:
  %__q.addr = alloca i64, align 8
  store i64 %__q, ptr %__q.addr, align 8, !tbaa !50
  %0 = load i64, ptr %__q.addr, align 8, !tbaa !50
  %1 = load i64, ptr %__q.addr, align 8, !tbaa !50
  %call = call <2 x i64> @_mm_set_epi64x(i64 noundef %0, i64 noundef %1)
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @_mm_set_epi64x(i64 noundef %__q1, i64 noundef %__q0) #6 {
entry:
  %__q1.addr = alloca i64, align 8
  %__q0.addr = alloca i64, align 8
  %.compoundliteral = alloca <2 x i64>, align 16
  store i64 %__q1, ptr %__q1.addr, align 8, !tbaa !50
  store i64 %__q0, ptr %__q0.addr, align 8, !tbaa !50
  %0 = load i64, ptr %__q0.addr, align 8, !tbaa !50
  %vecinit = insertelement <2 x i64> undef, i64 %0, i32 0
  %1 = load i64, ptr %__q1.addr, align 8, !tbaa !50
  %vecinit1 = insertelement <2 x i64> %vecinit, i64 %1, i32 1
  store <2 x i64> %vecinit1, ptr %.compoundliteral, align 16, !tbaa !16
  %2 = load <2 x i64>, ptr %.compoundliteral, align 16, !tbaa !16
  ret <2 x i64> %2
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @_mm_sub_epi64(<2 x i64> noundef %__a, <2 x i64> noundef %__b) #6 {
entry:
  %__a.addr = alloca <2 x i64>, align 16
  %__b.addr = alloca <2 x i64>, align 16
  store <2 x i64> %__a, ptr %__a.addr, align 16, !tbaa !16
  store <2 x i64> %__b, ptr %__b.addr, align 16, !tbaa !16
  %0 = load <2 x i64>, ptr %__a.addr, align 16, !tbaa !16
  %1 = load <2 x i64>, ptr %__b.addr, align 16, !tbaa !16
  %sub = sub <2 x i64> %0, %1
  ret <2 x i64> %sub
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_vi64_(i64 noundef %vec_len, ptr noundef %a, ptr noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %vec_len.addr = alloca i64, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i64 %vec_len, ptr %vec_len.addr, align 8, !tbaa !11
  store ptr %a, ptr %a.addr, align 8, !tbaa !9
  store ptr %b, ptr %b.addr, align 8, !tbaa !9
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %1 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %3 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds i64, ptr %4, i64 %5
  %6 = load i64, ptr %arrayidx, align 8, !tbaa !11
  %7 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx1 = getelementptr inbounds i64, ptr %7, i64 %8
  %9 = load i64, ptr %arrayidx1, align 8, !tbaa !11
  %cmp2 = icmp ne i64 %6, %9
  %lnot = xor i1 %cmp2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %10 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %11 = load i32, ptr %line.addr, align 4, !tbaa !5
  %12 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %13 = load i64, ptr %i, align 8, !tbaa !11
  %14 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %15 = load i64, ptr %i, align 8, !tbaa !11
  %16 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %17 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx4 = getelementptr inbounds i64, ptr %16, i64 %17
  %18 = load i64, ptr %arrayidx4, align 8, !tbaa !11
  %19 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %20 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx5 = getelementptr inbounds i64, ptr %19, i64 %20
  %21 = load i64, ptr %arrayidx5, align 8, !tbaa !11
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.28, ptr noundef %10, i32 noundef %11, ptr noundef %12, i64 noundef %13, ptr noundef %14, i64 noundef %15, i64 noundef %18, i64 noundef %21)
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %22 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %22, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup
  %23 = load i32, ptr %retval, align 4
  ret i32 %23

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_mask_rorv_epi64(<2 x i64> noundef %src, i8 noundef zeroext %k, <2 x i64> noundef %a, <2 x i64> noundef %b) #6 {
entry:
  %src.addr = alloca <2 x i64>, align 16
  %k.addr = alloca i8, align 1
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  store <2 x i64> %src, ptr %src.addr, align 16, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  %0 = load <2 x i64>, ptr %src.addr, align 16, !tbaa !16
  %1 = load i8, ptr %k.addr, align 1, !tbaa !16
  %2 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %3 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call = call <2 x i64> @simde_mm_rorv_epi64(<2 x i64> noundef %2, <2 x i64> noundef %3)
  %call1 = call <2 x i64> @simde_mm_mask_mov_epi64(<2 x i64> noundef %0, i8 noundef zeroext %1, <2 x i64> noundef %call)
  ret <2 x i64> %call1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_mask_mov_epi64(<2 x i64> noundef %src, i8 noundef zeroext %k, <2 x i64> noundef %a) #6 {
entry:
  %src.addr = alloca <2 x i64>, align 16
  %k.addr = alloca i8, align 1
  %a.addr = alloca <2 x i64>, align 16
  %src_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store <2 x i64> %src, ptr %src.addr, align 16, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %src_) #13
  %0 = load <2 x i64>, ptr %src.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %src_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #13
  %5 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #13
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #13
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %10 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !52
  %cmp = icmp ult i64 %10, 2
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !52
  %mul = mul i64 %11, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !52
  %12 = load i8, ptr %k.addr, align 1, !tbaa !16, !llvm.access.group !52
  %conv = zext i8 %12 to i32
  %13 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !52
  %sh_prom = trunc i64 %13 to i32
  %shr = ashr i32 %conv, %sh_prom
  %and = and i32 %shr, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %omp.inner.for.body
  %14 = load <2 x i64>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !52
  %15 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !52
  %vecext = extractelement <2 x i64> %14, i64 %15
  br label %cond.end

cond.false:                                       ; preds = %omp.inner.for.body
  %16 = load <2 x i64>, ptr %src_, align 16, !tbaa !16, !llvm.access.group !52
  %17 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !52
  %vecext3 = extractelement <2 x i64> %16, i64 %17
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %vecext, %cond.true ], [ %vecext3, %cond.false ]
  %18 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !52
  %19 = load <2 x i64>, ptr %r_, align 16, !llvm.access.group !52
  %vecins = insertelement <2 x i64> %19, i64 %cond, i64 %18
  store <2 x i64> %vecins, ptr %r_, align 16, !llvm.access.group !52
  br label %omp.body.continue

omp.body.continue:                                ; preds = %cond.end
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %20 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !52
  %add4 = add i64 %20, 1
  store i64 %add4, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !52
  br label %omp.inner.for.cond, !llvm.loop !53

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 2, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #13
  %21 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %22 = load double, ptr %21, align 16
  %23 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %24 = load double, ptr %23, align 8
  %call5 = call <2 x i64> @simde__m128i_from_private(double %22, double %24)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %src_) #13
  ret <2 x i64> %call5
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_maskz_rorv_epi64(i8 noundef zeroext %k, <2 x i64> noundef %a, <2 x i64> noundef %b) #6 {
entry:
  %k.addr = alloca i8, align 1
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  %0 = load i8, ptr %k.addr, align 1, !tbaa !16
  %1 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %2 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call = call <2 x i64> @simde_mm_rorv_epi64(<2 x i64> noundef %1, <2 x i64> noundef %2)
  %call1 = call <2 x i64> @simde_mm_maskz_mov_epi64(i8 noundef zeroext %0, <2 x i64> noundef %call)
  ret <2 x i64> %call1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_maskz_mov_epi64(i8 noundef zeroext %k, <2 x i64> noundef %a) #6 {
entry:
  %k.addr = alloca i8, align 1
  %a.addr = alloca <2 x i64>, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #13
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #13
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #13
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %5 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !55
  %cmp = icmp ult i64 %5, 2
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %6 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !55
  %mul = mul i64 %6, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !55
  %7 = load i8, ptr %k.addr, align 1, !tbaa !16, !llvm.access.group !55
  %conv = zext i8 %7 to i32
  %8 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !55
  %sh_prom = trunc i64 %8 to i32
  %shr = ashr i32 %conv, %sh_prom
  %and = and i32 %shr, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %omp.inner.for.body
  %9 = load <2 x i64>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !55
  %10 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !55
  %vecext = extractelement <2 x i64> %9, i64 %10
  br label %cond.end

cond.false:                                       ; preds = %omp.inner.for.body
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %vecext, %cond.true ], [ 0, %cond.false ]
  %11 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !55
  %12 = load <2 x i64>, ptr %r_, align 16, !llvm.access.group !55
  %vecins = insertelement <2 x i64> %12, i64 %cond, i64 %11
  store <2 x i64> %vecins, ptr %r_, align 16, !llvm.access.group !55
  br label %omp.body.continue

omp.body.continue:                                ; preds = %cond.end
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %13 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !55
  %add1 = add i64 %13, 1
  store i64 %add1, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !55
  br label %omp.inner.for.cond, !llvm.loop !56

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 2, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #13
  %14 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %15 = load double, ptr %14, align 16
  %16 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %17 = load double, ptr %16, align 8
  %call2 = call <2 x i64> @simde__m128i_from_private(double %15, double %17)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #13
  ret <2 x i64> %call2
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x i64> @simde_mm256_loadu_epi64(ptr noundef %mem_addr) #9 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %r = alloca <4 x i64>, align 32
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 32, ptr %r) #13
  %0 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.memcpy.p0.p0.i64(ptr align 32 %r, ptr align 1 %0, i64 32, i1 false)
  %1 = load <4 x i64>, ptr %r, align 32, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 32, ptr %r) #13
  ret <4 x i64> %1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x i64> @simde_mm256_rorv_epi64(ptr noundef byval(<4 x i64>) align 32 %0, ptr noundef byval(<4 x i64>) align 32 %1) #9 {
entry:
  %a.addr = alloca <4 x i64>, align 32
  %b.addr = alloca <4 x i64>, align 32
  %r_ = alloca %union.simde__m256i_private, align 32
  %a_ = alloca %union.simde__m256i_private, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %b_ = alloca %union.simde__m256i_private, align 32
  %indirect-arg-temp1 = alloca <4 x i64>, align 32
  %a = load <4 x i64>, ptr %0, align 32, !tbaa !16
  %b = load <4 x i64>, ptr %1, align 32, !tbaa !16
  store <4 x i64> %a, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %b, ptr %b.addr, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %r_) #13
  call void @llvm.lifetime.start.p0(i64 32, ptr %a_) #13
  %2 = load <4 x i64>, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %2, ptr %indirect-arg-temp, align 32, !tbaa !16
  call void @simde__m256i_to_private(ptr sret(%union.simde__m256i_private) align 32 %a_, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 32, ptr %b_) #13
  %3 = load <4 x i64>, ptr %b.addr, align 32, !tbaa !16
  store <4 x i64> %3, ptr %indirect-arg-temp1, align 32, !tbaa !16
  call void @simde__m256i_to_private(ptr sret(%union.simde__m256i_private) align 32 %b_, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp1)
  %arrayidx = getelementptr inbounds [2 x <2 x i64>], ptr %a_, i64 0, i64 0
  %4 = load <2 x i64>, ptr %arrayidx, align 32, !tbaa !16
  %arrayidx2 = getelementptr inbounds [2 x <2 x i64>], ptr %b_, i64 0, i64 0
  %5 = load <2 x i64>, ptr %arrayidx2, align 32, !tbaa !16
  %call = call <2 x i64> @simde_mm_rorv_epi64(<2 x i64> noundef %4, <2 x i64> noundef %5)
  %arrayidx3 = getelementptr inbounds [2 x <2 x i64>], ptr %r_, i64 0, i64 0
  store <2 x i64> %call, ptr %arrayidx3, align 32, !tbaa !16
  %arrayidx4 = getelementptr inbounds [2 x <2 x i64>], ptr %a_, i64 0, i64 1
  %6 = load <2 x i64>, ptr %arrayidx4, align 16, !tbaa !16
  %arrayidx5 = getelementptr inbounds [2 x <2 x i64>], ptr %b_, i64 0, i64 1
  %7 = load <2 x i64>, ptr %arrayidx5, align 16, !tbaa !16
  %call6 = call <2 x i64> @simde_mm_rorv_epi64(<2 x i64> noundef %6, <2 x i64> noundef %7)
  %arrayidx7 = getelementptr inbounds [2 x <2 x i64>], ptr %r_, i64 0, i64 1
  store <2 x i64> %call6, ptr %arrayidx7, align 16, !tbaa !16
  %call8 = call <4 x i64> @simde__m256i_from_private(ptr noundef byval(%union.simde__m256i_private) align 32 %r_)
  call void @llvm.lifetime.end.p0(i64 32, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %r_) #13
  ret <4 x i64> %call8
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_x86_assert_equal_i64x4_(ptr noundef byval(<4 x i64>) align 32 %0, ptr noundef byval(<4 x i64>) align 32 %1, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %a.addr = alloca <4 x i64>, align 32
  %b.addr = alloca <4 x i64>, align 32
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %a_ = alloca [4 x i64], align 16
  %b_ = alloca [4 x i64], align 16
  %simde_r_ = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %simde_r_1 = alloca ptr, align 8
  %tmp3 = alloca ptr, align 8
  %indirect-arg-temp4 = alloca <4 x i64>, align 32
  %a = load <4 x i64>, ptr %0, align 32, !tbaa !16
  %b = load <4 x i64>, ptr %1, align 32, !tbaa !16
  store <4 x i64> %a, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %b, ptr %b.addr, align 32, !tbaa !16
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 32, ptr %a_) #13
  call void @llvm.lifetime.start.p0(i64 32, ptr %b_) #13
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_) #13
  %arraydecay = getelementptr inbounds [4 x i64], ptr %a_, i64 0, i64 0
  store ptr %arraydecay, ptr %simde_r_, align 8, !tbaa !9
  %2 = load ptr, ptr %simde_r_, align 8, !tbaa !9
  store ptr %2, ptr %tmp, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_) #13
  %3 = load ptr, ptr %tmp, align 8, !tbaa !9
  %4 = load <4 x i64>, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %4, ptr %indirect-arg-temp, align 32, !tbaa !16
  call void @simde_mm256_storeu_si256(ptr noundef %3, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_1) #13
  %arraydecay2 = getelementptr inbounds [4 x i64], ptr %b_, i64 0, i64 0
  store ptr %arraydecay2, ptr %simde_r_1, align 8, !tbaa !9
  %5 = load ptr, ptr %simde_r_1, align 8, !tbaa !9
  store ptr %5, ptr %tmp3, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_1) #13
  %6 = load ptr, ptr %tmp3, align 8, !tbaa !9
  %7 = load <4 x i64>, ptr %b.addr, align 32, !tbaa !16
  store <4 x i64> %7, ptr %indirect-arg-temp4, align 32, !tbaa !16
  call void @simde_mm256_storeu_si256(ptr noundef %6, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp4)
  %arraydecay5 = getelementptr inbounds [4 x i64], ptr %a_, i64 0, i64 0
  %arraydecay6 = getelementptr inbounds [4 x i64], ptr %b_, i64 0, i64 0
  %8 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %9 = load i32, ptr %line.addr, align 4, !tbaa !5
  %10 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %11 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %call = call i32 @simde_assert_equal_vi64_(i64 noundef 4, ptr noundef %arraydecay5, ptr noundef %arraydecay6, ptr noundef %8, i32 noundef %9, ptr noundef %10, ptr noundef %11)
  call void @llvm.lifetime.end.p0(i64 32, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a_) #13
  ret i32 %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x i64> @simde_mm256_mask_rorv_epi64(ptr noundef byval(<4 x i64>) align 32 %0, i8 noundef zeroext %k, ptr noundef byval(<4 x i64>) align 32 %1, ptr noundef byval(<4 x i64>) align 32 %2) #9 {
entry:
  %src.addr = alloca <4 x i64>, align 32
  %k.addr = alloca i8, align 1
  %a.addr = alloca <4 x i64>, align 32
  %b.addr = alloca <4 x i64>, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %indirect-arg-temp1 = alloca <4 x i64>, align 32
  %indirect-arg-temp2 = alloca <4 x i64>, align 32
  %indirect-arg-temp3 = alloca <4 x i64>, align 32
  %src = load <4 x i64>, ptr %0, align 32, !tbaa !16
  %a = load <4 x i64>, ptr %1, align 32, !tbaa !16
  %b = load <4 x i64>, ptr %2, align 32, !tbaa !16
  store <4 x i64> %src, ptr %src.addr, align 32, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <4 x i64> %a, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %b, ptr %b.addr, align 32, !tbaa !16
  %3 = load <4 x i64>, ptr %src.addr, align 32, !tbaa !16
  %4 = load i8, ptr %k.addr, align 1, !tbaa !16
  %5 = load <4 x i64>, ptr %a.addr, align 32, !tbaa !16
  %6 = load <4 x i64>, ptr %b.addr, align 32, !tbaa !16
  store <4 x i64> %5, ptr %indirect-arg-temp, align 32, !tbaa !16
  store <4 x i64> %6, ptr %indirect-arg-temp1, align 32, !tbaa !16
  %call = call <4 x i64> @simde_mm256_rorv_epi64(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp1)
  store <4 x i64> %3, ptr %indirect-arg-temp2, align 32, !tbaa !16
  store <4 x i64> %call, ptr %indirect-arg-temp3, align 32, !tbaa !16
  %call4 = call <4 x i64> @simde_mm256_mask_mov_epi64(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp2, i8 noundef zeroext %4, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp3)
  ret <4 x i64> %call4
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x i64> @simde_mm256_mask_mov_epi64(ptr noundef byval(<4 x i64>) align 32 %0, i8 noundef zeroext %k, ptr noundef byval(<4 x i64>) align 32 %1) #9 {
entry:
  %src.addr = alloca <4 x i64>, align 32
  %k.addr = alloca i8, align 1
  %a.addr = alloca <4 x i64>, align 32
  %src_ = alloca %union.simde__m256i_private, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %a_ = alloca %union.simde__m256i_private, align 32
  %indirect-arg-temp1 = alloca <4 x i64>, align 32
  %r_ = alloca %union.simde__m256i_private, align 32
  %src = load <4 x i64>, ptr %0, align 32, !tbaa !16
  %a = load <4 x i64>, ptr %1, align 32, !tbaa !16
  store <4 x i64> %src, ptr %src.addr, align 32, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <4 x i64> %a, ptr %a.addr, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %src_) #13
  %2 = load <4 x i64>, ptr %src.addr, align 32, !tbaa !16
  store <4 x i64> %2, ptr %indirect-arg-temp, align 32, !tbaa !16
  call void @simde__m256i_to_private(ptr sret(%union.simde__m256i_private) align 32 %src_, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 32, ptr %a_) #13
  %3 = load <4 x i64>, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %3, ptr %indirect-arg-temp1, align 32, !tbaa !16
  call void @simde__m256i_to_private(ptr sret(%union.simde__m256i_private) align 32 %a_, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp1)
  call void @llvm.lifetime.start.p0(i64 32, ptr %r_) #13
  %arrayidx = getelementptr inbounds [2 x <2 x i64>], ptr %src_, i64 0, i64 0
  %4 = load <2 x i64>, ptr %arrayidx, align 32, !tbaa !16
  %5 = load i8, ptr %k.addr, align 1, !tbaa !16
  %arrayidx2 = getelementptr inbounds [2 x <2 x i64>], ptr %a_, i64 0, i64 0
  %6 = load <2 x i64>, ptr %arrayidx2, align 32, !tbaa !16
  %call = call <2 x i64> @simde_mm_mask_mov_epi64(<2 x i64> noundef %4, i8 noundef zeroext %5, <2 x i64> noundef %6)
  %arrayidx3 = getelementptr inbounds [2 x <2 x i64>], ptr %r_, i64 0, i64 0
  store <2 x i64> %call, ptr %arrayidx3, align 32, !tbaa !16
  %arrayidx4 = getelementptr inbounds [2 x <2 x i64>], ptr %src_, i64 0, i64 1
  %7 = load <2 x i64>, ptr %arrayidx4, align 16, !tbaa !16
  %8 = load i8, ptr %k.addr, align 1, !tbaa !16
  %conv = zext i8 %8 to i32
  %shr = ashr i32 %conv, 2
  %conv5 = trunc i32 %shr to i8
  %arrayidx6 = getelementptr inbounds [2 x <2 x i64>], ptr %a_, i64 0, i64 1
  %9 = load <2 x i64>, ptr %arrayidx6, align 16, !tbaa !16
  %call7 = call <2 x i64> @simde_mm_mask_mov_epi64(<2 x i64> noundef %7, i8 noundef zeroext %conv5, <2 x i64> noundef %9)
  %arrayidx8 = getelementptr inbounds [2 x <2 x i64>], ptr %r_, i64 0, i64 1
  store <2 x i64> %call7, ptr %arrayidx8, align 16, !tbaa !16
  %call9 = call <4 x i64> @simde__m256i_from_private(ptr noundef byval(%union.simde__m256i_private) align 32 %r_)
  call void @llvm.lifetime.end.p0(i64 32, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %src_) #13
  ret <4 x i64> %call9
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x i64> @simde_mm256_maskz_rorv_epi64(i8 noundef zeroext %k, ptr noundef byval(<4 x i64>) align 32 %0, ptr noundef byval(<4 x i64>) align 32 %1) #9 {
entry:
  %k.addr = alloca i8, align 1
  %a.addr = alloca <4 x i64>, align 32
  %b.addr = alloca <4 x i64>, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %indirect-arg-temp1 = alloca <4 x i64>, align 32
  %indirect-arg-temp2 = alloca <4 x i64>, align 32
  %a = load <4 x i64>, ptr %0, align 32, !tbaa !16
  %b = load <4 x i64>, ptr %1, align 32, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <4 x i64> %a, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %b, ptr %b.addr, align 32, !tbaa !16
  %2 = load i8, ptr %k.addr, align 1, !tbaa !16
  %3 = load <4 x i64>, ptr %a.addr, align 32, !tbaa !16
  %4 = load <4 x i64>, ptr %b.addr, align 32, !tbaa !16
  store <4 x i64> %3, ptr %indirect-arg-temp, align 32, !tbaa !16
  store <4 x i64> %4, ptr %indirect-arg-temp1, align 32, !tbaa !16
  %call = call <4 x i64> @simde_mm256_rorv_epi64(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp1)
  store <4 x i64> %call, ptr %indirect-arg-temp2, align 32, !tbaa !16
  %call3 = call <4 x i64> @simde_mm256_maskz_mov_epi64(i8 noundef zeroext %2, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp2)
  ret <4 x i64> %call3
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x i64> @simde_mm256_maskz_mov_epi64(i8 noundef zeroext %k, ptr noundef byval(<4 x i64>) align 32 %0) #9 {
entry:
  %k.addr = alloca i8, align 1
  %a.addr = alloca <4 x i64>, align 32
  %a_ = alloca %union.simde__m256i_private, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %r_ = alloca %union.simde__m256i_private, align 32
  %a = load <4 x i64>, ptr %0, align 32, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <4 x i64> %a, ptr %a.addr, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %a_) #13
  %1 = load <4 x i64>, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %1, ptr %indirect-arg-temp, align 32, !tbaa !16
  call void @simde__m256i_to_private(ptr sret(%union.simde__m256i_private) align 32 %a_, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 32, ptr %r_) #13
  %2 = load i8, ptr %k.addr, align 1, !tbaa !16
  %arrayidx = getelementptr inbounds [2 x <2 x i64>], ptr %a_, i64 0, i64 0
  %3 = load <2 x i64>, ptr %arrayidx, align 32, !tbaa !16
  %call = call <2 x i64> @simde_mm_maskz_mov_epi64(i8 noundef zeroext %2, <2 x i64> noundef %3)
  %arrayidx1 = getelementptr inbounds [2 x <2 x i64>], ptr %r_, i64 0, i64 0
  store <2 x i64> %call, ptr %arrayidx1, align 32, !tbaa !16
  %4 = load i8, ptr %k.addr, align 1, !tbaa !16
  %conv = zext i8 %4 to i32
  %shr = ashr i32 %conv, 2
  %conv2 = trunc i32 %shr to i8
  %arrayidx3 = getelementptr inbounds [2 x <2 x i64>], ptr %a_, i64 0, i64 1
  %5 = load <2 x i64>, ptr %arrayidx3, align 16, !tbaa !16
  %call4 = call <2 x i64> @simde_mm_maskz_mov_epi64(i8 noundef zeroext %conv2, <2 x i64> noundef %5)
  %arrayidx5 = getelementptr inbounds [2 x <2 x i64>], ptr %r_, i64 0, i64 1
  store <2 x i64> %call4, ptr %arrayidx5, align 16, !tbaa !16
  %call6 = call <4 x i64> @simde__m256i_from_private(ptr noundef byval(%union.simde__m256i_private) align 32 %r_)
  call void @llvm.lifetime.end.p0(i64 32, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a_) #13
  ret <4 x i64> %call6
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde_mm512_rorv_epi64(ptr noundef byval(<8 x i64>) align 64 %0, ptr noundef byval(<8 x i64>) align 64 %1) #11 {
entry:
  %a.addr = alloca <8 x i64>, align 64
  %b.addr = alloca <8 x i64>, align 64
  %r_ = alloca %union.simde__m512i_private, align 64
  %a_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %b_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp1 = alloca <8 x i64>, align 64
  %indirect-arg-temp3 = alloca <4 x i64>, align 32
  %indirect-arg-temp4 = alloca <4 x i64>, align 32
  %indirect-arg-temp8 = alloca <4 x i64>, align 32
  %indirect-arg-temp9 = alloca <4 x i64>, align 32
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %b = load <8 x i64>, ptr %1, align 64, !tbaa !16
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %b, ptr %b.addr, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %r_) #13
  call void @llvm.lifetime.start.p0(i64 64, ptr %a_) #13
  %2 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %2, ptr %indirect-arg-temp, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %a_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 64, ptr %b_) #13
  %3 = load <8 x i64>, ptr %b.addr, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp1, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %b_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp1)
  %arrayidx = getelementptr inbounds [2 x <4 x i64>], ptr %a_, i64 0, i64 0
  %4 = load <4 x i64>, ptr %arrayidx, align 64, !tbaa !16
  %arrayidx2 = getelementptr inbounds [2 x <4 x i64>], ptr %b_, i64 0, i64 0
  %5 = load <4 x i64>, ptr %arrayidx2, align 64, !tbaa !16
  store <4 x i64> %4, ptr %indirect-arg-temp3, align 32, !tbaa !16
  store <4 x i64> %5, ptr %indirect-arg-temp4, align 32, !tbaa !16
  %call = call <4 x i64> @simde_mm256_rorv_epi64(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp3, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp4)
  %arrayidx5 = getelementptr inbounds [2 x <4 x i64>], ptr %r_, i64 0, i64 0
  store <4 x i64> %call, ptr %arrayidx5, align 64, !tbaa !16
  %arrayidx6 = getelementptr inbounds [2 x <4 x i64>], ptr %a_, i64 0, i64 1
  %6 = load <4 x i64>, ptr %arrayidx6, align 32, !tbaa !16
  %arrayidx7 = getelementptr inbounds [2 x <4 x i64>], ptr %b_, i64 0, i64 1
  %7 = load <4 x i64>, ptr %arrayidx7, align 32, !tbaa !16
  store <4 x i64> %6, ptr %indirect-arg-temp8, align 32, !tbaa !16
  store <4 x i64> %7, ptr %indirect-arg-temp9, align 32, !tbaa !16
  %call10 = call <4 x i64> @simde_mm256_rorv_epi64(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp8, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp9)
  %arrayidx11 = getelementptr inbounds [2 x <4 x i64>], ptr %r_, i64 0, i64 1
  store <4 x i64> %call10, ptr %arrayidx11, align 32, !tbaa !16
  %call12 = call <8 x i64> @simde__m512i_from_private(ptr noundef byval(%union.simde__m512i_private) align 64 %r_)
  call void @llvm.lifetime.end.p0(i64 64, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %r_) #13
  ret <8 x i64> %call12
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_x86_assert_equal_i64x8_(ptr noundef byval(<8 x i64>) align 64 %0, ptr noundef byval(<8 x i64>) align 64 %1, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %a.addr = alloca <8 x i64>, align 64
  %b.addr = alloca <8 x i64>, align 64
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %a_ = alloca [8 x i64], align 16
  %b_ = alloca [8 x i64], align 16
  %simde_r_ = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %simde_r_1 = alloca ptr, align 8
  %tmp3 = alloca ptr, align 8
  %indirect-arg-temp4 = alloca <8 x i64>, align 64
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %b = load <8 x i64>, ptr %1, align 64, !tbaa !16
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %b, ptr %b.addr, align 64, !tbaa !16
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 64, ptr %a_) #13
  call void @llvm.lifetime.start.p0(i64 64, ptr %b_) #13
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_) #13
  %arraydecay = getelementptr inbounds [8 x i64], ptr %a_, i64 0, i64 0
  store ptr %arraydecay, ptr %simde_r_, align 8, !tbaa !9
  %2 = load ptr, ptr %simde_r_, align 8, !tbaa !9
  store ptr %2, ptr %tmp, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_) #13
  %3 = load ptr, ptr %tmp, align 8, !tbaa !9
  %4 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %4, ptr %indirect-arg-temp, align 64, !tbaa !16
  call void @simde_mm512_storeu_si512(ptr noundef %3, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_1) #13
  %arraydecay2 = getelementptr inbounds [8 x i64], ptr %b_, i64 0, i64 0
  store ptr %arraydecay2, ptr %simde_r_1, align 8, !tbaa !9
  %5 = load ptr, ptr %simde_r_1, align 8, !tbaa !9
  store ptr %5, ptr %tmp3, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_1) #13
  %6 = load ptr, ptr %tmp3, align 8, !tbaa !9
  %7 = load <8 x i64>, ptr %b.addr, align 64, !tbaa !16
  store <8 x i64> %7, ptr %indirect-arg-temp4, align 64, !tbaa !16
  call void @simde_mm512_storeu_si512(ptr noundef %6, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp4)
  %arraydecay5 = getelementptr inbounds [8 x i64], ptr %a_, i64 0, i64 0
  %arraydecay6 = getelementptr inbounds [8 x i64], ptr %b_, i64 0, i64 0
  %8 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %9 = load i32, ptr %line.addr, align 4, !tbaa !5
  %10 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %11 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %call = call i32 @simde_assert_equal_vi64_(i64 noundef 8, ptr noundef %arraydecay5, ptr noundef %arraydecay6, ptr noundef %8, i32 noundef %9, ptr noundef %10, ptr noundef %11)
  call void @llvm.lifetime.end.p0(i64 64, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a_) #13
  ret i32 %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde_mm512_mask_rorv_epi64(ptr noundef byval(<8 x i64>) align 64 %0, i8 noundef zeroext %k, ptr noundef byval(<8 x i64>) align 64 %1, ptr noundef byval(<8 x i64>) align 64 %2) #11 {
entry:
  %src.addr = alloca <8 x i64>, align 64
  %k.addr = alloca i8, align 1
  %a.addr = alloca <8 x i64>, align 64
  %b.addr = alloca <8 x i64>, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp1 = alloca <8 x i64>, align 64
  %indirect-arg-temp2 = alloca <8 x i64>, align 64
  %indirect-arg-temp3 = alloca <8 x i64>, align 64
  %src = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %a = load <8 x i64>, ptr %1, align 64, !tbaa !16
  %b = load <8 x i64>, ptr %2, align 64, !tbaa !16
  store <8 x i64> %src, ptr %src.addr, align 64, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %b, ptr %b.addr, align 64, !tbaa !16
  %3 = load <8 x i64>, ptr %src.addr, align 64, !tbaa !16
  %4 = load i8, ptr %k.addr, align 1, !tbaa !16
  %5 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  %6 = load <8 x i64>, ptr %b.addr, align 64, !tbaa !16
  store <8 x i64> %5, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %6, ptr %indirect-arg-temp1, align 64, !tbaa !16
  %call = call <8 x i64> @simde_mm512_rorv_epi64(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp1)
  store <8 x i64> %3, ptr %indirect-arg-temp2, align 64, !tbaa !16
  store <8 x i64> %call, ptr %indirect-arg-temp3, align 64, !tbaa !16
  %call4 = call <8 x i64> @simde_mm512_mask_mov_epi64(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp2, i8 noundef zeroext %4, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp3)
  ret <8 x i64> %call4
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde_mm512_mask_mov_epi64(ptr noundef byval(<8 x i64>) align 64 %0, i8 noundef zeroext %k, ptr noundef byval(<8 x i64>) align 64 %1) #11 {
entry:
  %src.addr = alloca <8 x i64>, align 64
  %k.addr = alloca i8, align 1
  %a.addr = alloca <8 x i64>, align 64
  %src_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %a_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp1 = alloca <8 x i64>, align 64
  %r_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp3 = alloca <4 x i64>, align 32
  %indirect-arg-temp4 = alloca <4 x i64>, align 32
  %indirect-arg-temp9 = alloca <4 x i64>, align 32
  %indirect-arg-temp10 = alloca <4 x i64>, align 32
  %src = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %a = load <8 x i64>, ptr %1, align 64, !tbaa !16
  store <8 x i64> %src, ptr %src.addr, align 64, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %src_) #13
  %2 = load <8 x i64>, ptr %src.addr, align 64, !tbaa !16
  store <8 x i64> %2, ptr %indirect-arg-temp, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %src_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 64, ptr %a_) #13
  %3 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp1, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %a_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp1)
  call void @llvm.lifetime.start.p0(i64 64, ptr %r_) #13
  %arrayidx = getelementptr inbounds [2 x <4 x i64>], ptr %src_, i64 0, i64 0
  %4 = load <4 x i64>, ptr %arrayidx, align 64, !tbaa !16
  %5 = load i8, ptr %k.addr, align 1, !tbaa !16
  %arrayidx2 = getelementptr inbounds [2 x <4 x i64>], ptr %a_, i64 0, i64 0
  %6 = load <4 x i64>, ptr %arrayidx2, align 64, !tbaa !16
  store <4 x i64> %4, ptr %indirect-arg-temp3, align 32, !tbaa !16
  store <4 x i64> %6, ptr %indirect-arg-temp4, align 32, !tbaa !16
  %call = call <4 x i64> @simde_mm256_mask_mov_epi64(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp3, i8 noundef zeroext %5, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp4)
  %arrayidx5 = getelementptr inbounds [2 x <4 x i64>], ptr %r_, i64 0, i64 0
  store <4 x i64> %call, ptr %arrayidx5, align 64, !tbaa !16
  %arrayidx6 = getelementptr inbounds [2 x <4 x i64>], ptr %src_, i64 0, i64 1
  %7 = load <4 x i64>, ptr %arrayidx6, align 32, !tbaa !16
  %8 = load i8, ptr %k.addr, align 1, !tbaa !16
  %conv = zext i8 %8 to i32
  %shr = ashr i32 %conv, 4
  %conv7 = trunc i32 %shr to i8
  %arrayidx8 = getelementptr inbounds [2 x <4 x i64>], ptr %a_, i64 0, i64 1
  %9 = load <4 x i64>, ptr %arrayidx8, align 32, !tbaa !16
  store <4 x i64> %7, ptr %indirect-arg-temp9, align 32, !tbaa !16
  store <4 x i64> %9, ptr %indirect-arg-temp10, align 32, !tbaa !16
  %call11 = call <4 x i64> @simde_mm256_mask_mov_epi64(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp9, i8 noundef zeroext %conv7, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp10)
  %arrayidx12 = getelementptr inbounds [2 x <4 x i64>], ptr %r_, i64 0, i64 1
  store <4 x i64> %call11, ptr %arrayidx12, align 32, !tbaa !16
  %call13 = call <8 x i64> @simde__m512i_from_private(ptr noundef byval(%union.simde__m512i_private) align 64 %r_)
  call void @llvm.lifetime.end.p0(i64 64, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %src_) #13
  ret <8 x i64> %call13
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde_mm512_maskz_rorv_epi64(i8 noundef zeroext %k, ptr noundef byval(<8 x i64>) align 64 %0, ptr noundef byval(<8 x i64>) align 64 %1) #11 {
entry:
  %k.addr = alloca i8, align 1
  %a.addr = alloca <8 x i64>, align 64
  %b.addr = alloca <8 x i64>, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp1 = alloca <8 x i64>, align 64
  %indirect-arg-temp2 = alloca <8 x i64>, align 64
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %b = load <8 x i64>, ptr %1, align 64, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %b, ptr %b.addr, align 64, !tbaa !16
  %2 = load i8, ptr %k.addr, align 1, !tbaa !16
  %3 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  %4 = load <8 x i64>, ptr %b.addr, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %4, ptr %indirect-arg-temp1, align 64, !tbaa !16
  %call = call <8 x i64> @simde_mm512_rorv_epi64(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp1)
  store <8 x i64> %call, ptr %indirect-arg-temp2, align 64, !tbaa !16
  %call3 = call <8 x i64> @simde_mm512_maskz_mov_epi64(i8 noundef zeroext %2, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp2)
  ret <8 x i64> %call3
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde_mm512_maskz_mov_epi64(i8 noundef zeroext %k, ptr noundef byval(<8 x i64>) align 64 %0) #11 {
entry:
  %k.addr = alloca i8, align 1
  %a.addr = alloca <8 x i64>, align 64
  %a_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %r_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp1 = alloca <4 x i64>, align 32
  %indirect-arg-temp5 = alloca <4 x i64>, align 32
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %a_) #13
  %1 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %1, ptr %indirect-arg-temp, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %a_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 64, ptr %r_) #13
  %2 = load i8, ptr %k.addr, align 1, !tbaa !16
  %arrayidx = getelementptr inbounds [2 x <4 x i64>], ptr %a_, i64 0, i64 0
  %3 = load <4 x i64>, ptr %arrayidx, align 64, !tbaa !16
  store <4 x i64> %3, ptr %indirect-arg-temp1, align 32, !tbaa !16
  %call = call <4 x i64> @simde_mm256_maskz_mov_epi64(i8 noundef zeroext %2, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp1)
  %arrayidx2 = getelementptr inbounds [2 x <4 x i64>], ptr %r_, i64 0, i64 0
  store <4 x i64> %call, ptr %arrayidx2, align 64, !tbaa !16
  %4 = load i8, ptr %k.addr, align 1, !tbaa !16
  %conv = zext i8 %4 to i32
  %shr = ashr i32 %conv, 4
  %conv3 = trunc i32 %shr to i8
  %arrayidx4 = getelementptr inbounds [2 x <4 x i64>], ptr %a_, i64 0, i64 1
  %5 = load <4 x i64>, ptr %arrayidx4, align 32, !tbaa !16
  store <4 x i64> %5, ptr %indirect-arg-temp5, align 32, !tbaa !16
  %call6 = call <4 x i64> @simde_mm256_maskz_mov_epi64(i8 noundef zeroext %conv3, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp5)
  %arrayidx7 = getelementptr inbounds [2 x <4 x i64>], ptr %r_, i64 0, i64 1
  store <4 x i64> %call6, ptr %arrayidx7, align 32, !tbaa !16
  %call8 = call <8 x i64> @simde__m512i_from_private(ptr noundef byval(%union.simde__m512i_private) align 64 %r_)
  call void @llvm.lifetime.end.p0(i64 64, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a_) #13
  ret <8 x i64> %call8
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_start.p0(ptr) #12

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_end.p0(ptr) #12

attributes #0 = { nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind uwtable "min-legal-vector-width"="128" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { nounwind uwtable "min-legal-vector-width"="256" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { nounwind uwtable "min-legal-vector-width"="512" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { alwaysinline nounwind uwtable "min-legal-vector-width"="128" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #8 = { nocallback nofree nosync nounwind willreturn memory(none) }
attributes #9 = { alwaysinline nounwind uwtable "min-legal-vector-width"="256" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { alwaysinline nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { alwaysinline nounwind uwtable "min-legal-vector-width"="512" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #12 = { nocallback nofree nosync nounwind willreturn }
attributes #13 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"clang version 18.0.0 (https://github.com/llvm-ml/llvm-project b452eb491a2ae09c12cc88b715f003377cec543b)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = !{!10, !10, i64 0}
!10 = !{!"any pointer", !7, i64 0}
!11 = !{!12, !12, i64 0}
!12 = !{!"long", !7, i64 0}
!13 = !{!14, !10, i64 0}
!14 = !{!"", !10, i64 0, !10, i64 8}
!15 = !{!14, !10, i64 8}
!16 = !{!7, !7, i64 0}
!17 = !{!18, !7, i64 16}
!18 = !{!"", !7, i64 0, !7, i64 16, !7, i64 20, !7, i64 36, !7, i64 52}
!19 = !{!20, !7, i64 0}
!20 = !{!"", !7, i64 0, !7, i64 4, !7, i64 20, !7, i64 36}
!21 = !{!22, !7, i64 32}
!22 = !{!"", !7, i64 0, !7, i64 32, !7, i64 36, !7, i64 68, !7, i64 100}
!23 = !{!24, !7, i64 0}
!24 = !{!"", !7, i64 0, !7, i64 4, !7, i64 36, !7, i64 68}
!25 = !{!26, !27, i64 64}
!26 = !{!"", !7, i64 0, !27, i64 64, !7, i64 68, !7, i64 132, !7, i64 196}
!27 = !{!"short", !7, i64 0}
!28 = !{!29, !27, i64 0}
!29 = !{!"", !27, i64 0, !7, i64 4, !7, i64 68, !7, i64 132}
!30 = !{!31, !7, i64 16}
!31 = !{!"", !7, i64 0, !7, i64 16, !7, i64 24, !7, i64 40, !7, i64 56}
!32 = !{!33, !7, i64 0}
!33 = !{!"", !7, i64 0, !7, i64 8, !7, i64 24, !7, i64 40}
!34 = !{!35, !7, i64 32}
!35 = !{!"", !7, i64 0, !7, i64 32, !7, i64 40, !7, i64 72, !7, i64 104}
!36 = !{!37, !7, i64 0}
!37 = !{!"", !7, i64 0, !7, i64 8, !7, i64 40, !7, i64 72}
!38 = !{!39, !7, i64 64}
!39 = !{!"", !7, i64 0, !7, i64 64, !7, i64 72, !7, i64 136, !7, i64 200}
!40 = !{!41, !7, i64 0}
!41 = !{!"", !7, i64 0, !7, i64 8, !7, i64 72, !7, i64 136}
!42 = distinct !{}
!43 = distinct !{!43, !44, !45}
!44 = !{!"llvm.loop.parallel_accesses", !42}
!45 = !{!"llvm.loop.vectorize.enable", i1 true}
!46 = distinct !{}
!47 = distinct !{!47, !48, !45}
!48 = !{!"llvm.loop.parallel_accesses", !46}
!49 = !{!27, !27, i64 0}
!50 = !{!51, !51, i64 0}
!51 = !{!"long long", !7, i64 0}
!52 = distinct !{}
!53 = distinct !{!53, !54, !45}
!54 = !{!"llvm.loop.parallel_accesses", !52}
!55 = distinct !{}
!56 = distinct !{!56, !57, !45}
!57 = !{!"llvm.loop.parallel_accesses", !55}
