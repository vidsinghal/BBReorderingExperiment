; ModuleID = 'samples/285.bc'
source_filename = "../spack-src/test/x86/sse4.1.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.anon = type { ptr, ptr }
%struct.anon.26 = type { [2 x double], [2 x double], [2 x double], [2 x double], [2 x double] }
%struct.anon.27 = type { [4 x float], [4 x float], [4 x float], [4 x float], [4 x float] }
%struct.anon.31 = type { [4 x float], i32 }
%struct.anon.39 = type { [4 x float], [4 x float], [4 x float] }
%struct.anon.41 = type { [4 x float], [4 x float], [4 x float] }
%struct.anon.60 = type { [4 x float], [4 x float] }
%struct.anon.61 = type { [4 x float], [4 x float] }
%struct.anon.62 = type { [4 x float], [4 x float] }
%struct.anon.63 = type { [4 x float], [4 x float] }
%struct.anon.0 = type { <2 x i64>, <2 x i64>, <2 x i64> }
%union.simde__m128i_private = type { <16 x i8> }
%struct.anon.1 = type { <2 x double>, <2 x double>, <2 x double> }
%union.simde__m128d_private = type { <16 x i8> }
%struct.anon.2 = type { <4 x float>, <4 x float>, <4 x float> }
%union.simde__m128_private = type { <16 x i8> }
%struct.anon.3 = type { <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> }
%struct.anon.4 = type { <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> }
%struct.anon.5 = type { <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> }
%struct.anon.6 = type { <2 x i64>, <2 x i64>, <2 x i64>, <2 x i64> }
%struct.anon.7 = type { <2 x double>, <2 x double>, <2 x i64>, <2 x double> }
%struct.anon.8 = type { <4 x float>, <4 x float>, <2 x i64>, <4 x float> }
%struct.anon.9 = type { <2 x double>, <2 x double> }
%struct.anon.10 = type { <4 x float>, <4 x float> }
%struct.anon.11 = type { <2 x double>, <2 x double>, <2 x double> }
%struct.anon.12 = type { <4 x float>, <4 x float>, <4 x float> }
%struct.anon.13 = type { <2 x i64>, <2 x i64>, <2 x i64> }
%struct.anon.14 = type { <2 x i64>, <2 x i64> }
%struct.anon.15 = type { <2 x i64>, <2 x i64> }
%struct.anon.16 = type { <2 x i64>, <2 x i64> }
%struct.anon.17 = type { <2 x i64>, <2 x i64> }
%struct.anon.18 = type { <2 x i64>, <2 x i64> }
%struct.anon.19 = type { <2 x i64>, <2 x i64> }
%struct.anon.20 = type { <2 x i64>, <2 x i64> }
%struct.anon.21 = type { <2 x i64>, <2 x i64> }
%struct.anon.22 = type { <2 x i64>, <2 x i64> }
%struct.anon.23 = type { <2 x i64>, <2 x i64> }
%struct.anon.24 = type { <2 x i64>, <2 x i64> }
%struct.anon.25 = type { <2 x i64>, <2 x i64> }
%struct.anon.28 = type { <2 x i64>, i8, [15 x i8] }
%struct.anon.29 = type { <2 x i64>, i32, [12 x i8] }
%struct.anon.30 = type { <2 x i64>, i64, [8 x i8] }
%struct.anon.32 = type { <2 x double>, <2 x double> }
%struct.anon.33 = type { <4 x float>, <4 x float> }
%struct.anon.34 = type { <2 x double>, <2 x double>, <2 x double> }
%struct.anon.35 = type { <4 x float>, <4 x float>, <4 x float> }
%struct.anon.36 = type { <2 x i64>, i32, <2 x i64> }
%struct.anon.37 = type { <2 x i64>, i32, <2 x i64> }
%struct.anon.38 = type { <2 x i64>, i64, <2 x i64> }
%struct.anon.40 = type { <4 x float>, <4 x float>, <4 x float> }
%struct.anon.42 = type { <2 x i64>, <2 x i64>, <2 x i64> }
%struct.anon.43 = type { <2 x i64>, <2 x i64>, <2 x i64> }
%struct.anon.44 = type { <2 x i64>, <2 x i64>, <2 x i64> }
%struct.anon.45 = type { <2 x i64>, <2 x i64>, <2 x i64> }
%struct.anon.46 = type { <2 x i64>, <2 x i64>, <2 x i64> }
%struct.anon.47 = type { <2 x i64>, <2 x i64>, <2 x i64> }
%struct.anon.48 = type { <2 x i64>, <2 x i64>, <2 x i64> }
%struct.anon.49 = type { <2 x i64>, <2 x i64>, <2 x i64> }
%struct.anon.50 = type { <2 x i64>, <2 x i64> }
%struct.anon.51 = type { <2 x i64>, <2 x i64>, <2 x i64> }
%struct.anon.52 = type { <2 x i64>, <2 x i64>, <2 x i64> }
%struct.anon.53 = type { <2 x i64>, <2 x i64>, <2 x i64> }
%struct.anon.54 = type { <2 x i64>, <2 x i64>, <2 x i64> }
%struct.anon.55 = type { <2 x i64>, <2 x i64>, <2 x i64> }
%struct.anon.56 = type { <2 x double>, i32, <2 x double> }
%struct.anon.57 = type { <4 x float>, i32, <4 x float> }
%struct.anon.58 = type { <2 x double>, <2 x double>, i32, <2 x double> }
%struct.anon.59 = type { <4 x float>, <4 x float>, i32, <4 x float> }
%struct.anon.64 = type { <2 x i64>, <2 x i64> }
%struct.anon.65 = type { <2 x i64>, i32, [12 x i8] }
%struct.anon.66 = type { <2 x i64>, <2 x i64>, i32, [12 x i8] }
%struct.anon.67 = type { <2 x i64>, <2 x i64>, i32, [12 x i8] }
%struct.anon.68 = type { <2 x i64>, <2 x i64>, i32, [12 x i8] }
%struct.anon.69 = type { <2 x i64>, <2 x i64>, i32, [12 x i8] }
%struct.anon.70 = type { <2 x i64>, <2 x i64>, i32, [12 x i8] }
%struct.__va_list_tag = type { i32, i32, ptr, ptr }

@stdout = external global ptr, align 8
@.str = private unnamed_addr constant [8 x i8] c"1..%zu\0A\00", align 1
@test_suite_tests = internal constant [69 x %struct.anon] [%struct.anon { ptr @test_simde_mm_blend_epi16, ptr @.str.3 }, %struct.anon { ptr @test_simde_mm_blend_pd, ptr @.str.4 }, %struct.anon { ptr @test_simde_mm_blend_ps, ptr @.str.5 }, %struct.anon { ptr @test_simde_mm_blendv_epi8, ptr @.str.6 }, %struct.anon { ptr @test_simde_x_mm_blendv_epi16, ptr @.str.7 }, %struct.anon { ptr @test_simde_x_mm_blendv_epi32, ptr @.str.8 }, %struct.anon { ptr @test_simde_x_mm_blendv_epi64, ptr @.str.9 }, %struct.anon { ptr @test_simde_mm_blendv_pd, ptr @.str.10 }, %struct.anon { ptr @test_simde_mm_blendv_ps, ptr @.str.11 }, %struct.anon { ptr @test_simde_mm_ceil_pd, ptr @.str.12 }, %struct.anon { ptr @test_simde_mm_ceil_ps, ptr @.str.13 }, %struct.anon { ptr @test_simde_mm_ceil_sd, ptr @.str.14 }, %struct.anon { ptr @test_simde_mm_ceil_ss, ptr @.str.15 }, %struct.anon { ptr @test_simde_mm_cmpeq_epi64, ptr @.str.16 }, %struct.anon { ptr @test_simde_mm_cvtepi8_epi16, ptr @.str.17 }, %struct.anon { ptr @test_simde_mm_cvtepi8_epi32, ptr @.str.18 }, %struct.anon { ptr @test_simde_mm_cvtepi8_epi64, ptr @.str.19 }, %struct.anon { ptr @test_simde_mm_cvtepu8_epi16, ptr @.str.20 }, %struct.anon { ptr @test_simde_mm_cvtepu8_epi32, ptr @.str.21 }, %struct.anon { ptr @test_simde_mm_cvtepu8_epi64, ptr @.str.22 }, %struct.anon { ptr @test_simde_mm_cvtepi16_epi32, ptr @.str.23 }, %struct.anon { ptr @test_simde_mm_cvtepi16_epi64, ptr @.str.24 }, %struct.anon { ptr @test_simde_mm_cvtepu16_epi32, ptr @.str.25 }, %struct.anon { ptr @test_simde_mm_cvtepu16_epi64, ptr @.str.26 }, %struct.anon { ptr @test_simde_mm_cvtepi32_epi64, ptr @.str.27 }, %struct.anon { ptr @test_simde_mm_cvtepu32_epi64, ptr @.str.28 }, %struct.anon { ptr @test_simde_mm_dp_pd, ptr @.str.29 }, %struct.anon { ptr @test_simde_mm_dp_ps, ptr @.str.30 }, %struct.anon { ptr @test_simde_mm_extract_epi8, ptr @.str.31 }, %struct.anon { ptr @test_simde_mm_extract_epi32, ptr @.str.32 }, %struct.anon { ptr @test_simde_mm_extract_epi64, ptr @.str.33 }, %struct.anon { ptr @test_simde_mm_extract_ps, ptr @.str.34 }, %struct.anon { ptr @test_simde_mm_floor_pd, ptr @.str.35 }, %struct.anon { ptr @test_simde_mm_floor_ps, ptr @.str.36 }, %struct.anon { ptr @test_simde_mm_floor_sd, ptr @.str.37 }, %struct.anon { ptr @test_simde_mm_floor_ss, ptr @.str.38 }, %struct.anon { ptr @test_simde_mm_insert_epi8, ptr @.str.39 }, %struct.anon { ptr @test_simde_mm_insert_epi32, ptr @.str.40 }, %struct.anon { ptr @test_simde_mm_insert_epi64, ptr @.str.41 }, %struct.anon { ptr @test_simde_mm_insert_ps, ptr @.str.42 }, %struct.anon { ptr @test_simde_mm_max_epi8, ptr @.str.43 }, %struct.anon { ptr @test_simde_mm_max_epi32, ptr @.str.44 }, %struct.anon { ptr @test_simde_mm_max_epu16, ptr @.str.45 }, %struct.anon { ptr @test_simde_mm_max_epu32, ptr @.str.46 }, %struct.anon { ptr @test_simde_mm_min_epi8, ptr @.str.47 }, %struct.anon { ptr @test_simde_mm_min_epi32, ptr @.str.48 }, %struct.anon { ptr @test_simde_mm_min_epu16, ptr @.str.49 }, %struct.anon { ptr @test_simde_mm_min_epu32, ptr @.str.50 }, %struct.anon { ptr @test_simde_mm_minpos_epu16, ptr @.str.51 }, %struct.anon { ptr @test_simde_mm_mpsadbw_epu8, ptr @.str.52 }, %struct.anon { ptr @test_simde_mm_mul_epi32, ptr @.str.53 }, %struct.anon { ptr @test_simde_mm_mullo_epi32, ptr @.str.54 }, %struct.anon { ptr @test_simde_x_mm_mullo_epu32, ptr @.str.55 }, %struct.anon { ptr @test_simde_mm_packus_epi32, ptr @.str.56 }, %struct.anon { ptr @test_simde_mm_round_pd, ptr @.str.57 }, %struct.anon { ptr @test_simde_mm_round_ps, ptr @.str.58 }, %struct.anon { ptr @test_simde_mm_round_sd, ptr @.str.59 }, %struct.anon { ptr @test_simde_mm_round_ss, ptr @.str.60 }, %struct.anon { ptr @test_simde_mm_round_ps_nearest, ptr @.str.61 }, %struct.anon { ptr @test_simde_mm_round_ps_ninf, ptr @.str.62 }, %struct.anon { ptr @test_simde_mm_round_ps_pinf, ptr @.str.63 }, %struct.anon { ptr @test_simde_mm_round_ps_zero, ptr @.str.64 }, %struct.anon { ptr @test_simde_mm_stream_load_si128, ptr @.str.65 }, %struct.anon { ptr @test_simde_mm_test_all_ones, ptr @.str.66 }, %struct.anon { ptr @test_simde_mm_test_all_zeros, ptr @.str.67 }, %struct.anon { ptr @test_simde_mm_test_mix_ones_zeros, ptr @.str.68 }, %struct.anon { ptr @test_simde_mm_testc_si128, ptr @.str.69 }, %struct.anon { ptr @test_simde_mm_testnzc_si128, ptr @.str.70 }, %struct.anon { ptr @test_simde_mm_testz_si128, ptr @.str.71 }], align 16
@.str.1 = private unnamed_addr constant [22 x i8] c"not ok %zu sse4_1/%s\0A\00", align 1
@.str.2 = private unnamed_addr constant [18 x i8] c"ok %zu sse4_1/%s\0A\00", align 1
@.str.3 = private unnamed_addr constant [15 x i8] c"mm_blend_epi16\00", align 1
@.str.4 = private unnamed_addr constant [12 x i8] c"mm_blend_pd\00", align 1
@.str.5 = private unnamed_addr constant [12 x i8] c"mm_blend_ps\00", align 1
@.str.6 = private unnamed_addr constant [15 x i8] c"mm_blendv_epi8\00", align 1
@.str.7 = private unnamed_addr constant [18 x i8] c"x_mm_blendv_epi16\00", align 1
@.str.8 = private unnamed_addr constant [18 x i8] c"x_mm_blendv_epi32\00", align 1
@.str.9 = private unnamed_addr constant [18 x i8] c"x_mm_blendv_epi64\00", align 1
@.str.10 = private unnamed_addr constant [13 x i8] c"mm_blendv_pd\00", align 1
@.str.11 = private unnamed_addr constant [13 x i8] c"mm_blendv_ps\00", align 1
@.str.12 = private unnamed_addr constant [11 x i8] c"mm_ceil_pd\00", align 1
@.str.13 = private unnamed_addr constant [11 x i8] c"mm_ceil_ps\00", align 1
@.str.14 = private unnamed_addr constant [11 x i8] c"mm_ceil_sd\00", align 1
@.str.15 = private unnamed_addr constant [11 x i8] c"mm_ceil_ss\00", align 1
@.str.16 = private unnamed_addr constant [15 x i8] c"mm_cmpeq_epi64\00", align 1
@.str.17 = private unnamed_addr constant [17 x i8] c"mm_cvtepi8_epi16\00", align 1
@.str.18 = private unnamed_addr constant [17 x i8] c"mm_cvtepi8_epi32\00", align 1
@.str.19 = private unnamed_addr constant [17 x i8] c"mm_cvtepi8_epi64\00", align 1
@.str.20 = private unnamed_addr constant [17 x i8] c"mm_cvtepu8_epi16\00", align 1
@.str.21 = private unnamed_addr constant [17 x i8] c"mm_cvtepu8_epi32\00", align 1
@.str.22 = private unnamed_addr constant [17 x i8] c"mm_cvtepu8_epi64\00", align 1
@.str.23 = private unnamed_addr constant [18 x i8] c"mm_cvtepi16_epi32\00", align 1
@.str.24 = private unnamed_addr constant [18 x i8] c"mm_cvtepi16_epi64\00", align 1
@.str.25 = private unnamed_addr constant [18 x i8] c"mm_cvtepu16_epi32\00", align 1
@.str.26 = private unnamed_addr constant [18 x i8] c"mm_cvtepu16_epi64\00", align 1
@.str.27 = private unnamed_addr constant [18 x i8] c"mm_cvtepi32_epi64\00", align 1
@.str.28 = private unnamed_addr constant [18 x i8] c"mm_cvtepu32_epi64\00", align 1
@.str.29 = private unnamed_addr constant [9 x i8] c"mm_dp_pd\00", align 1
@.str.30 = private unnamed_addr constant [9 x i8] c"mm_dp_ps\00", align 1
@.str.31 = private unnamed_addr constant [16 x i8] c"mm_extract_epi8\00", align 1
@.str.32 = private unnamed_addr constant [17 x i8] c"mm_extract_epi32\00", align 1
@.str.33 = private unnamed_addr constant [17 x i8] c"mm_extract_epi64\00", align 1
@.str.34 = private unnamed_addr constant [14 x i8] c"mm_extract_ps\00", align 1
@.str.35 = private unnamed_addr constant [12 x i8] c"mm_floor_pd\00", align 1
@.str.36 = private unnamed_addr constant [12 x i8] c"mm_floor_ps\00", align 1
@.str.37 = private unnamed_addr constant [12 x i8] c"mm_floor_sd\00", align 1
@.str.38 = private unnamed_addr constant [12 x i8] c"mm_floor_ss\00", align 1
@.str.39 = private unnamed_addr constant [15 x i8] c"mm_insert_epi8\00", align 1
@.str.40 = private unnamed_addr constant [16 x i8] c"mm_insert_epi32\00", align 1
@.str.41 = private unnamed_addr constant [16 x i8] c"mm_insert_epi64\00", align 1
@.str.42 = private unnamed_addr constant [13 x i8] c"mm_insert_ps\00", align 1
@.str.43 = private unnamed_addr constant [12 x i8] c"mm_max_epi8\00", align 1
@.str.44 = private unnamed_addr constant [13 x i8] c"mm_max_epi32\00", align 1
@.str.45 = private unnamed_addr constant [13 x i8] c"mm_max_epu16\00", align 1
@.str.46 = private unnamed_addr constant [13 x i8] c"mm_max_epu32\00", align 1
@.str.47 = private unnamed_addr constant [12 x i8] c"mm_min_epi8\00", align 1
@.str.48 = private unnamed_addr constant [13 x i8] c"mm_min_epi32\00", align 1
@.str.49 = private unnamed_addr constant [13 x i8] c"mm_min_epu16\00", align 1
@.str.50 = private unnamed_addr constant [13 x i8] c"mm_min_epu32\00", align 1
@.str.51 = private unnamed_addr constant [16 x i8] c"mm_minpos_epu16\00", align 1
@.str.52 = private unnamed_addr constant [16 x i8] c"mm_mpsadbw_epu8\00", align 1
@.str.53 = private unnamed_addr constant [13 x i8] c"mm_mul_epi32\00", align 1
@.str.54 = private unnamed_addr constant [15 x i8] c"mm_mullo_epi32\00", align 1
@.str.55 = private unnamed_addr constant [17 x i8] c"x_mm_mullo_epu32\00", align 1
@.str.56 = private unnamed_addr constant [16 x i8] c"mm_packus_epi32\00", align 1
@.str.57 = private unnamed_addr constant [12 x i8] c"mm_round_pd\00", align 1
@.str.58 = private unnamed_addr constant [12 x i8] c"mm_round_ps\00", align 1
@.str.59 = private unnamed_addr constant [12 x i8] c"mm_round_sd\00", align 1
@.str.60 = private unnamed_addr constant [12 x i8] c"mm_round_ss\00", align 1
@.str.61 = private unnamed_addr constant [20 x i8] c"mm_round_ps_nearest\00", align 1
@.str.62 = private unnamed_addr constant [17 x i8] c"mm_round_ps_ninf\00", align 1
@.str.63 = private unnamed_addr constant [17 x i8] c"mm_round_ps_pinf\00", align 1
@.str.64 = private unnamed_addr constant [17 x i8] c"mm_round_ps_zero\00", align 1
@.str.65 = private unnamed_addr constant [21 x i8] c"mm_stream_load_si128\00", align 1
@.str.66 = private unnamed_addr constant [17 x i8] c"mm_test_all_ones\00", align 1
@.str.67 = private unnamed_addr constant [18 x i8] c"mm_test_all_zeros\00", align 1
@.str.68 = private unnamed_addr constant [23 x i8] c"mm_test_mix_ones_zeros\00", align 1
@.str.69 = private unnamed_addr constant [15 x i8] c"mm_testc_si128\00", align 1
@.str.70 = private unnamed_addr constant [17 x i8] c"mm_testnzc_si128\00", align 1
@.str.71 = private unnamed_addr constant [15 x i8] c"mm_testz_si128\00", align 1
@.str.72 = private unnamed_addr constant [31 x i8] c"../spack-src/test/x86/sse4.1.c\00", align 1
@.str.73 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.74 = private unnamed_addr constant [14 x i8] c"test_vec[i].r\00", align 1
@.str.75 = private unnamed_addr constant [56 x i8] c"%s:%d: assertion failed: %s[%zu] == %s[%zu] (%d == %d)\0A\00", align 1
@stderr = external global ptr, align 8
@.str.76 = private unnamed_addr constant [56 x i8] c"%s:%d: assertion failed: %s[%zu] ~= %s[%zu] (%f ~= %f)\0A\00", align 1
@.str.77 = private unnamed_addr constant [58 x i8] c"%s:%d: assertion failed: %s[%zu] == %s[%zu] (%ld == %ld)\0A\00", align 1
@test_simde_mm_dp_pd.test_vec = internal constant [8 x %struct.anon.26] [%struct.anon.26 { [2 x double] [double -1.851000e+02, double -8.143100e+02], [2 x double] [double 0xC083CB3333333333, double 2.640700e+02], [2 x double] [double -9.779250e+04, double -9.779250e+04], [2 x double] [double 0x40FC9FA570A3D70A, double 0x40FC9FA570A3D70A], [2 x double] zeroinitializer }, %struct.anon.26 { [2 x double] [double -5.650600e+02, double 6.981000e+01], [2 x double] [double -6.300200e+02, double 0x40856F0A3D70A3D7], [2 x double] [double 0x4118A6A1851EB852, double 0x4118A6A1851EB852], [2 x double] [double 0x4115BA7C66666666, double 0x4115BA7C66666666], [2 x double] zeroinitializer }, %struct.anon.26 { [2 x double] [double 0xC08C8170A3D70A3D, double 0xC084E15C28F5C28F], [2 x double] [double 1.014100e+02, double -2.690300e+02], [2 x double] [double 8.725360e+04, double 8.725360e+04], [2 x double] [double 0xC0F69582B851EB85, double 0xC0F69582B851EB85], [2 x double] zeroinitializer }, %struct.anon.26 { [2 x double] [double 2.856400e+02, double 8.804600e+02], [2 x double] [double 0xC089853333333333, double -8.357200e+02], [2 x double] [double 0xC12D92FBE147AE14, double 0xC12D92FBE147AE14], [2 x double] [double 0xC10C799F47AE147B, double 0xC10C799F47AE147B], [2 x double] zeroinitializer }, %struct.anon.26 { [2 x double] [double -4.362500e+02, double -2.568400e+02], [2 x double] [double -1.710100e+02, double -1.917400e+02], [2 x double] [double 0x40FE3C99C28F5C29, double 0x40FE3C99C28F5C29], [2 x double] [double 0x40F236B1C28F5C29, double 0x40F236B1C28F5C29], [2 x double] zeroinitializer }, %struct.anon.26 { [2 x double] [double -8.393300e+02, double 0x408A8170A3D70A3D], [2 x double] [double -4.700400e+02, double 1.036900e+02], [2 x double] [double 0x411D7289D70A3D71, double 0x411D7289D70A3D71], [2 x double] [double 0x4118145AAE147AE1, double 0x4118145AAE147AE1], [2 x double] zeroinitializer }, %struct.anon.26 { [2 x double] [double -6.865600e+02, double -7.177700e+02], [2 x double] [double 0x408BD91EB851EB85, double 5.679100e+02], [2 x double] [double 0xC12F1C73AE147AE1, double 0xC12F1C73AE147AE1], [2 x double] [double 0xC122ABDA28F5C28F, double 0xC122ABDA28F5C28F], [2 x double] zeroinitializer }, %struct.anon.26 { [2 x double] [double 5.962600e+02, double 0x4086955C28F5C28F], [2 x double] [double 0xC089E35C28F5C28F, double -5.888400e+02], [2 x double] [double 0xC12C0F856B851EB8, double 0xC12C0F856B851EB8], [2 x double] [double 0xC11E2606D70A3D71, double 0xC11E2606D70A3D71], [2 x double] zeroinitializer }], align 16
@.str.78 = private unnamed_addr constant [35 x i8] c"simde_mm_loadu_pd(test_vec[i].rff)\00", align 1
@.str.79 = private unnamed_addr constant [35 x i8] c"simde_mm_loadu_pd(test_vec[i].r13)\00", align 1
@.str.80 = private unnamed_addr constant [35 x i8] c"simde_mm_loadu_pd(test_vec[i].r42)\00", align 1
@test_simde_mm_dp_ps.test_vec = internal constant [8 x %struct.anon.27] [%struct.anon.27 { [4 x float] [float 0x7FF8000000000000, float 0xC05538F5C0000000, float 0x7FF8000000000000, float 0x4052928F60000000], [4 x float] [float 0xC049D999A0000000, float 0x7FF8000000000000, float 0x7FF8000000000000, float 0x4054A47AE0000000], [4 x float] [float 0x7FF8000000000000, float 0x7FF8000000000000, float 0x7FF8000000000000, float 0x7FF8000000000000], [4 x float] [float 0x7FF8000000000000, float 0x7FF8000000000000, float 0x7FF8000000000000, float 0x7FF8000000000000], [4 x float] [float 0.000000e+00, float 0x7FF8000000000000, float 0.000000e+00, float 0x7FF8000000000000] }, %struct.anon.27 { [4 x float] [float 0x40371EB860000000, float 0x40365C2900000000, float 0xC02D1999A0000000, float 0x403AB5C280000000], [4 x float] [float 0x404B1D70A0000000, float 0xC03F428F60000000, float 0x403A4A3D80000000, float 0x40426CCCC0000000], [4 x float] [float 0x40921247A0000000, float 0x40921247A0000000, float 0x40921247A0000000, float 0x40921247A0000000], [4 x float] [float 0x40658999A0000000, float 0x40658999A0000000, float 0x40658999A0000000, float 0x40658999A0000000], [4 x float] [float 0.000000e+00, float 0xC085D7C280000000, float 0.000000e+00, float 0xC085D7C280000000] }, %struct.anon.27 { [4 x float] [float 0xC04C5AE140000000, float 0x4052F47AE0000000, float 0x40498F5C20000000, float 0xC057A51EC0000000], [4 x float] [float 0xC03E9999A0000000, float 0x4043B0A3E0000000, float 0x40562D70A0000000, float 0xC03DF0A3E0000000], [4 x float] [float 0x40C79BD9A0000000, float 0x40C79BD9A0000000, float 0x40C79BD9A0000000, float 0x40C79BD9A0000000], [4 x float] [float 0x40C213FC20000000, float 0x40C213FC20000000, float 0x40C213FC20000000, float 0x40C213FC20000000], [4 x float] [float 0.000000e+00, float 0x40A7539480000000, float 0.000000e+00, float 0x40A7539480000000] }, %struct.anon.27 { [4 x float] [float 0xC04ADAE140000000, float 0xC042A51EC0000000, float 0x4044ECCCC0000000, float 0xC05725C280000000], [4 x float] [float 0xC030666660000000, float 0xC03BC7AE20000000, float 0xC052351EC0000000, float 0x400D9999A0000000], [4 x float] [float 0xC097070A40000000, float 0xC097070A40000000, float 0xC097070A40000000, float 0xC097070A40000000], [4 x float] [float 0xC091ACB860000000, float 0xC091ACB860000000, float 0xC091ACB860000000, float 0xC091ACB860000000], [4 x float] [float 0.000000e+00, float 0x40902FAE20000000, float 0.000000e+00, float 0x40902FAE20000000] }, %struct.anon.27 { [4 x float] [float 0xC029570A40000000, float 0x3FD1EB8520000000, float 0xC036028F60000000, float 0x4041D0A3E0000000], [4 x float] [float 0x40401D70A0000000, float 0x403E547AE0000000, float 0x4032333340000000, float 0xC046533340000000], [4 x float] [float 0xC0A2AEA3E0000000, float 0xC0A2AEA3E0000000, float 0xC0A2AEA3E0000000, float 0xC0A2AEA3E0000000], [4 x float] [float 0xC089038520000000, float 0xC089038520000000, float 0xC089038520000000, float 0xC089038520000000], [4 x float] [float 0.000000e+00, float 0x4020FAE140000000, float 0.000000e+00, float 0x4020FAE140000000] }, %struct.anon.27 { [4 x float] [float 0xC047A7AE20000000, float 0xC058166660000000, float 0x405483D700000000, float 0xC057451EC0000000], [4 x float] [float 0xC03B9C2900000000, float 0x4020B33340000000, float 0x4045E28F60000000, float 0x402F5C2900000000], [4 x float] [float 0x40A493F5C0000000, float 0x40A493F5C0000000, float 0x40A493F5C0000000, float 0x40A493F5C0000000], [4 x float] [float 0x40AFFAF0A0000000, float 0x40AFFAF0A0000000, float 0x40AFFAF0A0000000, float 0x40AFFAF0A0000000], [4 x float] [float 0.000000e+00, float 0xC089242900000000, float 0.000000e+00, float 0xC089242900000000] }, %struct.anon.27 { [4 x float] [float 0xC02FA3D700000000, float 0xC01470A3E0000000, float 0x40351999A0000000, float 0x404AC8F5C0000000], [4 x float] [float 0xC0506EB860000000, float 0x40239EB860000000, float 0xC053170A40000000, float 0xC0336E1480000000], [4 x float] [float 0xC099F95C20000000, float 0xC099F95C20000000, float 0xC099F95C20000000, float 0xC099F95C20000000], [4 x float] [float 0xC0836BD700000000, float 0xC0836BD700000000, float 0xC0836BD700000000, float 0xC0836BD700000000], [4 x float] [float 0.000000e+00, float 0xC04910A3E0000000, float 0.000000e+00, float 0xC04910A3E0000000] }, %struct.anon.27 { [4 x float] [float 0x40522147A0000000, float 0x40505EB860000000, float 0xC0280A3D80000000, float 0xC045F0A3E0000000], [4 x float] [float 0xC04F266660000000, float 0x402E4CCCC0000000, float 0x404DE8F5C0000000, float 0x403907AE20000000], [4 x float] [float 0xC0B4DF5480000000, float 0xC0B4DF5480000000, float 0xC0B4DF5480000000, float 0xC0B4DF5480000000], [4 x float] [float 0xC0B0950280000000, float 0xC0B0950280000000, float 0xC0B0950280000000, float 0xC0B0950280000000], [4 x float] [float 0.000000e+00, float 0x408F002900000000, float 0.000000e+00, float 0x408F002900000000] }], align 16
@.str.81 = private unnamed_addr constant [27 x i8] c"simde_mm_dp_ps(a, b, 0xff)\00", align 1
@.str.82 = private unnamed_addr constant [35 x i8] c"simde_mm_loadu_ps(test_vec[i].rff)\00", align 1
@.str.83 = private unnamed_addr constant [27 x i8] c"simde_mm_dp_ps(a, b, 0x7f)\00", align 1
@.str.84 = private unnamed_addr constant [35 x i8] c"simde_mm_loadu_ps(test_vec[i].r7f)\00", align 1
@.str.85 = private unnamed_addr constant [27 x i8] c"simde_mm_dp_ps(a, b, 0x2a)\00", align 1
@.str.86 = private unnamed_addr constant [35 x i8] c"simde_mm_loadu_ps(test_vec[i].r2a)\00", align 1
@.str.87 = private unnamed_addr constant [46 x i8] c"%s:%d: assertion failed: %s == %s (%d == %d)\0A\00", align 1
@.str.88 = private unnamed_addr constant [48 x i8] c"%s:%d: assertion failed: %s == %s (%ld == %ld)\0A\00", align 1
@test_simde_mm_extract_ps.test_vec = internal constant [8 x %struct.anon.31] [%struct.anon.31 { [4 x float] [float 0xC08A8AE140000000, float 0xC082B651E0000000, float 0xC086F86660000000, float 0x407B342900000000], i32 -1001105654 }, %struct.anon.31 { [4 x float] [float 0xC08EFE6660000000, float 0xC082F799A0000000, float 5.320000e+02, float 0xC06E74CCC0000000], i32 -998771917 }, %struct.anon.31 { [4 x float] [float 6.520000e+02, float 0xC0891D3340000000, float 0x408AA9D700000000, float 0xC07DF28F60000000], i32 1143144448 }, %struct.anon.31 { [4 x float] [float 0xC07F002900000000, float 0xC07C142900000000, float 0x4089C0CCC0000000, float 0x4069CA3D80000000], i32 -1007156920 }, %struct.anon.31 { [4 x float] [float 0xC0812DEB80000000, float 0x402C28F5C0000000, float 0x408BEAF5C0000000, float 0x408CCD47A0000000], i32 -1006014628 }, %struct.anon.31 { [4 x float] [float 0xC07283AE20000000, float 0x4060A1EB80000000, float 0xC0613BD700000000, float 0xC0820C6660000000], i32 -1013703311 }, %struct.anon.31 { [4 x float] [float 0xC058828F60000000, float 0x4087408F60000000, float 0x40510851E0000000, float 0x4073B8CCC0000000], i32 -1027337093 }, %struct.anon.31 { [4 x float] [float 0xC070226660000000, float 0x4082662900000000, float 0xC086910A40000000, float 0xC05AE0A3E0000000], i32 -1014951117 }], align 16
@__const.test_simde_mm_insert_ps.test_vec_0 = private unnamed_addr constant [8 x %struct.anon.39] [%struct.anon.39 { [4 x float] [float 0x408F0AE140000000, float 0xC06FE47AE0000000, float 0x40642999A0000000, float 0x4082858520000000], [4 x float] [float 0xC06A13D700000000, float 0xC06995C280000000, float 0xC081470A40000000, float 0x4088F06660000000], [4 x float] [float 0xC06A13D700000000, float 0xC06FE47AE0000000, float 0x40642999A0000000, float 0x4082858520000000] }, %struct.anon.39 { [4 x float] [float 0x40741170A0000000, float 0x4088F6B860000000, float 0x40831199A0000000, float 0xC08B9FD700000000], [4 x float] [float 0x407BEB0A40000000, float 0xC073D47AE0000000, float 0xC06A128F60000000, float 0xC08BBB3340000000], [4 x float] [float 0x407BEB0A40000000, float 0x4088F6B860000000, float 0x40831199A0000000, float 0xC08B9FD700000000] }, %struct.anon.39 { [4 x float] [float 0xC05E728F60000000, float 0xC08BA6B860000000, float 0xC0444E1480000000, float 0xC07B0199A0000000], [4 x float] [float 0xC084CD1EC0000000, float 0xC06B1CCCC0000000, float 1.000000e+01, float 0x406BEBD700000000], [4 x float] [float 0xC084CD1EC0000000, float 0xC08BA6B860000000, float 0xC0444E1480000000, float 0xC07B0199A0000000] }, %struct.anon.39 { [4 x float] [float 0x4033D70A40000000, float 0xC08918F5C0000000, float 0x40715F8520000000, float 0x4084D8B860000000], [4 x float] [float 0xC08C1BC280000000, float 0x408C2B5C20000000, float 0xC084C1EB80000000, float 0xC08C50CCC0000000], [4 x float] [float 0xC08C1BC280000000, float 0xC08918F5C0000000, float 0x40715F8520000000, float 0x4084D8B860000000] }, %struct.anon.39 { [4 x float] [float 0xC0761B8520000000, float 0x407F10F5C0000000, float 0x408574B860000000, float 0x407B5A8F60000000], [4 x float] [float 0xC0861CF5C0000000, float 0xC08B1251E0000000, float 0x406D76B860000000, float 0x40832BC280000000], [4 x float] [float 0xC0861CF5C0000000, float 0x407F10F5C0000000, float 0x408574B860000000, float 0x407B5A8F60000000] }, %struct.anon.39 { [4 x float] [float 0x408D246660000000, float 0xC06342E140000000, float 0x4086CBEB80000000, float 0x4077B3D700000000], [4 x float] [float 0x4080850A40000000, float 0xC07DF170A0000000, float 0x407EBD70A0000000, float 0xC0828947A0000000], [4 x float] [float 0x4080850A40000000, float 0xC06342E140000000, float 0x4086CBEB80000000, float 0x4077B3D700000000] }, %struct.anon.39 { [4 x float] [float 0xC076BEE140000000, float 0xC081262900000000, float 0xC039428F60000000, float 0xC03D8F5C20000000], [4 x float] [float 0x406D4A8F60000000, float 0x408EC5EB80000000, float 0xC0893199A0000000, float 0xC0874EA3E0000000], [4 x float] [float 0x406D4A8F60000000, float 0xC081262900000000, float 0xC039428F60000000, float 0xC03D8F5C20000000] }, %struct.anon.39 { [4 x float] [float 0xC089930A40000000, float 0x407D7C7AE0000000, float 0x408CCA1480000000, float 0xC0866ECCC0000000], [4 x float] [float 0x4077533340000000, float 0xC08737D700000000, float 0xC0837F99A0000000, float 0xC08EA42900000000], [4 x float] [float 0x4077533340000000, float 0x407D7C7AE0000000, float 0x408CCA1480000000, float 0xC0866ECCC0000000] }], align 16
@__const.test_simde_mm_insert_ps.test_vec_4 = private unnamed_addr constant [8 x %struct.anon.41] [%struct.anon.41 { [4 x float] [float 0x407CB68F60000000, float 0x408B0399A0000000, float 0xC0637199A0000000, float 0xC072F1EB80000000], [4 x float] [float 0x40869F5C20000000, float 0x40684DC280000000, float 0x408AF53340000000, float 0x408106E140000000], [4 x float] [float 0x40869F5C20000000, float 0x408B0399A0000000, float 0.000000e+00, float 0xC072F1EB80000000] }, %struct.anon.41 { [4 x float] [float 0x4080CA8F60000000, float 0x40825D70A0000000, float 0x4078C6E140000000, float 0xC081CE8F60000000], [4 x float] [float 0x40784CCCC0000000, float 0xC06EB8F5C0000000, float 0x40808FAE20000000, float 0xC070C21480000000], [4 x float] [float 0x40784CCCC0000000, float 0x40825D70A0000000, float 0.000000e+00, float 0xC081CE8F60000000] }, %struct.anon.41 { [4 x float] [float 0xC07182B860000000, float 0x4080591EC0000000, float 0x407B021480000000, float 0xC04B7D70A0000000], [4 x float] [float 0x40874DEB80000000, float 0x4086BACCC0000000, float 0xC0680C2900000000, float 0x4089750A40000000], [4 x float] [float 0x40874DEB80000000, float 0x4080591EC0000000, float 0.000000e+00, float 0xC04B7D70A0000000] }, %struct.anon.41 { [4 x float] [float 0xC06D0A3D80000000, float -6.017500e+02, float 0xC08DB95C20000000, float 0x4063738520000000], [4 x float] [float 0x4053E33340000000, float 0xC080B851E0000000, float 0x4071D851E0000000, float 0xC07CD0A3E0000000], [4 x float] [float 0x4053E33340000000, float -6.017500e+02, float 0.000000e+00, float 0x4063738520000000] }, %struct.anon.41 { [4 x float] [float 0xC084F4B860000000, float 0xC08B303D80000000, float 0x406D7AE140000000, float 0xC08D955C20000000], [4 x float] [float 0x4074466660000000, float 0x40589F5C20000000, float 0x4082B18520000000, float 0xC06148F5C0000000], [4 x float] [float 0x4074466660000000, float 0xC08B303D80000000, float 0.000000e+00, float 0xC08D955C20000000] }, %struct.anon.41 { [4 x float] [float 0xC0739D47A0000000, float 0xC015851EC0000000, float 0x40723E6660000000, float 0xC08CE83D80000000], [4 x float] [float 0x408766B860000000, float 0xC066447AE0000000, float 0xC068251EC0000000, float 0xC0809AA3E0000000], [4 x float] [float 0x408766B860000000, float 0xC015851EC0000000, float 0.000000e+00, float 0xC08CE83D80000000] }, %struct.anon.41 { [4 x float] [float -6.550000e+02, float 0xC087C83D80000000, float 0x4079DB0A40000000, float 0xC08C6A2900000000], [4 x float] [float 0x408E328F60000000, float 0xC088558520000000, float 0x408C4AE140000000, float -2.660000e+02], [4 x float] [float 0x408E328F60000000, float 0xC087C83D80000000, float 0.000000e+00, float 0xC08C6A2900000000] }, %struct.anon.41 { [4 x float] [float 0xC077C70A40000000, float 0x408DD18520000000, float 0x408BCCE140000000, float 0x4085D8E140000000], [4 x float] [float 0xC08226CCC0000000, float 0x4065E42900000000, float 0xC087CF5C20000000, float 0xC06F6E1480000000], [4 x float] [float 0xC08226CCC0000000, float 0x408DD18520000000, float 0.000000e+00, float 0x4085D8E140000000] }], align 16
@.str.89 = private unnamed_addr constant [35 x i8] c"simde_mm_loadu_ps(test_vec_0[i].r)\00", align 1
@.str.90 = private unnamed_addr constant [16 x i8] c"test_vec_3[i].r\00", align 1
@.str.91 = private unnamed_addr constant [35 x i8] c"simde_mm_loadu_ps(test_vec_4[i].r)\00", align 1
@.str.92 = private unnamed_addr constant [56 x i8] c"%s:%d: assertion failed: %s[%zu] == %s[%zu] (%u == %u)\0A\00", align 1
@test_simde_mm_round_ps_nearest.test_vec = internal constant [8 x %struct.anon.60] [%struct.anon.60 { [4 x float] [float 9.425000e+02, float -1.700000e+02, float -7.075000e+02, float -1.415000e+02], [4 x float] [float 9.420000e+02, float -1.700000e+02, float -7.080000e+02, float -1.420000e+02] }, %struct.anon.60 { [4 x float] [float 7.305000e+02, float -3.825000e+02, float -5.847500e+02, float 3.160000e+02], [4 x float] [float 7.300000e+02, float -3.820000e+02, float -5.850000e+02, float 3.160000e+02] }, %struct.anon.60 { [4 x float] [float 6.645000e+02, float 1.025000e+02, float -7.160000e+02, float 3.505000e+02], [4 x float] [float 6.640000e+02, float 1.020000e+02, float -7.160000e+02, float 3.500000e+02] }, %struct.anon.60 { [4 x float] [float 6.585000e+02, float 6.975000e+02, float -6.345000e+02, float -5.600000e+02], [4 x float] [float 6.580000e+02, float 6.980000e+02, float -6.340000e+02, float -5.600000e+02] }, %struct.anon.60 { [4 x float] [float 9.095000e+02, float 0x407A2CCCC0000000, float -3.005000e+02, float 8.990000e+02], [4 x float] [float 9.100000e+02, float 4.190000e+02, float -3.000000e+02, float 8.990000e+02] }, %struct.anon.60 { [4 x float] [float -4.355000e+02, float -7.525000e+02, float 5.355000e+02, float -7.285000e+02], [4 x float] [float -4.360000e+02, float -7.520000e+02, float 5.360000e+02, float -7.280000e+02] }, %struct.anon.60 { [4 x float] [float 4.555000e+02, float -8.265000e+02, float 4.740000e+02, float 0x4045CF5C20000000], [4 x float] [float 4.560000e+02, float -8.260000e+02, float 4.740000e+02, float 4.400000e+01] }, %struct.anon.60 { [4 x float] [float -2.245000e+02, float 1.955000e+02, float 0x4083D3AE20000000, float -6.705000e+02], [4 x float] [float -2.240000e+02, float 1.960000e+02, float 6.340000e+02, float -6.700000e+02] }], align 16
@.str.93 = private unnamed_addr constant [33 x i8] c"simde_mm_loadu_ps(test_vec[i].r)\00", align 1
@test_simde_mm_round_ps_ninf.test_vec = internal constant [8 x %struct.anon.61] [%struct.anon.61 { [4 x float] [float 4.575000e+02, float 4.975000e+02, float -4.295000e+02, float 3.450000e+01], [4 x float] [float 4.570000e+02, float 4.970000e+02, float -4.300000e+02, float 3.400000e+01] }, %struct.anon.61 { [4 x float] [float 6.575000e+02, float 3.595000e+02, float -8.325000e+02, float -6.755000e+02], [4 x float] [float 6.570000e+02, float 3.590000e+02, float -8.330000e+02, float -6.760000e+02] }, %struct.anon.61 { [4 x float] [float -7.125000e+02, float -7.500000e+00, float 5.055000e+02, float -3.350000e+01], [4 x float] [float -7.130000e+02, float -8.000000e+00, float 5.050000e+02, float -3.400000e+01] }, %struct.anon.61 { [4 x float] [float 8.665000e+02, float 5.000000e-01, float -8.905000e+02, float -1.185000e+02], [4 x float] [float 8.660000e+02, float 0.000000e+00, float -8.910000e+02, float -1.190000e+02] }, %struct.anon.61 { [4 x float] [float -5.935000e+02, float -4.715000e+02, float -3.825000e+02, float -2.305000e+02], [4 x float] [float -5.940000e+02, float -4.720000e+02, float -3.830000e+02, float -2.310000e+02] }, %struct.anon.61 { [4 x float] [float 0x407B670A40000000, float 0x40751F8520000000, float -5.500000e+00, float -1.395000e+02], [4 x float] [float 4.380000e+02, float 3.370000e+02, float -6.000000e+00, float -1.400000e+02] }, %struct.anon.61 { [4 x float] [float 8.605000e+02, float 9.685000e+02, float 0xC062DD1EC0000000, float 0x4085EA1480000000], [4 x float] [float 8.600000e+02, float 9.680000e+02, float -1.510000e+02, float 7.010000e+02] }, %struct.anon.61 { [4 x float] [float 5.755000e+02, float -1.795000e+02, float -6.485000e+02, float 0xC05F9EB860000000], [4 x float] [float 5.750000e+02, float -1.800000e+02, float -6.490000e+02, float -1.270000e+02] }], align 16
@test_simde_mm_round_ps_pinf.test_vec = internal constant [8 x %struct.anon.62] [%struct.anon.62 { [4 x float] [float -9.415000e+02, float -6.255000e+02, float 5.065000e+02, float -1.810000e+02], [4 x float] [float -9.410000e+02, float -6.250000e+02, float 5.070000e+02, float -1.810000e+02] }, %struct.anon.62 { [4 x float] [float 5.400000e+01, float 5.735000e+02, float 2.345000e+02, float -4.045000e+02], [4 x float] [float 5.400000e+01, float 5.740000e+02, float 2.350000e+02, float -4.040000e+02] }, %struct.anon.62 { [4 x float] [float 4.335000e+02, float -5.925000e+02, float -1.995000e+02, float 6.150000e+02], [4 x float] [float 4.340000e+02, float -5.920000e+02, float -1.990000e+02, float 6.150000e+02] }, %struct.anon.62 { [4 x float] [float -7.850000e+01, float 3.650000e+01, float 2.700000e+01, float 2.055000e+02], [4 x float] [float -7.800000e+01, float 3.700000e+01, float 2.700000e+01, float 2.060000e+02] }, %struct.anon.62 { [4 x float] [float 3.450000e+01, float 7.757500e+02, float -6.285000e+02, float -7.535000e+02], [4 x float] [float 3.500000e+01, float 7.760000e+02, float -6.280000e+02, float -7.530000e+02] }, %struct.anon.62 { [4 x float] [float -4.925000e+02, float -1.725000e+02, float 5.195000e+02, float 7.185000e+02], [4 x float] [float -4.920000e+02, float -1.720000e+02, float 5.200000e+02, float 7.190000e+02] }, %struct.anon.62 { [4 x float] [float -2.615000e+02, float -1.890000e+02, float -5.425000e+02, float 3.370000e+02], [4 x float] [float -2.610000e+02, float -1.890000e+02, float -5.420000e+02, float 3.370000e+02] }, %struct.anon.62 { [4 x float] [float -1.865000e+02, float 7.205000e+02, float 3.650000e+01, float 1.505000e+02], [4 x float] [float -1.860000e+02, float 7.210000e+02, float 3.700000e+01, float 1.510000e+02] }], align 16
@test_simde_mm_round_ps_zero.test_vec = internal constant [8 x %struct.anon.63] [%struct.anon.63 { [4 x float] [float -7.325000e+02, float 2.555000e+02, float -8.650000e+02, float 2.725000e+02], [4 x float] [float -7.320000e+02, float 2.550000e+02, float -8.650000e+02, float 2.720000e+02] }, %struct.anon.63 { [4 x float] [float 8.505000e+02, float 5.065000e+02, float 2.155000e+02, float 0xC06DB147A0000000], [4 x float] [float 8.500000e+02, float 5.060000e+02, float 2.150000e+02, float -2.370000e+02] }, %struct.anon.63 { [4 x float] [float 0x40824C2900000000, float 7.505000e+02, float 2.845000e+02, float 5.515000e+02], [4 x float] [float 5.850000e+02, float 7.500000e+02, float 2.840000e+02, float 5.510000e+02] }, %struct.anon.63 { [4 x float] [float -1.915000e+02, float -5.750000e+01, float -7.855000e+02, float -9.345000e+02], [4 x float] [float -1.910000e+02, float -5.700000e+01, float -7.850000e+02, float -9.340000e+02] }, %struct.anon.63 { [4 x float] [float 5.715000e+02, float -2.125000e+02, float 5.485000e+02, float 2.055000e+02], [4 x float] [float 5.710000e+02, float -2.120000e+02, float 5.480000e+02, float 2.050000e+02] }, %struct.anon.63 { [4 x float] [float 6.465000e+02, float -5.435000e+02, float 7.935000e+02, float 9.265000e+02], [4 x float] [float 6.460000e+02, float -5.430000e+02, float 7.930000e+02, float 9.260000e+02] }, %struct.anon.63 { [4 x float] [float -5.515000e+02, float -7.905000e+02, float 1.740000e+02, float 2.305000e+02], [4 x float] [float -5.510000e+02, float -7.900000e+02, float 1.740000e+02, float 2.300000e+02] }, %struct.anon.63 { [4 x float] [float 7.255000e+02, float 8.055000e+02, float -6.650000e+02, float -3.705000e+02], [4 x float] [float 7.250000e+02, float 8.050000e+02, float -6.650000e+02, float -3.700000e+02] }], align 16

; Function Attrs: nounwind uwtable
define dso_local i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %retval1 = alloca i32, align 4
  %i = alloca i64, align 8
  %res = alloca i32, align 4
  store i32 0, ptr %retval, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %retval1) #10
  store i32 0, ptr %retval1, align 4, !tbaa !5
  %0 = load ptr, ptr @stdout, align 8, !tbaa !9
  %call = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %0, ptr noundef @.str, i64 noundef 69)
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %1, 69
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  br label %for.end

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 4, ptr %res) #10
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [69 x %struct.anon], ptr @test_suite_tests, i64 0, i64 %2
  %func = getelementptr inbounds %struct.anon, ptr %arrayidx, i32 0, i32 0
  %3 = load ptr, ptr %func, align 16, !tbaa !13
  %call2 = call i32 %3()
  store i32 %call2, ptr %res, align 4, !tbaa !5
  %4 = load i32, ptr %res, align 4, !tbaa !5
  %cmp3 = icmp ne i32 %4, 0
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  store i32 1, ptr %retval1, align 4, !tbaa !5
  %5 = load ptr, ptr @stdout, align 8, !tbaa !9
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %add = add i64 %6, 1
  %7 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx4 = getelementptr inbounds [69 x %struct.anon], ptr @test_suite_tests, i64 0, i64 %7
  %name = getelementptr inbounds %struct.anon, ptr %arrayidx4, i32 0, i32 1
  %8 = load ptr, ptr %name, align 8, !tbaa !15
  %call5 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %5, ptr noundef @.str.1, i64 noundef %add, ptr noundef %8)
  br label %if.end

if.else:                                          ; preds = %for.body
  %9 = load ptr, ptr @stdout, align 8, !tbaa !9
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %add6 = add i64 %10, 1
  %11 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx7 = getelementptr inbounds [69 x %struct.anon], ptr @test_suite_tests, i64 0, i64 %11
  %name8 = getelementptr inbounds %struct.anon, ptr %arrayidx7, i32 0, i32 1
  %12 = load ptr, ptr %name8, align 8, !tbaa !15
  %call9 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %9, ptr noundef @.str.2, i64 noundef %add6, ptr noundef %12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %res) #10
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %13 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %13, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.end:                                          ; preds = %for.cond.cleanup
  %14 = load i32, ptr %retval1, align 4, !tbaa !5
  call void @llvm.lifetime.end.p0(i64 4, ptr %retval1) #10
  ret i32 %14
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

declare i32 @fprintf(ptr noundef, ptr noundef, ...) #2

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_blend_epi16() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.0], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <2 x i64>, align 16
  %simde_mm_blend_epi16_a_ = alloca %union.simde__m128i_private, align 16
  %simde_mm_blend_epi16_b_ = alloca %union.simde__m128i_private, align 16
  %simde_mm_blend_epi16_r_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.0], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.0, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 13825, i16 noundef signext -17802, i16 noundef signext -1598, i16 noundef signext 25326, i16 noundef signext 14943, i16 noundef signext -8227, i16 noundef signext 21745, i16 noundef signext 9989)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.0, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -11058, i16 noundef signext 4192, i16 noundef signext -28252, i16 noundef signext 10795, i16 noundef signext 19700, i16 noundef signext 29704, i16 noundef signext -7052, i16 noundef signext 16432)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.0, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 13825, i16 noundef signext -17802, i16 noundef signext -1598, i16 noundef signext 25326, i16 noundef signext 14943, i16 noundef signext -8227, i16 noundef signext -7052, i16 noundef signext 16432)
  store <2 x i64> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.0, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -17914, i16 noundef signext -32103, i16 noundef signext 17164, i16 noundef signext -187, i16 noundef signext 21942, i16 noundef signext -25306, i16 noundef signext -7849, i16 noundef signext -11297)
  store <2 x i64> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -9027, i16 noundef signext -14363, i16 noundef signext 16126, i16 noundef signext 30921, i16 noundef signext 3730, i16 noundef signext -20492, i16 noundef signext -5510, i16 noundef signext 32723)
  store <2 x i64> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -17914, i16 noundef signext -32103, i16 noundef signext 17164, i16 noundef signext -187, i16 noundef signext 21942, i16 noundef signext -25306, i16 noundef signext -5510, i16 noundef signext 32723)
  store <2 x i64> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -25152, i16 noundef signext 30665, i16 noundef signext 26270, i16 noundef signext 23820, i16 noundef signext -24322, i16 noundef signext 706, i16 noundef signext -26336, i16 noundef signext -13296)
  store <2 x i64> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -24671, i16 noundef signext -19680, i16 noundef signext 10653, i16 noundef signext -9500, i16 noundef signext -16899, i16 noundef signext 495, i16 noundef signext 26780, i16 noundef signext -11315)
  store <2 x i64> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -25152, i16 noundef signext 30665, i16 noundef signext 26270, i16 noundef signext 23820, i16 noundef signext -24322, i16 noundef signext 706, i16 noundef signext 26780, i16 noundef signext -11315)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 20562, i16 noundef signext -19834, i16 noundef signext 5180, i16 noundef signext -5117, i16 noundef signext 16168, i16 noundef signext 23520, i16 noundef signext -16838, i16 noundef signext 28892)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 2860, i16 noundef signext -6670, i16 noundef signext -25365, i16 noundef signext -4954, i16 noundef signext 30912, i16 noundef signext 6045, i16 noundef signext 2749, i16 noundef signext 4401)
  store <2 x i64> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 20562, i16 noundef signext -19834, i16 noundef signext 5180, i16 noundef signext -5117, i16 noundef signext 16168, i16 noundef signext 23520, i16 noundef signext 2749, i16 noundef signext 4401)
  store <2 x i64> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 25997, i16 noundef signext -1860, i16 noundef signext -9126, i16 noundef signext 12214, i16 noundef signext 7159, i16 noundef signext -2303, i16 noundef signext 7182, i16 noundef signext -20779)
  store <2 x i64> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -7432, i16 noundef signext 954, i16 noundef signext -26453, i16 noundef signext -2062, i16 noundef signext 14984, i16 noundef signext -7563, i16 noundef signext 13369, i16 noundef signext -4134)
  store <2 x i64> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 25997, i16 noundef signext -1860, i16 noundef signext -9126, i16 noundef signext 12214, i16 noundef signext 7159, i16 noundef signext -2303, i16 noundef signext 13369, i16 noundef signext -4134)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -6104, i16 noundef signext -18564, i16 noundef signext 5298, i16 noundef signext -6001, i16 noundef signext -6122, i16 noundef signext 14804, i16 noundef signext -32440, i16 noundef signext -10960)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 8197, i16 noundef signext 14220, i16 noundef signext -10924, i16 noundef signext 17196, i16 noundef signext 21768, i16 noundef signext 7639, i16 noundef signext -4935, i16 noundef signext -993)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -6104, i16 noundef signext -18564, i16 noundef signext 5298, i16 noundef signext -6001, i16 noundef signext -6122, i16 noundef signext 14804, i16 noundef signext -4935, i16 noundef signext -993)
  store <2 x i64> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 6003, i16 noundef signext -5880, i16 noundef signext 31967, i16 noundef signext -28984, i16 noundef signext -9503, i16 noundef signext 30320, i16 noundef signext -19146, i16 noundef signext 32146)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 4317, i16 noundef signext 22644, i16 noundef signext -25807, i16 noundef signext -30524, i16 noundef signext 223, i16 noundef signext -7098, i16 noundef signext 9867, i16 noundef signext -9190)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 6003, i16 noundef signext -5880, i16 noundef signext 31967, i16 noundef signext -28984, i16 noundef signext -9503, i16 noundef signext 30320, i16 noundef signext 9867, i16 noundef signext -9190)
  store <2 x i64> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 12033, i16 noundef signext 14639, i16 noundef signext 28420, i16 noundef signext 14334, i16 noundef signext -3029, i16 noundef signext -20328, i16 noundef signext 8988, i16 noundef signext 23547)
  store <2 x i64> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 9966, i16 noundef signext -21867, i16 noundef signext 738, i16 noundef signext -29688, i16 noundef signext 9349, i16 noundef signext 2360, i16 noundef signext -12771, i16 noundef signext -15402)
  store <2 x i64> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.0, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 12033, i16 noundef signext 14639, i16 noundef signext 28420, i16 noundef signext 14334, i16 noundef signext -3029, i16 noundef signext -20328, i16 noundef signext -12771, i16 noundef signext -15402)
  store <2 x i64> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup62

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %simde_mm_blend_epi16_a_) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.0], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.0, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a52, align 16, !tbaa !16
  %call53 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %2)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %simde_mm_blend_epi16_a_, i32 0, i32 0
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %4 = extractvalue { double, double } %call53, 0
  store double %4, ptr %3, align 16
  %5 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %6 = extractvalue { double, double } %call53, 1
  store double %6, ptr %5, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %simde_mm_blend_epi16_b_) #10
  %7 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx54 = getelementptr inbounds [8 x %struct.anon.0], ptr %test_vec, i64 0, i64 %7
  %b55 = getelementptr inbounds %struct.anon.0, ptr %arrayidx54, i32 0, i32 1
  %8 = load <2 x i64>, ptr %b55, align 16, !tbaa !16
  %call56 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %8)
  %coerce.dive57 = getelementptr inbounds %union.simde__m128i_private, ptr %simde_mm_blend_epi16_b_, i32 0, i32 0
  %9 = getelementptr inbounds { double, double }, ptr %coerce.dive57, i32 0, i32 0
  %10 = extractvalue { double, double } %call56, 0
  store double %10, ptr %9, align 16
  %11 = getelementptr inbounds { double, double }, ptr %coerce.dive57, i32 0, i32 1
  %12 = extractvalue { double, double } %call56, 1
  store double %12, ptr %11, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %simde_mm_blend_epi16_r_) #10
  %13 = load <8 x i16>, ptr %simde_mm_blend_epi16_a_, align 16, !tbaa !16
  %14 = load <8 x i16>, ptr %simde_mm_blend_epi16_b_, align 16, !tbaa !16
  %shuffle = shufflevector <8 x i16> %13, <8 x i16> %14, <8 x i32> <i32 8, i32 9, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  store <8 x i16> %shuffle, ptr %simde_mm_blend_epi16_r_, align 16, !tbaa !16
  %15 = getelementptr inbounds { double, double }, ptr %simde_mm_blend_epi16_r_, i32 0, i32 0
  %16 = load double, ptr %15, align 16
  %17 = getelementptr inbounds { double, double }, ptr %simde_mm_blend_epi16_r_, i32 0, i32 1
  %18 = load double, ptr %17, align 8
  %call58 = call <2 x i64> @simde__m128i_from_private(double %16, double %18)
  store <2 x i64> %call58, ptr %tmp, align 16, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 16, ptr %simde_mm_blend_epi16_r_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %simde_mm_blend_epi16_b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %simde_mm_blend_epi16_a_) #10
  %19 = load <2 x i64>, ptr %tmp, align 16, !tbaa !16
  store <2 x i64> %19, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %20 = load <2 x i64>, ptr %r51, align 16, !tbaa !16
  %21 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx59 = getelementptr inbounds [8 x %struct.anon.0], ptr %test_vec, i64 0, i64 %21
  %r60 = getelementptr inbounds %struct.anon.0, ptr %arrayidx59, i32 0, i32 2
  %22 = load <2 x i64>, ptr %r60, align 16, !tbaa !16
  %call61 = call i32 @simde_test_x86_assert_equal_i16x8_(<2 x i64> noundef %20, <2 x i64> noundef %22, ptr noundef @.str.72, i32 noundef 415, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call61, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup62 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %23 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %23, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup62:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest63 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest63, label %cleanup64 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup62
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup64

cleanup64:                                        ; preds = %for.end, %cleanup62
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %24 = load i32, ptr %retval, align 4
  ret i32 %24
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_blend_pd() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.1], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <2 x double>, align 16
  %simde_mm_blend_pd_a_ = alloca %union.simde__m128d_private, align 16
  %simde_mm_blend_pd_b_ = alloca %union.simde__m128d_private, align 16
  %simde_mm_blend_pd_r_ = alloca %union.simde__m128d_private, align 16
  %tmp = alloca <2 x double>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.1], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.1, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x double> @simde_mm_set_pd(double noundef 3.070900e+02, double noundef 0xC08EFF70A3D70A3D)
  store <2 x double> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.1, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x double> @simde_mm_set_pd(double noundef -2.529200e+02, double noundef -5.661000e+01)
  store <2 x double> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.1, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x double> @simde_mm_set_pd(double noundef 3.070900e+02, double noundef -5.661000e+01)
  store <2 x double> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.1, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x double> @simde_mm_set_pd(double noundef 2.632500e+02, double noundef 0x4082055C28F5C28F)
  store <2 x double> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x double> @simde_mm_set_pd(double noundef -3.984700e+02, double noundef -8.450000e+02)
  store <2 x double> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <2 x double> @simde_mm_set_pd(double noundef 2.632500e+02, double noundef -8.450000e+02)
  store <2 x double> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <2 x double> @simde_mm_set_pd(double noundef -1.562100e+02, double noundef 8.059800e+02)
  store <2 x double> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <2 x double> @simde_mm_set_pd(double noundef -7.123200e+02, double noundef -5.578500e+02)
  store <2 x double> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <2 x double> @simde_mm_set_pd(double noundef -1.562100e+02, double noundef -5.578500e+02)
  store <2 x double> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x double> @simde_mm_set_pd(double noundef 1.917800e+02, double noundef -3.096100e+02)
  store <2 x double> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x double> @simde_mm_set_pd(double noundef -9.978200e+02, double noundef -4.935800e+02)
  store <2 x double> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <2 x double> @simde_mm_set_pd(double noundef 1.917800e+02, double noundef -4.935800e+02)
  store <2 x double> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <2 x double> @simde_mm_set_pd(double noundef -9.335800e+02, double noundef -4.863600e+02)
  store <2 x double> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <2 x double> @simde_mm_set_pd(double noundef 0x408B855C28F5C28F, double noundef 7.911000e+02)
  store <2 x double> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <2 x double> @simde_mm_set_pd(double noundef -9.335800e+02, double noundef 7.911000e+02)
  store <2 x double> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x double> @simde_mm_set_pd(double noundef 4.545000e+01, double noundef -4.363800e+02)
  store <2 x double> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x double> @simde_mm_set_pd(double noundef 2.118200e+02, double noundef 6.539800e+02)
  store <2 x double> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x double> @simde_mm_set_pd(double noundef 4.545000e+01, double noundef 6.539800e+02)
  store <2 x double> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x double> @simde_mm_set_pd(double noundef 0x408C9C147AE147AE, double noundef -4.454300e+02)
  store <2 x double> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x double> @simde_mm_set_pd(double noundef -6.914000e+01, double noundef -3.458200e+02)
  store <2 x double> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <2 x double> @simde_mm_set_pd(double noundef 0x408C9C147AE147AE, double noundef -3.458200e+02)
  store <2 x double> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <2 x double> @simde_mm_set_pd(double noundef -6.032100e+02, double noundef -1.826900e+02)
  store <2 x double> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <2 x double> @simde_mm_set_pd(double noundef -4.634500e+02, double noundef 9.292100e+02)
  store <2 x double> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.1, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <2 x double> @simde_mm_set_pd(double noundef -6.032100e+02, double noundef 9.292100e+02)
  store <2 x double> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup63

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %simde_mm_blend_pd_a_) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.1], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.1, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x double>, ptr %a52, align 16, !tbaa !16
  %call53 = call { double, double } @simde__m128d_to_private(<2 x double> noundef %2)
  %coerce.dive = getelementptr inbounds %union.simde__m128d_private, ptr %simde_mm_blend_pd_a_, i32 0, i32 0
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %4 = extractvalue { double, double } %call53, 0
  store double %4, ptr %3, align 16
  %5 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %6 = extractvalue { double, double } %call53, 1
  store double %6, ptr %5, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %simde_mm_blend_pd_b_) #10
  %7 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx54 = getelementptr inbounds [8 x %struct.anon.1], ptr %test_vec, i64 0, i64 %7
  %b55 = getelementptr inbounds %struct.anon.1, ptr %arrayidx54, i32 0, i32 1
  %8 = load <2 x double>, ptr %b55, align 16, !tbaa !16
  %call56 = call { double, double } @simde__m128d_to_private(<2 x double> noundef %8)
  %coerce.dive57 = getelementptr inbounds %union.simde__m128d_private, ptr %simde_mm_blend_pd_b_, i32 0, i32 0
  %9 = getelementptr inbounds { double, double }, ptr %coerce.dive57, i32 0, i32 0
  %10 = extractvalue { double, double } %call56, 0
  store double %10, ptr %9, align 16
  %11 = getelementptr inbounds { double, double }, ptr %coerce.dive57, i32 0, i32 1
  %12 = extractvalue { double, double } %call56, 1
  store double %12, ptr %11, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %simde_mm_blend_pd_r_) #10
  %13 = load <2 x double>, ptr %simde_mm_blend_pd_a_, align 16, !tbaa !16
  %14 = load <2 x double>, ptr %simde_mm_blend_pd_b_, align 16, !tbaa !16
  %shuffle = shufflevector <2 x double> %13, <2 x double> %14, <2 x i32> <i32 2, i32 1>
  store <2 x double> %shuffle, ptr %simde_mm_blend_pd_r_, align 16, !tbaa !16
  %15 = getelementptr inbounds { double, double }, ptr %simde_mm_blend_pd_r_, i32 0, i32 0
  %16 = load double, ptr %15, align 16
  %17 = getelementptr inbounds { double, double }, ptr %simde_mm_blend_pd_r_, i32 0, i32 1
  %18 = load double, ptr %17, align 8
  %call58 = call <2 x double> @simde__m128d_from_private(double %16, double %18)
  store <2 x double> %call58, ptr %tmp, align 16, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 16, ptr %simde_mm_blend_pd_r_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %simde_mm_blend_pd_b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %simde_mm_blend_pd_a_) #10
  %19 = load <2 x double>, ptr %tmp, align 16, !tbaa !16
  store <2 x double> %19, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %20 = load <2 x double>, ptr %r51, align 16, !tbaa !16
  %21 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx59 = getelementptr inbounds [8 x %struct.anon.1], ptr %test_vec, i64 0, i64 %21
  %r60 = getelementptr inbounds %struct.anon.1, ptr %arrayidx59, i32 0, i32 2
  %22 = load <2 x double>, ptr %r60, align 16, !tbaa !16
  %call61 = call double @simde_test_f64_precision_to_slop(i32 noundef 1)
  %call62 = call i32 @simde_test_x86_assert_equal_f64x2_(<2 x double> noundef %20, <2 x double> noundef %22, double noundef %call61, ptr noundef @.str.72, i32 noundef 456, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call62, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup63 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %23 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %23, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup63:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest64 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest64, label %cleanup65 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup63
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup65

cleanup65:                                        ; preds = %for.end, %cleanup63
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %24 = load i32, ptr %retval, align 4
  ret i32 %24
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_blend_ps() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.2], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <4 x float>, align 16
  %simde_mm_blend_ps_a_ = alloca %union.simde__m128_private, align 16
  %simde_mm_blend_ps_b_ = alloca %union.simde__m128_private, align 16
  %simde_mm_blend_ps_r_ = alloca %union.simde__m128_private, align 16
  %tmp = alloca <4 x float>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.2], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.2, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <4 x float> @simde_mm_set_ps(float noundef 2.632500e+02, float noundef 0x4082055C20000000, float noundef 0x40733170A0000000, float noundef 0xC08EFF70A0000000)
  store <4 x float> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.2, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <4 x float> @simde_mm_set_ps(float noundef 0xC078E78520000000, float noundef -8.450000e+02, float noundef 0xC06F9D70A0000000, float noundef 0xC04C4E1480000000)
  store <4 x float> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.2, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <4 x float> @simde_mm_set_ps(float noundef 2.632500e+02, float noundef 0x4082055C20000000, float noundef 0xC06F9D70A0000000, float noundef 0xC08EFF70A0000000)
  store <4 x float> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.2, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <4 x float> @simde_mm_set_ps(float noundef 0x4067F8F5C0000000, float noundef 0xC07359C280000000, float noundef 0xC06386B860000000, float noundef 0x40892FD700000000)
  store <4 x float> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <4 x float> @simde_mm_set_ps(float noundef 0xC08F2E8F60000000, float noundef 0xC07ED947A0000000, float noundef 0xC086428F60000000, float noundef 0xC0816ECCC0000000)
  store <4 x float> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <4 x float> @simde_mm_set_ps(float noundef 0x4067F8F5C0000000, float noundef 0xC07359C280000000, float noundef 0xC086428F60000000, float noundef 0x40892FD700000000)
  store <4 x float> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <4 x float> @simde_mm_set_ps(float noundef 0x4046B999A0000000, float noundef 0xC07B461480000000, float noundef 0xC08D2CA3E0000000, float noundef 0xC07E65C280000000)
  store <4 x float> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <4 x float> @simde_mm_set_ps(float noundef 0x406A7A3D80000000, float noundef 0x40846FD700000000, float noundef 0x408B855C20000000, float noundef 0x4088B8CCC0000000)
  store <4 x float> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <4 x float> @simde_mm_set_ps(float noundef 0x4046B999A0000000, float noundef 0xC07B461480000000, float noundef 0x408B855C20000000, float noundef 0xC07E65C280000000)
  store <4 x float> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <4 x float> @simde_mm_set_ps(float noundef 0xC082D9AE20000000, float noundef 0xC066D61480000000, float noundef 0x408C9C1480000000, float noundef 0xC07BD6E140000000)
  store <4 x float> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <4 x float> @simde_mm_set_ps(float noundef 0xC07CF73340000000, float noundef 0x408D09AE20000000, float noundef 0xC05148F5C0000000, float noundef 0xC0759D1EC0000000)
  store <4 x float> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <4 x float> @simde_mm_set_ps(float noundef 0xC082D9AE20000000, float noundef 0xC066D61480000000, float noundef 0xC05148F5C0000000, float noundef 0xC07BD6E140000000)
  store <4 x float> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <4 x float> @simde_mm_set_ps(float noundef 0x408C171EC0000000, float noundef 0xC052EC2900000000, float noundef 0x4078CF0A40000000, float noundef 0xC08DF98520000000)
  store <4 x float> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <4 x float> @simde_mm_set_ps(float noundef 0xC07A39EB80000000, float noundef 0xC072B547A0000000, float noundef 0xC06268F5C0000000, float noundef -4.587500e+02)
  store <4 x float> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <4 x float> @simde_mm_set_ps(float noundef 0x408C171EC0000000, float noundef 0xC052EC2900000000, float noundef 0xC06268F5C0000000, float noundef 0xC08DF98520000000)
  store <4 x float> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <4 x float> @simde_mm_set_ps(float noundef 0x407E0F8520000000, float noundef 0x4073CF8520000000, float noundef 0xC085E5EB80000000, float noundef 0xC054566660000000)
  store <4 x float> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <4 x float> @simde_mm_set_ps(float noundef 0xC08D10A3E0000000, float noundef 0x404D651EC0000000, float noundef 0xC086CEB860000000, float noundef 0x4081E27AE0000000)
  store <4 x float> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <4 x float> @simde_mm_set_ps(float noundef 0x407E0F8520000000, float noundef 0x4073CF8520000000, float noundef 0xC086CEB860000000, float noundef 0xC054566660000000)
  store <4 x float> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <4 x float> @simde_mm_set_ps(float noundef 0xC049C3D700000000, float noundef 0x4087326660000000, float noundef 0x407B8EE140000000, float noundef 0xC08BA9EB80000000)
  store <4 x float> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <4 x float> @simde_mm_set_ps(float noundef 0x408B9B0A40000000, float noundef 0xC073AF0A40000000, float noundef 0xC0892A1480000000, float noundef 0x408A595C20000000)
  store <4 x float> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <4 x float> @simde_mm_set_ps(float noundef 0xC049C3D700000000, float noundef 0x4087326660000000, float noundef 0xC0892A1480000000, float noundef 0xC08BA9EB80000000)
  store <4 x float> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <4 x float> @simde_mm_set_ps(float noundef 0x408961D700000000, float noundef 0xC074F5EB80000000, float noundef 0x40771EB860000000, float noundef 0xC061261480000000)
  store <4 x float> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <4 x float> @simde_mm_set_ps(float noundef 0x405DF8F5C0000000, float noundef 0x408C2CF5C0000000, float noundef 0xC06D44CCC0000000, float noundef 0x407EEDC280000000)
  store <4 x float> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.2, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <4 x float> @simde_mm_set_ps(float noundef 0x408961D700000000, float noundef 0xC074F5EB80000000, float noundef 0xC06D44CCC0000000, float noundef 0xC061261480000000)
  store <4 x float> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup63

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %simde_mm_blend_ps_a_) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.2], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.2, ptr %arrayidx, i32 0, i32 0
  %2 = load <4 x float>, ptr %a52, align 16, !tbaa !16
  %call53 = call { double, double } @simde__m128_to_private(<4 x float> noundef %2)
  %coerce.dive = getelementptr inbounds %union.simde__m128_private, ptr %simde_mm_blend_ps_a_, i32 0, i32 0
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %4 = extractvalue { double, double } %call53, 0
  store double %4, ptr %3, align 16
  %5 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %6 = extractvalue { double, double } %call53, 1
  store double %6, ptr %5, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %simde_mm_blend_ps_b_) #10
  %7 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx54 = getelementptr inbounds [8 x %struct.anon.2], ptr %test_vec, i64 0, i64 %7
  %b55 = getelementptr inbounds %struct.anon.2, ptr %arrayidx54, i32 0, i32 1
  %8 = load <4 x float>, ptr %b55, align 16, !tbaa !16
  %call56 = call { double, double } @simde__m128_to_private(<4 x float> noundef %8)
  %coerce.dive57 = getelementptr inbounds %union.simde__m128_private, ptr %simde_mm_blend_ps_b_, i32 0, i32 0
  %9 = getelementptr inbounds { double, double }, ptr %coerce.dive57, i32 0, i32 0
  %10 = extractvalue { double, double } %call56, 0
  store double %10, ptr %9, align 16
  %11 = getelementptr inbounds { double, double }, ptr %coerce.dive57, i32 0, i32 1
  %12 = extractvalue { double, double } %call56, 1
  store double %12, ptr %11, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %simde_mm_blend_ps_r_) #10
  %13 = load <4 x float>, ptr %simde_mm_blend_ps_a_, align 16, !tbaa !16
  %14 = load <4 x float>, ptr %simde_mm_blend_ps_b_, align 16, !tbaa !16
  %shuffle = shufflevector <4 x float> %13, <4 x float> %14, <4 x i32> <i32 0, i32 5, i32 2, i32 3>
  store <4 x float> %shuffle, ptr %simde_mm_blend_ps_r_, align 16, !tbaa !16
  %15 = getelementptr inbounds { double, double }, ptr %simde_mm_blend_ps_r_, i32 0, i32 0
  %16 = load double, ptr %15, align 16
  %17 = getelementptr inbounds { double, double }, ptr %simde_mm_blend_ps_r_, i32 0, i32 1
  %18 = load double, ptr %17, align 8
  %call58 = call <4 x float> @simde__m128_from_private(double %16, double %18)
  store <4 x float> %call58, ptr %tmp, align 16, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 16, ptr %simde_mm_blend_ps_r_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %simde_mm_blend_ps_b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %simde_mm_blend_ps_a_) #10
  %19 = load <4 x float>, ptr %tmp, align 16, !tbaa !16
  store <4 x float> %19, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %20 = load <4 x float>, ptr %r51, align 16, !tbaa !16
  %21 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx59 = getelementptr inbounds [8 x %struct.anon.2], ptr %test_vec, i64 0, i64 %21
  %r60 = getelementptr inbounds %struct.anon.2, ptr %arrayidx59, i32 0, i32 2
  %22 = load <4 x float>, ptr %r60, align 16, !tbaa !16
  %call61 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call62 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %20, <4 x float> noundef %22, float noundef %call61, ptr noundef @.str.72, i32 noundef 497, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call62, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup63 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %23 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %23, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup63:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest64 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest64, label %cleanup65 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup63
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup65

cleanup65:                                        ; preds = %for.end, %cleanup63
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %24 = load i32, ptr %retval, align 4
  ret i32 %24
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_blendv_epi8() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.3], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r66 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 512, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.3], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.3, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -85, i8 noundef signext -39, i8 noundef signext -107, i8 noundef signext -76, i8 noundef signext -25, i8 noundef signext -32, i8 noundef signext -50, i8 noundef signext -115, i8 noundef signext -54, i8 noundef signext -26, i8 noundef signext 56, i8 noundef signext 16, i8 noundef signext -17, i8 noundef signext 98, i8 noundef signext -10, i8 noundef signext -86)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.3, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 111, i8 noundef signext -17, i8 noundef signext 70, i8 noundef signext -98, i8 noundef signext 38, i8 noundef signext 75, i8 noundef signext 17, i8 noundef signext -50, i8 noundef signext -64, i8 noundef signext 25, i8 noundef signext -4, i8 noundef signext 42, i8 noundef signext 13, i8 noundef signext 109, i8 noundef signext 122, i8 noundef signext -104)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %mask = getelementptr inbounds %struct.anon.3, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -13, i8 noundef signext 21, i8 noundef signext 111, i8 noundef signext -8, i8 noundef signext 32, i8 noundef signext -14, i8 noundef signext 25, i8 noundef signext 45, i8 noundef signext 34, i8 noundef signext -43, i8 noundef signext -81, i8 noundef signext 26, i8 noundef signext -105, i8 noundef signext 63, i8 noundef signext -61, i8 noundef signext -38)
  store <2 x i64> %call2, ptr %mask, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.3, ptr %arrayinit.begin, i32 0, i32 3
  %call3 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 111, i8 noundef signext -39, i8 noundef signext -107, i8 noundef signext -98, i8 noundef signext -25, i8 noundef signext 75, i8 noundef signext -50, i8 noundef signext -115, i8 noundef signext -54, i8 noundef signext 25, i8 noundef signext -4, i8 noundef signext 16, i8 noundef signext 13, i8 noundef signext 98, i8 noundef signext 122, i8 noundef signext -104)
  store <2 x i64> %call3, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.3, ptr %arrayinit.begin, i64 1
  %a4 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element, i32 0, i32 0
  %call5 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -79, i8 noundef signext 12, i8 noundef signext 105, i8 noundef signext -95, i8 noundef signext -27, i8 noundef signext 97, i8 noundef signext 123, i8 noundef signext -2, i8 noundef signext -75, i8 noundef signext -82, i8 noundef signext -63, i8 noundef signext 121, i8 noundef signext 39, i8 noundef signext -40, i8 noundef signext -103, i8 noundef signext -72)
  store <2 x i64> %call5, ptr %a4, align 16, !tbaa !16
  %b6 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element, i32 0, i32 1
  %call7 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -77, i8 noundef signext -58, i8 noundef signext -15, i8 noundef signext -99, i8 noundef signext -120, i8 noundef signext 124, i8 noundef signext 40, i8 noundef signext 82, i8 noundef signext 121, i8 noundef signext 50, i8 noundef signext -103, i8 noundef signext -45, i8 noundef signext -125, i8 noundef signext -55, i8 noundef signext -57, i8 noundef signext -95)
  store <2 x i64> %call7, ptr %b6, align 16, !tbaa !16
  %mask8 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element, i32 0, i32 2
  %call9 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -97, i8 noundef signext -10, i8 noundef signext 107, i8 noundef signext 95, i8 noundef signext 99, i8 noundef signext -103, i8 noundef signext 112, i8 noundef signext -80, i8 noundef signext -21, i8 noundef signext 52, i8 noundef signext -128, i8 noundef signext 9, i8 noundef signext 47, i8 noundef signext -45, i8 noundef signext -98, i8 noundef signext 67)
  store <2 x i64> %call9, ptr %mask8, align 16, !tbaa !16
  %r10 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element, i32 0, i32 3
  %call11 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -77, i8 noundef signext -58, i8 noundef signext 105, i8 noundef signext -95, i8 noundef signext -27, i8 noundef signext 124, i8 noundef signext 123, i8 noundef signext 82, i8 noundef signext 121, i8 noundef signext -82, i8 noundef signext -103, i8 noundef signext 121, i8 noundef signext 39, i8 noundef signext -55, i8 noundef signext -57, i8 noundef signext -72)
  store <2 x i64> %call11, ptr %r10, align 16, !tbaa !16
  %arrayinit.element12 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element, i64 1
  %a13 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element12, i32 0, i32 0
  %call14 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 65, i8 noundef signext 33, i8 noundef signext -24, i8 noundef signext -68, i8 noundef signext -81, i8 noundef signext 103, i8 noundef signext -77, i8 noundef signext -49, i8 noundef signext 99, i8 noundef signext 55, i8 noundef signext 98, i8 noundef signext 36, i8 noundef signext 31, i8 noundef signext 86, i8 noundef signext -79, i8 noundef signext 106)
  store <2 x i64> %call14, ptr %a13, align 16, !tbaa !16
  %b15 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element12, i32 0, i32 1
  %call16 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 101, i8 noundef signext 91, i8 noundef signext -24, i8 noundef signext 33, i8 noundef signext -68, i8 noundef signext -109, i8 noundef signext -92, i8 noundef signext -49, i8 noundef signext -88, i8 noundef signext 86, i8 noundef signext 106, i8 noundef signext 125, i8 noundef signext 81, i8 noundef signext -60, i8 noundef signext -32, i8 noundef signext 38)
  store <2 x i64> %call16, ptr %b15, align 16, !tbaa !16
  %mask17 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element12, i32 0, i32 2
  %call18 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 3, i8 noundef signext 58, i8 noundef signext 40, i8 noundef signext 64, i8 noundef signext 7, i8 noundef signext -123, i8 noundef signext 47, i8 noundef signext 24, i8 noundef signext -14, i8 noundef signext 119, i8 noundef signext 8, i8 noundef signext 126, i8 noundef signext 123, i8 noundef signext 25, i8 noundef signext 42, i8 noundef signext -118)
  store <2 x i64> %call18, ptr %mask17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element12, i32 0, i32 3
  %call20 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 65, i8 noundef signext 33, i8 noundef signext -24, i8 noundef signext -68, i8 noundef signext -81, i8 noundef signext -109, i8 noundef signext -77, i8 noundef signext -49, i8 noundef signext -88, i8 noundef signext 55, i8 noundef signext 98, i8 noundef signext 36, i8 noundef signext 31, i8 noundef signext 86, i8 noundef signext -79, i8 noundef signext 38)
  store <2 x i64> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element12, i64 1
  %a22 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 34, i8 noundef signext -102, i8 noundef signext 26, i8 noundef signext 6, i8 noundef signext -98, i8 noundef signext -126, i8 noundef signext 34, i8 noundef signext 109, i8 noundef signext -65, i8 noundef signext -47, i8 noundef signext 54, i8 noundef signext -102, i8 noundef signext 52, i8 noundef signext 72, i8 noundef signext 95, i8 noundef signext -117)
  store <2 x i64> %call23, ptr %a22, align 16, !tbaa !16
  %b24 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -47, i8 noundef signext 2, i8 noundef signext 12, i8 noundef signext -2, i8 noundef signext 113, i8 noundef signext 15, i8 noundef signext -36, i8 noundef signext 63, i8 noundef signext 39, i8 noundef signext 47, i8 noundef signext -65, i8 noundef signext 45, i8 noundef signext -99, i8 noundef signext 91, i8 noundef signext -116, i8 noundef signext 94)
  store <2 x i64> %call25, ptr %b24, align 16, !tbaa !16
  %mask26 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element21, i32 0, i32 2
  %call27 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -98, i8 noundef signext 39, i8 noundef signext 27, i8 noundef signext -110, i8 noundef signext -56, i8 noundef signext 121, i8 noundef signext 15, i8 noundef signext 100, i8 noundef signext 94, i8 noundef signext 8, i8 noundef signext -121, i8 noundef signext 116, i8 noundef signext 47, i8 noundef signext -128, i8 noundef signext 82, i8 noundef signext 52)
  store <2 x i64> %call27, ptr %mask26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element21, i32 0, i32 3
  %call29 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -47, i8 noundef signext -102, i8 noundef signext 26, i8 noundef signext -2, i8 noundef signext 113, i8 noundef signext -126, i8 noundef signext 34, i8 noundef signext 109, i8 noundef signext -65, i8 noundef signext -47, i8 noundef signext -65, i8 noundef signext -102, i8 noundef signext 52, i8 noundef signext 91, i8 noundef signext 95, i8 noundef signext -117)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element21, i64 1
  %a31 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 114, i8 noundef signext -111, i8 noundef signext -9, i8 noundef signext -74, i8 noundef signext 56, i8 noundef signext -88, i8 noundef signext 102, i8 noundef signext 9, i8 noundef signext 123, i8 noundef signext -124, i8 noundef signext 2, i8 noundef signext -90, i8 noundef signext -87, i8 noundef signext -122, i8 noundef signext -39, i8 noundef signext -114)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -81, i8 noundef signext -26, i8 noundef signext 59, i8 noundef signext 3, i8 noundef signext 113, i8 noundef signext -96, i8 noundef signext -108, i8 noundef signext 77, i8 noundef signext -17, i8 noundef signext 59, i8 noundef signext -35, i8 noundef signext 43, i8 noundef signext 117, i8 noundef signext 11, i8 noundef signext -103, i8 noundef signext -21)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %mask35 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -116, i8 noundef signext 124, i8 noundef signext -23, i8 noundef signext -24, i8 noundef signext -105, i8 noundef signext -39, i8 noundef signext 45, i8 noundef signext -32, i8 noundef signext 5, i8 noundef signext -60, i8 noundef signext -98, i8 noundef signext 111, i8 noundef signext -112, i8 noundef signext -60, i8 noundef signext 8, i8 noundef signext 13)
  store <2 x i64> %call36, ptr %mask35, align 16, !tbaa !16
  %r37 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element30, i32 0, i32 3
  %call38 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -81, i8 noundef signext -111, i8 noundef signext 59, i8 noundef signext 3, i8 noundef signext 113, i8 noundef signext -96, i8 noundef signext 102, i8 noundef signext 77, i8 noundef signext 123, i8 noundef signext 59, i8 noundef signext -35, i8 noundef signext -90, i8 noundef signext 117, i8 noundef signext 11, i8 noundef signext -39, i8 noundef signext -114)
  store <2 x i64> %call38, ptr %r37, align 16, !tbaa !16
  %arrayinit.element39 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element30, i64 1
  %a40 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element39, i32 0, i32 0
  %call41 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 53, i8 noundef signext -97, i8 noundef signext 79, i8 noundef signext -93, i8 noundef signext 55, i8 noundef signext -115, i8 noundef signext -80, i8 noundef signext -27, i8 noundef signext 104, i8 noundef signext 109, i8 noundef signext -16, i8 noundef signext -75, i8 noundef signext 125, i8 noundef signext 6, i8 noundef signext 38, i8 noundef signext -55)
  store <2 x i64> %call41, ptr %a40, align 16, !tbaa !16
  %b42 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element39, i32 0, i32 1
  %call43 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 48, i8 noundef signext 25, i8 noundef signext 24, i8 noundef signext -17, i8 noundef signext -102, i8 noundef signext -66, i8 noundef signext -6, i8 noundef signext 22, i8 noundef signext -100, i8 noundef signext -56, i8 noundef signext 25, i8 noundef signext -26, i8 noundef signext -37, i8 noundef signext 49, i8 noundef signext 8, i8 noundef signext -6)
  store <2 x i64> %call43, ptr %b42, align 16, !tbaa !16
  %mask44 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element39, i32 0, i32 2
  %call45 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -114, i8 noundef signext 27, i8 noundef signext -68, i8 noundef signext 3, i8 noundef signext 88, i8 noundef signext 71, i8 noundef signext 77, i8 noundef signext 108, i8 noundef signext -112, i8 noundef signext 117, i8 noundef signext -100, i8 noundef signext -26, i8 noundef signext 86, i8 noundef signext -48, i8 noundef signext -34, i8 noundef signext -71)
  store <2 x i64> %call45, ptr %mask44, align 16, !tbaa !16
  %r46 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element39, i32 0, i32 3
  %call47 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 48, i8 noundef signext -97, i8 noundef signext 24, i8 noundef signext -93, i8 noundef signext 55, i8 noundef signext -115, i8 noundef signext -80, i8 noundef signext -27, i8 noundef signext -100, i8 noundef signext 109, i8 noundef signext 25, i8 noundef signext -26, i8 noundef signext 125, i8 noundef signext 49, i8 noundef signext 8, i8 noundef signext -6)
  store <2 x i64> %call47, ptr %r46, align 16, !tbaa !16
  %arrayinit.element48 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element39, i64 1
  %a49 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element48, i32 0, i32 0
  %call50 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -121, i8 noundef signext 29, i8 noundef signext -87, i8 noundef signext 80, i8 noundef signext 19, i8 noundef signext 64, i8 noundef signext 104, i8 noundef signext 67, i8 noundef signext -22, i8 noundef signext -16, i8 noundef signext -57, i8 noundef signext -78, i8 noundef signext -96, i8 noundef signext -113, i8 noundef signext 114, i8 noundef signext 15)
  store <2 x i64> %call50, ptr %a49, align 16, !tbaa !16
  %b51 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element48, i32 0, i32 1
  %call52 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 99, i8 noundef signext -98, i8 noundef signext 122, i8 noundef signext 119, i8 noundef signext 80, i8 noundef signext -87, i8 noundef signext -77, i8 noundef signext -36, i8 noundef signext 10, i8 noundef signext 99, i8 noundef signext 114, i8 noundef signext -46, i8 noundef signext -79, i8 noundef signext -58, i8 noundef signext -87, i8 noundef signext 106)
  store <2 x i64> %call52, ptr %b51, align 16, !tbaa !16
  %mask53 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element48, i32 0, i32 2
  %call54 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -96, i8 noundef signext 67, i8 noundef signext -85, i8 noundef signext 80, i8 noundef signext 107, i8 noundef signext 9, i8 noundef signext 20, i8 noundef signext 91, i8 noundef signext -58, i8 noundef signext -6, i8 noundef signext 120, i8 noundef signext -24, i8 noundef signext 26, i8 noundef signext -94, i8 noundef signext -17, i8 noundef signext 25)
  store <2 x i64> %call54, ptr %mask53, align 16, !tbaa !16
  %r55 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element48, i32 0, i32 3
  %call56 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 99, i8 noundef signext 29, i8 noundef signext 122, i8 noundef signext 80, i8 noundef signext 19, i8 noundef signext 64, i8 noundef signext 104, i8 noundef signext 67, i8 noundef signext 10, i8 noundef signext 99, i8 noundef signext -57, i8 noundef signext -46, i8 noundef signext -96, i8 noundef signext -58, i8 noundef signext -87, i8 noundef signext 15)
  store <2 x i64> %call56, ptr %r55, align 16, !tbaa !16
  %arrayinit.element57 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element48, i64 1
  %a58 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element57, i32 0, i32 0
  %call59 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -13, i8 noundef signext 28, i8 noundef signext -62, i8 noundef signext 108, i8 noundef signext -15, i8 noundef signext 17, i8 noundef signext -48, i8 noundef signext 13, i8 noundef signext 32, i8 noundef signext -56, i8 noundef signext 83, i8 noundef signext -65, i8 noundef signext 73, i8 noundef signext -114, i8 noundef signext 47, i8 noundef signext 99)
  store <2 x i64> %call59, ptr %a58, align 16, !tbaa !16
  %b60 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element57, i32 0, i32 1
  %call61 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 84, i8 noundef signext -32, i8 noundef signext -4, i8 noundef signext 8, i8 noundef signext 66, i8 noundef signext -71, i8 noundef signext -69, i8 noundef signext -41, i8 noundef signext -21, i8 noundef signext -40, i8 noundef signext 64, i8 noundef signext -47, i8 noundef signext 16, i8 noundef signext -61, i8 noundef signext 3, i8 noundef signext -15)
  store <2 x i64> %call61, ptr %b60, align 16, !tbaa !16
  %mask62 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element57, i32 0, i32 2
  %call63 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 27, i8 noundef signext 104, i8 noundef signext -26, i8 noundef signext -51, i8 noundef signext 114, i8 noundef signext -9, i8 noundef signext -56, i8 noundef signext 125, i8 noundef signext 41, i8 noundef signext -51, i8 noundef signext 26, i8 noundef signext 121, i8 noundef signext -16, i8 noundef signext -59, i8 noundef signext 93, i8 noundef signext -56)
  store <2 x i64> %call63, ptr %mask62, align 16, !tbaa !16
  %r64 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element57, i32 0, i32 3
  %call65 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -13, i8 noundef signext 28, i8 noundef signext -4, i8 noundef signext 8, i8 noundef signext -15, i8 noundef signext -71, i8 noundef signext -69, i8 noundef signext 13, i8 noundef signext 32, i8 noundef signext -40, i8 noundef signext 83, i8 noundef signext -65, i8 noundef signext 16, i8 noundef signext -61, i8 noundef signext 47, i8 noundef signext -15)
  store <2 x i64> %call65, ptr %r64, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup76

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r66) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.3], ptr %test_vec, i64 0, i64 %1
  %a67 = getelementptr inbounds %struct.anon.3, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a67, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx68 = getelementptr inbounds [8 x %struct.anon.3], ptr %test_vec, i64 0, i64 %3
  %b69 = getelementptr inbounds %struct.anon.3, ptr %arrayidx68, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b69, align 16, !tbaa !16
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx70 = getelementptr inbounds [8 x %struct.anon.3], ptr %test_vec, i64 0, i64 %5
  %mask71 = getelementptr inbounds %struct.anon.3, ptr %arrayidx70, i32 0, i32 2
  %6 = load <2 x i64>, ptr %mask71, align 16, !tbaa !16
  %call72 = call <2 x i64> @simde_mm_blendv_epi8(<2 x i64> noundef %2, <2 x i64> noundef %4, <2 x i64> noundef %6)
  store <2 x i64> %call72, ptr %r66, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %7 = load <2 x i64>, ptr %r66, align 16, !tbaa !16
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx73 = getelementptr inbounds [8 x %struct.anon.3], ptr %test_vec, i64 0, i64 %8
  %r74 = getelementptr inbounds %struct.anon.3, ptr %arrayidx73, i32 0, i32 3
  %9 = load <2 x i64>, ptr %r74, align 16, !tbaa !16
  %call75 = call i32 @simde_test_x86_assert_equal_i8x16_(<2 x i64> noundef %7, <2 x i64> noundef %9, ptr noundef @.str.72, i32 noundef 168, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call75, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r66) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup76 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %10, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup76:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest77 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest77, label %cleanup78 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup76
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup78

cleanup78:                                        ; preds = %for.end, %cleanup76
  call void @llvm.lifetime.end.p0(i64 512, ptr %test_vec) #10
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_x_mm_blendv_epi16() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.4], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r66 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 512, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.4], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.4, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -5889, i16 noundef signext -9240, i16 noundef signext 13406, i16 noundef signext 23197, i16 noundef signext 25390, i16 noundef signext 20613, i16 noundef signext -3211, i16 noundef signext -5281)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.4, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -5787, i16 noundef signext 260, i16 noundef signext -28529, i16 noundef signext -341, i16 noundef signext 26074, i16 noundef signext -30339, i16 noundef signext -9562, i16 noundef signext -4010)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %mask = getelementptr inbounds %struct.anon.4, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 11580, i16 noundef signext -26297, i16 noundef signext 8234, i16 noundef signext -6769, i16 noundef signext -3010, i16 noundef signext 26987, i16 noundef signext 26235, i16 noundef signext -23439)
  store <2 x i64> %call2, ptr %mask, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.4, ptr %arrayinit.begin, i32 0, i32 3
  %call3 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -5889, i16 noundef signext 260, i16 noundef signext 13406, i16 noundef signext -341, i16 noundef signext 26074, i16 noundef signext 20613, i16 noundef signext -3211, i16 noundef signext -4010)
  store <2 x i64> %call3, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.4, ptr %arrayinit.begin, i64 1
  %a4 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element, i32 0, i32 0
  %call5 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -10477, i16 noundef signext 1551, i16 noundef signext -16362, i16 noundef signext -15016, i16 noundef signext -3374, i16 noundef signext -19084, i16 noundef signext -221, i16 noundef signext -19089)
  store <2 x i64> %call5, ptr %a4, align 16, !tbaa !16
  %b6 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element, i32 0, i32 1
  %call7 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 8603, i16 noundef signext 8519, i16 noundef signext 4642, i16 noundef signext 1129, i16 noundef signext 6053, i16 noundef signext 28257, i16 noundef signext 10987, i16 noundef signext -17611)
  store <2 x i64> %call7, ptr %b6, align 16, !tbaa !16
  %mask8 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element, i32 0, i32 2
  %call9 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -14703, i16 noundef signext 23402, i16 noundef signext -5363, i16 noundef signext 25451, i16 noundef signext 4787, i16 noundef signext 6143, i16 noundef signext -8049, i16 noundef signext -25291)
  store <2 x i64> %call9, ptr %mask8, align 16, !tbaa !16
  %r10 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element, i32 0, i32 3
  %call11 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 8603, i16 noundef signext 1551, i16 noundef signext 4642, i16 noundef signext -15016, i16 noundef signext -3374, i16 noundef signext -19084, i16 noundef signext 10987, i16 noundef signext -17611)
  store <2 x i64> %call11, ptr %r10, align 16, !tbaa !16
  %arrayinit.element12 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element, i64 1
  %a13 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element12, i32 0, i32 0
  %call14 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -10958, i16 noundef signext 239, i16 noundef signext -29416, i16 noundef signext 25642, i16 noundef signext -31255, i16 noundef signext 18557, i16 noundef signext 17603, i16 noundef signext 9411)
  store <2 x i64> %call14, ptr %a13, align 16, !tbaa !16
  %b15 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element12, i32 0, i32 1
  %call16 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -22204, i16 noundef signext -12104, i16 noundef signext 21385, i16 noundef signext 163, i16 noundef signext -13806, i16 noundef signext -4673, i16 noundef signext -31502, i16 noundef signext 30113)
  store <2 x i64> %call16, ptr %b15, align 16, !tbaa !16
  %mask17 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element12, i32 0, i32 2
  %call18 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 26590, i16 noundef signext -27173, i16 noundef signext 3052, i16 noundef signext 29423, i16 noundef signext 14159, i16 noundef signext 16581, i16 noundef signext 15114, i16 noundef signext 31350)
  store <2 x i64> %call18, ptr %mask17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element12, i32 0, i32 3
  %call20 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -10958, i16 noundef signext -12104, i16 noundef signext -29416, i16 noundef signext 25642, i16 noundef signext -31255, i16 noundef signext 18557, i16 noundef signext 17603, i16 noundef signext 9411)
  store <2 x i64> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element12, i64 1
  %a22 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -8795, i16 noundef signext -24496, i16 noundef signext -21018, i16 noundef signext -23768, i16 noundef signext 25939, i16 noundef signext -2265, i16 noundef signext 13801, i16 noundef signext 28390)
  store <2 x i64> %call23, ptr %a22, align 16, !tbaa !16
  %b24 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -31776, i16 noundef signext 7886, i16 noundef signext 19773, i16 noundef signext 11337, i16 noundef signext -9683, i16 noundef signext -15212, i16 noundef signext -11745, i16 noundef signext -21367)
  store <2 x i64> %call25, ptr %b24, align 16, !tbaa !16
  %mask26 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element21, i32 0, i32 2
  %call27 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -30437, i16 noundef signext -4024, i16 noundef signext -15989, i16 noundef signext -4852, i16 noundef signext 20067, i16 noundef signext 28092, i16 noundef signext -20772, i16 noundef signext 17444)
  store <2 x i64> %call27, ptr %mask26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element21, i32 0, i32 3
  %call29 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -31776, i16 noundef signext 7886, i16 noundef signext 19773, i16 noundef signext 11337, i16 noundef signext 25939, i16 noundef signext -2265, i16 noundef signext -11745, i16 noundef signext 28390)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element21, i64 1
  %a31 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 11712, i16 noundef signext 21433, i16 noundef signext -1195, i16 noundef signext 25259, i16 noundef signext 18957, i16 noundef signext 5262, i16 noundef signext -9688, i16 noundef signext -14506)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 24574, i16 noundef signext 2777, i16 noundef signext -18691, i16 noundef signext 4928, i16 noundef signext 32122, i16 noundef signext -10541, i16 noundef signext 2746, i16 noundef signext 8282)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %mask35 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 5301, i16 noundef signext 12242, i16 noundef signext 18664, i16 noundef signext 26110, i16 noundef signext -14367, i16 noundef signext -9137, i16 noundef signext -7209, i16 noundef signext 24768)
  store <2 x i64> %call36, ptr %mask35, align 16, !tbaa !16
  %r37 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element30, i32 0, i32 3
  %call38 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 11712, i16 noundef signext 21433, i16 noundef signext -1195, i16 noundef signext 25259, i16 noundef signext 32122, i16 noundef signext -10541, i16 noundef signext 2746, i16 noundef signext -14506)
  store <2 x i64> %call38, ptr %r37, align 16, !tbaa !16
  %arrayinit.element39 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element30, i64 1
  %a40 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element39, i32 0, i32 0
  %call41 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -20542, i16 noundef signext 3332, i16 noundef signext 24354, i16 noundef signext -23695, i16 noundef signext -10493, i16 noundef signext 32452, i16 noundef signext -26923, i16 noundef signext 16579)
  store <2 x i64> %call41, ptr %a40, align 16, !tbaa !16
  %b42 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element39, i32 0, i32 1
  %call43 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 29156, i16 noundef signext 8347, i16 noundef signext -32604, i16 noundef signext -24707, i16 noundef signext -20393, i16 noundef signext -18566, i16 noundef signext 17032, i16 noundef signext -18520)
  store <2 x i64> %call43, ptr %b42, align 16, !tbaa !16
  %mask44 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element39, i32 0, i32 2
  %call45 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -23886, i16 noundef signext 30820, i16 noundef signext 12721, i16 noundef signext -28893, i16 noundef signext -7688, i16 noundef signext 11154, i16 noundef signext -11967, i16 noundef signext 31969)
  store <2 x i64> %call45, ptr %mask44, align 16, !tbaa !16
  %r46 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element39, i32 0, i32 3
  %call47 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 29156, i16 noundef signext 3332, i16 noundef signext 24354, i16 noundef signext -24707, i16 noundef signext -20393, i16 noundef signext 32452, i16 noundef signext 17032, i16 noundef signext 16579)
  store <2 x i64> %call47, ptr %r46, align 16, !tbaa !16
  %arrayinit.element48 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element39, i64 1
  %a49 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element48, i32 0, i32 0
  %call50 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 22583, i16 noundef signext 4415, i16 noundef signext -24878, i16 noundef signext -15401, i16 noundef signext -29840, i16 noundef signext -16999, i16 noundef signext -23406, i16 noundef signext -32259)
  store <2 x i64> %call50, ptr %a49, align 16, !tbaa !16
  %b51 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element48, i32 0, i32 1
  %call52 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 31553, i16 noundef signext 23166, i16 noundef signext -15560, i16 noundef signext 31886, i16 noundef signext 7368, i16 noundef signext -15822, i16 noundef signext -17797, i16 noundef signext 1487)
  store <2 x i64> %call52, ptr %b51, align 16, !tbaa !16
  %mask53 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element48, i32 0, i32 2
  %call54 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -12147, i16 noundef signext 2989, i16 noundef signext -24661, i16 noundef signext -22664, i16 noundef signext -16476, i16 noundef signext 408, i16 noundef signext -13750, i16 noundef signext -15888)
  store <2 x i64> %call54, ptr %mask53, align 16, !tbaa !16
  %r55 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element48, i32 0, i32 3
  %call56 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 31553, i16 noundef signext 4415, i16 noundef signext -15560, i16 noundef signext 31886, i16 noundef signext 7368, i16 noundef signext -16999, i16 noundef signext -17797, i16 noundef signext 1487)
  store <2 x i64> %call56, ptr %r55, align 16, !tbaa !16
  %arrayinit.element57 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element48, i64 1
  %a58 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element57, i32 0, i32 0
  %call59 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 32299, i16 noundef signext 7492, i16 noundef signext 26066, i16 noundef signext 30675, i16 noundef signext 26958, i16 noundef signext 8712, i16 noundef signext -17582, i16 noundef signext -18062)
  store <2 x i64> %call59, ptr %a58, align 16, !tbaa !16
  %b60 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element57, i32 0, i32 1
  %call61 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 25592, i16 noundef signext 2248, i16 noundef signext -21774, i16 noundef signext 7511, i16 noundef signext 6101, i16 noundef signext 18791, i16 noundef signext -31731, i16 noundef signext 22067)
  store <2 x i64> %call61, ptr %b60, align 16, !tbaa !16
  %mask62 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element57, i32 0, i32 2
  %call63 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -26320, i16 noundef signext 16537, i16 noundef signext -11326, i16 noundef signext 8393, i16 noundef signext -25832, i16 noundef signext 24810, i16 noundef signext -17206, i16 noundef signext -26982)
  store <2 x i64> %call63, ptr %mask62, align 16, !tbaa !16
  %r64 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element57, i32 0, i32 3
  %call65 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 25592, i16 noundef signext 7492, i16 noundef signext -21774, i16 noundef signext 30675, i16 noundef signext 6101, i16 noundef signext 8712, i16 noundef signext -31731, i16 noundef signext 22067)
  store <2 x i64> %call65, ptr %r64, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup76

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r66) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.4], ptr %test_vec, i64 0, i64 %1
  %a67 = getelementptr inbounds %struct.anon.4, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a67, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx68 = getelementptr inbounds [8 x %struct.anon.4], ptr %test_vec, i64 0, i64 %3
  %b69 = getelementptr inbounds %struct.anon.4, ptr %arrayidx68, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b69, align 16, !tbaa !16
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx70 = getelementptr inbounds [8 x %struct.anon.4], ptr %test_vec, i64 0, i64 %5
  %mask71 = getelementptr inbounds %struct.anon.4, ptr %arrayidx70, i32 0, i32 2
  %6 = load <2 x i64>, ptr %mask71, align 16, !tbaa !16
  %call72 = call <2 x i64> @simde_x_mm_blendv_epi16(<2 x i64> noundef %2, <2 x i64> noundef %4, <2 x i64> noundef %6)
  store <2 x i64> %call72, ptr %r66, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %7 = load <2 x i64>, ptr %r66, align 16, !tbaa !16
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx73 = getelementptr inbounds [8 x %struct.anon.4], ptr %test_vec, i64 0, i64 %8
  %r74 = getelementptr inbounds %struct.anon.4, ptr %arrayidx73, i32 0, i32 3
  %9 = load <2 x i64>, ptr %r74, align 16, !tbaa !16
  %call75 = call i32 @simde_test_x86_assert_equal_i16x8_(<2 x i64> noundef %7, <2 x i64> noundef %9, ptr noundef @.str.72, i32 noundef 250, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call75, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r66) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup76 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %10, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup76:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest77 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest77, label %cleanup78 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup76
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup78

cleanup78:                                        ; preds = %for.end, %cleanup76
  call void @llvm.lifetime.end.p0(i64 512, ptr %test_vec) #10
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_x_mm_blendv_epi32() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.5], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r66 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 512, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.5], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.5, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi32(i32 noundef -385885208, i32 noundef 878598813, i32 noundef 1663979653, i32 noundef -210375841)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.5, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -379256572, i32 noundef -1869611349, i32 noundef 1708820861, i32 noundef -626593706)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %mask = getelementptr inbounds %struct.anon.5, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 758946119, i32 noundef 539682191, i32 noundef -197236373, i32 noundef 1719379057)
  store <2 x i64> %call2, ptr %mask, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.5, ptr %arrayinit.begin, i32 0, i32 3
  %call3 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -385885208, i32 noundef 878598813, i32 noundef 1708820861, i32 noundef -210375841)
  store <2 x i64> %call3, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.5, ptr %arrayinit.begin, i64 1
  %a4 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element, i32 0, i32 0
  %call5 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -686619121, i32 noundef -1072249512, i32 noundef -221072012, i32 noundef -14437009)
  store <2 x i64> %call5, ptr %a4, align 16, !tbaa !16
  %b6 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element, i32 0, i32 1
  %call7 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 563814727, i32 noundef 304219241, i32 noundef 396717665, i32 noundef 720091957)
  store <2 x i64> %call7, ptr %b6, align 16, !tbaa !16
  %mask8 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element, i32 0, i32 2
  %call9 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -963552406, i32 noundef -351444117, i32 noundef 313726975, i32 noundef -527459019)
  store <2 x i64> %call9, ptr %mask8, align 16, !tbaa !16
  %r10 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element, i32 0, i32 3
  %call11 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 563814727, i32 noundef 304219241, i32 noundef -221072012, i32 noundef 720091957)
  store <2 x i64> %call11, ptr %r10, align 16, !tbaa !16
  %arrayinit.element12 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element, i64 1
  %a13 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element12, i32 0, i32 0
  %call14 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -718143249, i32 noundef -1927781334, i32 noundef -2048309123, i32 noundef 1153639619)
  store <2 x i64> %call14, ptr %a13, align 16, !tbaa !16
  %b15 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element12, i32 0, i32 1
  %call16 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1455107912, i32 noundef 1401487523, i32 noundef -904729153, i32 noundef -2064484959)
  store <2 x i64> %call16, ptr %b15, align 16, !tbaa !16
  %mask17 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element12, i32 0, i32 2
  %call18 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1742640603, i32 noundef 200045295, i32 noundef 927940805, i32 noundef 990542454)
  store <2 x i64> %call18, ptr %mask17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element12, i32 0, i32 3
  %call20 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -718143249, i32 noundef -1927781334, i32 noundef -2048309123, i32 noundef 1153639619)
  store <2 x i64> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element12, i64 1
  %a22 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -576348080, i32 noundef -1377393880, i32 noundef 1700001575, i32 noundef 904490726)
  store <2 x i64> %call23, ptr %a22, align 16, !tbaa !16
  %b24 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -2082464050, i32 noundef 1295854665, i32 noundef -634534764, i32 noundef -769676151)
  store <2 x i64> %call25, ptr %b24, align 16, !tbaa !16
  %mask26 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element21, i32 0, i32 2
  %call27 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1994657720, i32 noundef -1047794420, i32 noundef 1315139004, i32 noundef -1361296348)
  store <2 x i64> %call27, ptr %mask26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element21, i32 0, i32 3
  %call29 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -2082464050, i32 noundef 1295854665, i32 noundef 1700001575, i32 noundef -769676151)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element21, i64 1
  %a31 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 767579065, i32 noundef -78290261, i32 noundef 1242371214, i32 noundef -634861738)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1610484441, i32 noundef -1224928448, i32 noundef 2105202387, i32 noundef 179970138)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %mask35 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 347418578, i32 noundef 1223190014, i32 noundef -941499313, i32 noundef -472424256)
  store <2 x i64> %call36, ptr %mask35, align 16, !tbaa !16
  %r37 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element30, i32 0, i32 3
  %call38 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 767579065, i32 noundef -78290261, i32 noundef 2105202387, i32 noundef 179970138)
  store <2 x i64> %call38, ptr %r37, align 16, !tbaa !16
  %arrayinit.element39 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element30, i64 1
  %a40 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element39, i32 0, i32 0
  %call41 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1346237180, i32 noundef 1596105585, i32 noundef -687636796, i32 noundef -1764409149)
  store <2 x i64> %call41, ptr %a40, align 16, !tbaa !16
  %b42 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element39, i32 0, i32 1
  %call43 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1910775963, i32 noundef -2136694915, i32 noundef -1336428678, i32 noundef 1116256168)
  store <2 x i64> %call43, ptr %b42, align 16, !tbaa !16
  %mask44 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element39, i32 0, i32 2
  %call45 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1565362076, i32 noundef 833720099, i32 noundef -503829614, i32 noundef -784237343)
  store <2 x i64> %call45, ptr %mask44, align 16, !tbaa !16
  %r46 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element39, i32 0, i32 3
  %call47 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1910775963, i32 noundef 1596105585, i32 noundef -1336428678, i32 noundef 1116256168)
  store <2 x i64> %call47, ptr %r46, align 16, !tbaa !16
  %arrayinit.element48 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element39, i64 1
  %a49 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element48, i32 0, i32 0
  %call50 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1480003903, i32 noundef -1630354473, i32 noundef -1955545703, i32 noundef -1533902339)
  store <2 x i64> %call50, ptr %a49, align 16, !tbaa !16
  %b51 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element48, i32 0, i32 1
  %call52 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 2067880574, i32 noundef -1019708274, i32 noundef 482918962, i32 noundef -1166342705)
  store <2 x i64> %call52, ptr %b51, align 16, !tbaa !16
  %mask53 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element48, i32 0, i32 2
  %call54 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -796062803, i32 noundef -1616140424, i32 noundef -1079770728, i32 noundef -901070352)
  store <2 x i64> %call54, ptr %mask53, align 16, !tbaa !16
  %r55 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element48, i32 0, i32 3
  %call56 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 2067880574, i32 noundef -1019708274, i32 noundef 482918962, i32 noundef -1166342705)
  store <2 x i64> %call56, ptr %r55, align 16, !tbaa !16
  %arrayinit.element57 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element48, i64 1
  %a58 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element57, i32 0, i32 0
  %call59 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 2116754756, i32 noundef 1708292051, i32 noundef 1766728200, i32 noundef -1152206478)
  store <2 x i64> %call59, ptr %a58, align 16, !tbaa !16
  %b60 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element57, i32 0, i32 1
  %call61 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1677199560, i32 noundef -1426973353, i32 noundef 399853927, i32 noundef -2079500749)
  store <2 x i64> %call61, ptr %b60, align 16, !tbaa !16
  %mask62 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element57, i32 0, i32 2
  %call63 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1724890983, i32 noundef -742252343, i32 noundef -1692901142, i32 noundef -1127573862)
  store <2 x i64> %call63, ptr %mask62, align 16, !tbaa !16
  %r64 = getelementptr inbounds %struct.anon.5, ptr %arrayinit.element57, i32 0, i32 3
  %call65 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1677199560, i32 noundef -1426973353, i32 noundef 399853927, i32 noundef -2079500749)
  store <2 x i64> %call65, ptr %r64, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup76

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r66) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.5], ptr %test_vec, i64 0, i64 %1
  %a67 = getelementptr inbounds %struct.anon.5, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a67, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx68 = getelementptr inbounds [8 x %struct.anon.5], ptr %test_vec, i64 0, i64 %3
  %b69 = getelementptr inbounds %struct.anon.5, ptr %arrayidx68, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b69, align 16, !tbaa !16
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx70 = getelementptr inbounds [8 x %struct.anon.5], ptr %test_vec, i64 0, i64 %5
  %mask71 = getelementptr inbounds %struct.anon.5, ptr %arrayidx70, i32 0, i32 2
  %6 = load <2 x i64>, ptr %mask71, align 16, !tbaa !16
  %call72 = call <2 x i64> @simde_x_mm_blendv_epi32(<2 x i64> noundef %2, <2 x i64> noundef %4, <2 x i64> noundef %6)
  store <2 x i64> %call72, ptr %r66, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %7 = load <2 x i64>, ptr %r66, align 16, !tbaa !16
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx73 = getelementptr inbounds [8 x %struct.anon.5], ptr %test_vec, i64 0, i64 %8
  %r74 = getelementptr inbounds %struct.anon.5, ptr %arrayidx73, i32 0, i32 3
  %9 = load <2 x i64>, ptr %r74, align 16, !tbaa !16
  %call75 = call i32 @simde_test_x86_assert_equal_i32x4_(<2 x i64> noundef %7, <2 x i64> noundef %9, ptr noundef @.str.72, i32 noundef 300, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call75, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r66) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup76 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %10, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup76:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest77 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest77, label %cleanup78 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup76
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup78

cleanup78:                                        ; preds = %for.end, %cleanup76
  call void @llvm.lifetime.end.p0(i64 512, ptr %test_vec) #10
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_x_mm_blendv_epi64() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.6], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r66 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 512, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.6], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.6, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -1657364347491558755, i64 noundef 7146738194929019743)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.6, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -1628894571107713365, i64 noundef 7339329716385935446)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %mask = getelementptr inbounds %struct.anon.6, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 3259648761070806415, i64 noundef -847123769897278351)
  store <2 x i64> %call2, ptr %mask, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.6, ptr %arrayinit.begin, i32 0, i32 3
  %call3 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -1657364347491558755, i64 noundef 7339329716385935446)
  store <2 x i64> %call3, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.6, ptr %arrayinit.begin, i64 1
  %a4 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element, i32 0, i32 0
  %call5 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -2949006666280549032, i64 noundef -949497057320389265)
  store <2 x i64> %call5, ptr %a4, align 16, !tbaa !16
  %b6 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element, i32 0, i32 1
  %call7 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 2421565813772387433, i64 noundef 1703889397640575797)
  store <2 x i64> %call7, ptr %b6, align 16, !tbaa !16
  %mask8 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element, i32 0, i32 2
  %call9 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -4138426067808590997, i64 noundef 1347447101265517877)
  store <2 x i64> %call9, ptr %mask8, align 16, !tbaa !16
  %r10 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element, i32 0, i32 3
  %call11 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 2421565813772387433, i64 noundef -949497057320389265)
  store <2 x i64> %call11, ptr %r10, align 16, !tbaa !16
  %arrayinit.element12 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element, i64 1
  %a13 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element12, i32 0, i32 0
  %call14 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -3084401765930998742, i64 noundef -8797420694229801789)
  store <2 x i64> %call14, ptr %a13, align 16, !tbaa !16
  %b15 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element12, i32 0, i32 1
  %call16 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -6249640892789358429, i64 noundef -3885782121642297951)
  store <2 x i64> %call16, ptr %b15, align 16, !tbaa !16
  %mask17 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element12, i32 0, i32 2
  %call18 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 7484584398766764783, i64 noundef 3985475411089455734)
  store <2 x i64> %call18, ptr %mask17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element12, i32 0, i32 3
  %call20 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -3084401765930998742, i64 noundef -8797420694229801789)
  store <2 x i64> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element12, i64 1
  %a22 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -2475396151794818264, i64 noundef 7301451168677981926)
  store <2 x i64> %call23, ptr %a22, align 16, !tbaa !16
  %b24 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -8944114988549854135, i64 noundef -2725306056029786999)
  store <2 x i64> %call25, ptr %b24, align 16, !tbaa !16
  %mask26 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element21, i32 0, i32 2
  %call27 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -8566989670866752244, i64 noundef 5648479014807684132)
  store <2 x i64> %call27, ptr %mask26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element21, i32 0, i32 3
  %call29 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -8944114988549854135, i64 noundef 7301451168677981926)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element21, i64 1
  %a31 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 3296726985485935275, i64 noundef 5335943737281922902)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 6916978007881880384, i64 noundef 9041775403806105690)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %mask35 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 1492151431756015102, i64 noundef -4043708754718924608)
  store <2 x i64> %call36, ptr %mask35, align 16, !tbaa !16
  %r37 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element30, i32 0, i32 3
  %call38 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 3296726985485935275, i64 noundef 9041775403806105690)
  store <2 x i64> %call38, ptr %r37, align 16, !tbaa !16
  %arrayinit.element39 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element30, i64 1
  %a40 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element39, i32 0, i32 0
  %call41 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -5782044659163159695, i64 noundef -2953377547815665469)
  store <2 x i64> %call41, ptr %a40, align 16, !tbaa !16
  %b42 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element39, i32 0, i32 1
  %call43 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 8206720273226178429, i64 noundef -5739917464330258520)
  store <2 x i64> %call43, ptr %b42, align 16, !tbaa !16
  %mask44 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element39, i32 0, i32 2
  %call45 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -6723178921984946397, i64 noundef -2163931711375573791)
  store <2 x i64> %call45, ptr %mask44, align 16, !tbaa !16
  %r46 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element39, i32 0, i32 3
  %call47 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 8206720273226178429, i64 noundef -5739917464330258520)
  store <2 x i64> %call47, ptr %r46, align 16, !tbaa !16
  %arrayinit.element48 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element39, i64 1
  %a49 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element48, i32 0, i32 0
  %call50 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 6356568364001969111, i64 noundef -8399004837457264131)
  store <2 x i64> %call50, ptr %a49, align 16, !tbaa !16
  %b51 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element48, i32 0, i32 1
  %call52 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 8881479440638966926, i64 noundef 2074121151536891343)
  store <2 x i64> %call52, ptr %b51, align 16, !tbaa !16
  %mask53 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element48, i32 0, i32 2
  %call54 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -3419063701768263816, i64 noundef -4637579960544214544)
  store <2 x i64> %call54, ptr %mask53, align 16, !tbaa !16
  %r55 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element48, i32 0, i32 3
  %call56 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 8881479440638966926, i64 noundef 2074121151536891343)
  store <2 x i64> %call56, ptr %r55, align 16, !tbaa !16
  %arrayinit.element57 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element48, i64 1
  %a58 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element57, i32 0, i32 0
  %call59 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 9091392452380751827, i64 noundef 7588039843063708018)
  store <2 x i64> %call59, ptr %a58, align 16, !tbaa !16
  %b60 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element57, i32 0, i32 1
  %call61 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 7203517261933583703, i64 noundef 1717359541857637939)
  store <2 x i64> %call61, ptr %b60, align 16, !tbaa !16
  %mask62 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element57, i32 0, i32 2
  %call63 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -7408350357597577015, i64 noundef -7270955037083658598)
  store <2 x i64> %call63, ptr %mask62, align 16, !tbaa !16
  %r64 = getelementptr inbounds %struct.anon.6, ptr %arrayinit.element57, i32 0, i32 3
  %call65 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 7203517261933583703, i64 noundef 1717359541857637939)
  store <2 x i64> %call65, ptr %r64, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup76

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r66) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.6], ptr %test_vec, i64 0, i64 %1
  %a67 = getelementptr inbounds %struct.anon.6, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a67, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx68 = getelementptr inbounds [8 x %struct.anon.6], ptr %test_vec, i64 0, i64 %3
  %b69 = getelementptr inbounds %struct.anon.6, ptr %arrayidx68, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b69, align 16, !tbaa !16
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx70 = getelementptr inbounds [8 x %struct.anon.6], ptr %test_vec, i64 0, i64 %5
  %mask71 = getelementptr inbounds %struct.anon.6, ptr %arrayidx70, i32 0, i32 2
  %6 = load <2 x i64>, ptr %mask71, align 16, !tbaa !16
  %call72 = call <2 x i64> @simde_x_mm_blendv_epi64(<2 x i64> noundef %2, <2 x i64> noundef %4, <2 x i64> noundef %6)
  store <2 x i64> %call72, ptr %r66, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %7 = load <2 x i64>, ptr %r66, align 16, !tbaa !16
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx73 = getelementptr inbounds [8 x %struct.anon.6], ptr %test_vec, i64 0, i64 %8
  %r74 = getelementptr inbounds %struct.anon.6, ptr %arrayidx73, i32 0, i32 3
  %9 = load <2 x i64>, ptr %r74, align 16, !tbaa !16
  %call75 = call i32 @simde_test_x86_assert_equal_i64x2_(<2 x i64> noundef %7, <2 x i64> noundef %9, ptr noundef @.str.72, i32 noundef 350, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call75, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r66) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup76 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %10, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup76:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest77 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest77, label %cleanup78 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup76
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup78

cleanup78:                                        ; preds = %for.end, %cleanup76
  call void @llvm.lifetime.end.p0(i64 512, ptr %test_vec) #10
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_blendv_pd() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.7], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r66 = alloca <2 x double>, align 16
  call void @llvm.lifetime.start.p0(i64 512, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.7], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.7, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x double> @simde_mm_set_pd(double noundef 2.900200e+02, double noundef -7.751200e+02)
  store <2 x double> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.7, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x double> @simde_mm_set_pd(double noundef 5.676500e+02, double noundef 3.398700e+02)
  store <2 x double> %call1, ptr %b, align 16, !tbaa !16
  %mask = getelementptr inbounds %struct.anon.7, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 0, i64 noundef 1)
  store <2 x i64> %call2, ptr %mask, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.7, ptr %arrayinit.begin, i32 0, i32 3
  %call3 = call <2 x double> @simde_mm_set_pd(double noundef 2.900200e+02, double noundef -7.751200e+02)
  store <2 x double> %call3, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.7, ptr %arrayinit.begin, i64 1
  %a4 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element, i32 0, i32 0
  %call5 = call <2 x double> @simde_mm_set_pd(double noundef 7.022400e+02, double noundef -3.719900e+02)
  store <2 x double> %call5, ptr %a4, align 16, !tbaa !16
  %b6 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element, i32 0, i32 1
  %call7 = call <2 x double> @simde_mm_set_pd(double noundef 0x408C1828F5C28F5C, double noundef -6.647300e+02)
  store <2 x double> %call7, ptr %b6, align 16, !tbaa !16
  %mask8 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element, i32 0, i32 2
  %call9 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 1, i64 noundef 1)
  store <2 x i64> %call9, ptr %mask8, align 16, !tbaa !16
  %r10 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element, i32 0, i32 3
  %call11 = call <2 x double> @simde_mm_set_pd(double noundef 7.022400e+02, double noundef -3.719900e+02)
  store <2 x double> %call11, ptr %r10, align 16, !tbaa !16
  %arrayinit.element12 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element, i64 1
  %a13 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element12, i32 0, i32 0
  %call14 = call <2 x double> @simde_mm_set_pd(double noundef 4.032700e+02, double noundef -7.408700e+02)
  store <2 x double> %call14, ptr %a13, align 16, !tbaa !16
  %b15 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element12, i32 0, i32 1
  %call16 = call <2 x double> @simde_mm_set_pd(double noundef 0x408E7B3333333333, double noundef -4.802400e+02)
  store <2 x double> %call16, ptr %b15, align 16, !tbaa !16
  %mask17 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element12, i32 0, i32 2
  %call18 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 0, i64 noundef 0)
  store <2 x i64> %call18, ptr %mask17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element12, i32 0, i32 3
  %call20 = call <2 x double> @simde_mm_set_pd(double noundef 4.032700e+02, double noundef -7.408700e+02)
  store <2 x double> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element12, i64 1
  %a22 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x double> @simde_mm_set_pd(double noundef -4.176700e+02, double noundef 0x40863F5C28F5C28F)
  store <2 x double> %call23, ptr %a22, align 16, !tbaa !16
  %b24 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x double> @simde_mm_set_pd(double noundef -8.972100e+02, double noundef -4.025900e+02)
  store <2 x double> %call25, ptr %b24, align 16, !tbaa !16
  %mask26 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element21, i32 0, i32 2
  %call27 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 1, i64 noundef 0)
  store <2 x i64> %call27, ptr %mask26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element21, i32 0, i32 3
  %call29 = call <2 x double> @simde_mm_set_pd(double noundef -4.176700e+02, double noundef 0x40863F5C28F5C28F)
  store <2 x double> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element21, i64 1
  %a31 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x double> @simde_mm_set_pd(double noundef 0x4082171EB851EB85, double noundef -8.959900e+02)
  store <2 x double> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x double> @simde_mm_set_pd(double noundef -8.005000e+02, double noundef -1.442800e+02)
  store <2 x double> %call34, ptr %b33, align 16, !tbaa !16
  %mask35 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 1, i64 noundef 0)
  store <2 x i64> %call36, ptr %mask35, align 16, !tbaa !16
  %r37 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element30, i32 0, i32 3
  %call38 = call <2 x double> @simde_mm_set_pd(double noundef 0x4082171EB851EB85, double noundef -8.959900e+02)
  store <2 x double> %call38, ptr %r37, align 16, !tbaa !16
  %arrayinit.element39 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element30, i64 1
  %a40 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element39, i32 0, i32 0
  %call41 = call <2 x double> @simde_mm_set_pd(double noundef 5.467800e+02, double noundef 8.835700e+02)
  store <2 x double> %call41, ptr %a40, align 16, !tbaa !16
  %b42 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element39, i32 0, i32 1
  %call43 = call <2 x double> @simde_mm_set_pd(double noundef 4.150100e+02, double noundef 7.732100e+02)
  store <2 x double> %call43, ptr %b42, align 16, !tbaa !16
  %mask44 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element39, i32 0, i32 2
  %call45 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 1, i64 noundef 0)
  store <2 x i64> %call45, ptr %mask44, align 16, !tbaa !16
  %r46 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element39, i32 0, i32 3
  %call47 = call <2 x double> @simde_mm_set_pd(double noundef 5.467800e+02, double noundef 8.835700e+02)
  store <2 x double> %call47, ptr %r46, align 16, !tbaa !16
  %arrayinit.element48 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element39, i64 1
  %a49 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element48, i32 0, i32 0
  %call50 = call <2 x double> @simde_mm_set_pd(double noundef 2.601000e+01, double noundef -5.950000e+01)
  store <2 x double> %call50, ptr %a49, align 16, !tbaa !16
  %b51 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element48, i32 0, i32 1
  %call52 = call <2 x double> @simde_mm_set_pd(double noundef -5.302600e+02, double noundef 0x4082271EB851EB85)
  store <2 x double> %call52, ptr %b51, align 16, !tbaa !16
  %mask53 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element48, i32 0, i32 2
  %call54 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 0, i64 noundef 1)
  store <2 x i64> %call54, ptr %mask53, align 16, !tbaa !16
  %r55 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element48, i32 0, i32 3
  %call56 = call <2 x double> @simde_mm_set_pd(double noundef 2.601000e+01, double noundef -5.950000e+01)
  store <2 x double> %call56, ptr %r55, align 16, !tbaa !16
  %arrayinit.element57 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element48, i64 1
  %a58 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element57, i32 0, i32 0
  %call59 = call <2 x double> @simde_mm_set_pd(double noundef -3.442200e+02, double noundef 0x40839747AE147AE1)
  store <2 x double> %call59, ptr %a58, align 16, !tbaa !16
  %b60 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element57, i32 0, i32 1
  %call61 = call <2 x double> @simde_mm_set_pd(double noundef 7.524800e+02, double noundef 4.532800e+02)
  store <2 x double> %call61, ptr %b60, align 16, !tbaa !16
  %mask62 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element57, i32 0, i32 2
  %call63 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 0, i64 noundef 1)
  store <2 x i64> %call63, ptr %mask62, align 16, !tbaa !16
  %r64 = getelementptr inbounds %struct.anon.7, ptr %arrayinit.element57, i32 0, i32 3
  %call65 = call <2 x double> @simde_mm_set_pd(double noundef -3.442200e+02, double noundef 0x40839747AE147AE1)
  store <2 x double> %call65, ptr %r64, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup78

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r66) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.7], ptr %test_vec, i64 0, i64 %1
  %a67 = getelementptr inbounds %struct.anon.7, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x double>, ptr %a67, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx68 = getelementptr inbounds [8 x %struct.anon.7], ptr %test_vec, i64 0, i64 %3
  %b69 = getelementptr inbounds %struct.anon.7, ptr %arrayidx68, i32 0, i32 1
  %4 = load <2 x double>, ptr %b69, align 16, !tbaa !16
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx70 = getelementptr inbounds [8 x %struct.anon.7], ptr %test_vec, i64 0, i64 %5
  %mask71 = getelementptr inbounds %struct.anon.7, ptr %arrayidx70, i32 0, i32 2
  %6 = load <2 x i64>, ptr %mask71, align 16, !tbaa !16
  %call72 = call <2 x double> @simde_mm_castsi128_pd(<2 x i64> noundef %6)
  %call73 = call <2 x double> @simde_mm_blendv_pd(<2 x double> noundef %2, <2 x double> noundef %4, <2 x double> noundef %call72)
  store <2 x double> %call73, ptr %r66, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %7 = load <2 x double>, ptr %r66, align 16, !tbaa !16
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx74 = getelementptr inbounds [8 x %struct.anon.7], ptr %test_vec, i64 0, i64 %8
  %r75 = getelementptr inbounds %struct.anon.7, ptr %arrayidx74, i32 0, i32 3
  %9 = load <2 x double>, ptr %r75, align 16, !tbaa !16
  %call76 = call double @simde_test_f64_precision_to_slop(i32 noundef 1)
  %call77 = call i32 @simde_test_x86_assert_equal_f64x2_(<2 x double> noundef %7, <2 x double> noundef %9, double noundef %call76, ptr noundef @.str.72, i32 noundef 547, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call77, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r66) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup78 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %10, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup78:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest79 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest79, label %cleanup80 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup78
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup80

cleanup80:                                        ; preds = %for.end, %cleanup78
  call void @llvm.lifetime.end.p0(i64 512, ptr %test_vec) #10
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_blendv_ps() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.8], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r66 = alloca <4 x float>, align 16
  call void @llvm.lifetime.start.p0(i64 512, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.8], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.8, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <4 x float> @simde_mm_set_ps(float noundef 0xC06365C280000000, float noundef 0xC085D0A3E0000000, float noundef 0xC080B970A0000000, float noundef 0xC0620A3D80000000)
  store <4 x float> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.8, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <4 x float> @simde_mm_set_ps(float noundef 0xC076A8A3E0000000, float noundef 0xC0885B1EC0000000, float noundef 0x4089C81480000000, float noundef 0xC0884F70A0000000)
  store <4 x float> %call1, ptr %b, align 16, !tbaa !16
  %mask = getelementptr inbounds %struct.anon.8, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1, i32 noundef 0, i32 noundef 1, i32 noundef 0)
  store <2 x i64> %call2, ptr %mask, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.8, ptr %arrayinit.begin, i32 0, i32 3
  %call3 = call <4 x float> @simde_mm_set_ps(float noundef 0xC06365C280000000, float noundef 0xC085D0A3E0000000, float noundef 0xC080B970A0000000, float noundef 0xC0620A3D80000000)
  store <4 x float> %call3, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.8, ptr %arrayinit.begin, i64 1
  %a4 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element, i32 0, i32 0
  %call5 = call <4 x float> @simde_mm_set_ps(float noundef 0xC071C6B860000000, float noundef 0x4085A1EB80000000, float noundef 0x4059766660000000, float noundef 0xC0899A3D80000000)
  store <4 x float> %call5, ptr %a4, align 16, !tbaa !16
  %b6 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element, i32 0, i32 1
  %call7 = call <4 x float> @simde_mm_set_ps(float noundef 0x40747199A0000000, float noundef 0x40670CCCC0000000, float noundef 0x407B88A3E0000000, float noundef 0x4086E08F60000000)
  store <4 x float> %call7, ptr %b6, align 16, !tbaa !16
  %mask8 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element, i32 0, i32 2
  %call9 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 1)
  store <2 x i64> %call9, ptr %mask8, align 16, !tbaa !16
  %r10 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element, i32 0, i32 3
  %call11 = call <4 x float> @simde_mm_set_ps(float noundef 0xC071C6B860000000, float noundef 0x4085A1EB80000000, float noundef 0x4059766660000000, float noundef 0xC0899A3D80000000)
  store <4 x float> %call11, ptr %r10, align 16, !tbaa !16
  %arrayinit.element12 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element, i64 1
  %a13 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element12, i32 0, i32 0
  %call14 = call <4 x float> @simde_mm_set_ps(float noundef 0x4070826660000000, float noundef 0xC07E0CCCC0000000, float noundef 0xC073051EC0000000, float noundef 8.625000e+02)
  store <4 x float> %call14, ptr %a13, align 16, !tbaa !16
  %b15 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element12, i32 0, i32 1
  %call16 = call <4 x float> @simde_mm_set_ps(float noundef 0x406CD199A0000000, float noundef 0xC0844A3D80000000, float noundef 0x4089DB70A0000000, float noundef 0xC07CE999A0000000)
  store <4 x float> %call16, ptr %b15, align 16, !tbaa !16
  %mask17 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element12, i32 0, i32 2
  %call18 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0)
  store <2 x i64> %call18, ptr %mask17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element12, i32 0, i32 3
  %call20 = call <4 x float> @simde_mm_set_ps(float noundef 0x4070826660000000, float noundef 0xC07E0CCCC0000000, float noundef 0xC073051EC0000000, float noundef 8.625000e+02)
  store <4 x float> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element12, i64 1
  %a22 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <4 x float> @simde_mm_set_ps(float noundef 0x406D751EC0000000, float noundef 0x407DE28F60000000, float noundef 0x407E0947A0000000, float noundef 0xC04AC28F60000000)
  store <4 x float> %call23, ptr %a22, align 16, !tbaa !16
  %b24 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <4 x float> @simde_mm_set_ps(float noundef 0x408EB55C20000000, float noundef 0xC08824F5C0000000, float noundef 0xC062C33340000000, float noundef 0xC0870EE140000000)
  store <4 x float> %call25, ptr %b24, align 16, !tbaa !16
  %mask26 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element21, i32 0, i32 2
  %call27 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1, i32 noundef 1, i32 noundef 0, i32 noundef 0)
  store <2 x i64> %call27, ptr %mask26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element21, i32 0, i32 3
  %call29 = call <4 x float> @simde_mm_set_ps(float noundef 0x406D751EC0000000, float noundef 0x407DE28F60000000, float noundef 0x407E0947A0000000, float noundef 0xC04AC28F60000000)
  store <4 x float> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element21, i64 1
  %a31 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <4 x float> @simde_mm_set_ps(float noundef 0x405E6147A0000000, float noundef 0x4088F48F60000000, float noundef 0x40819F3340000000, float noundef 0x408A6B5C20000000)
  store <4 x float> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <4 x float> @simde_mm_set_ps(float noundef 0x40828B47A0000000, float noundef 0x40692DC280000000, float noundef 0xC070738520000000, float noundef 0x4044C147A0000000)
  store <4 x float> %call34, ptr %b33, align 16, !tbaa !16
  %mask35 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1, i32 noundef 1, i32 noundef 1, i32 noundef 0)
  store <2 x i64> %call36, ptr %mask35, align 16, !tbaa !16
  %r37 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element30, i32 0, i32 3
  %call38 = call <4 x float> @simde_mm_set_ps(float noundef 0x405E6147A0000000, float noundef 0x4088F48F60000000, float noundef 0x40819F3340000000, float noundef 0x408A6B5C20000000)
  store <4 x float> %call38, ptr %r37, align 16, !tbaa !16
  %arrayinit.element39 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element30, i64 1
  %a40 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element39, i32 0, i32 0
  %call41 = call <4 x float> @simde_mm_set_ps(float noundef 0xC08D56E140000000, float noundef 0xC067C33340000000, float noundef 0xC086C86660000000, float noundef 0x408DE1D700000000)
  store <4 x float> %call41, ptr %a40, align 16, !tbaa !16
  %b42 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element39, i32 0, i32 1
  %call43 = call <4 x float> @simde_mm_set_ps(float noundef 0x4081F7D700000000, float noundef 0xC054BAE140000000, float noundef 0x406EE23D80000000, float noundef 0xC0891370A0000000)
  store <4 x float> %call43, ptr %b42, align 16, !tbaa !16
  %mask44 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element39, i32 0, i32 2
  %call45 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 0, i32 noundef 1, i32 noundef 0, i32 noundef 0)
  store <2 x i64> %call45, ptr %mask44, align 16, !tbaa !16
  %r46 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element39, i32 0, i32 3
  %call47 = call <4 x float> @simde_mm_set_ps(float noundef 0xC08D56E140000000, float noundef 0xC067C33340000000, float noundef 0xC086C86660000000, float noundef 0x408DE1D700000000)
  store <4 x float> %call47, ptr %r46, align 16, !tbaa !16
  %arrayinit.element48 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element39, i64 1
  %a49 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element48, i32 0, i32 0
  %call50 = call <4 x float> @simde_mm_set_ps(float noundef 0xC082827AE0000000, float noundef 0xC05EFA3D80000000, float noundef 0x405A6AE140000000, float noundef 5.962500e+02)
  store <4 x float> %call50, ptr %a49, align 16, !tbaa !16
  %b51 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element48, i32 0, i32 1
  %call52 = call <4 x float> @simde_mm_set_ps(float noundef 0xC058D999A0000000, float noundef 0x4055947AE0000000, float noundef 0xC089DE8F60000000, float noundef 0x407BB051E0000000)
  store <4 x float> %call52, ptr %b51, align 16, !tbaa !16
  %mask53 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element48, i32 0, i32 2
  %call54 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1, i32 noundef 1, i32 noundef 1, i32 noundef 0)
  store <2 x i64> %call54, ptr %mask53, align 16, !tbaa !16
  %r55 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element48, i32 0, i32 3
  %call56 = call <4 x float> @simde_mm_set_ps(float noundef 0xC082827AE0000000, float noundef 0xC05EFA3D80000000, float noundef 0x405A6AE140000000, float noundef 5.962500e+02)
  store <4 x float> %call56, ptr %r55, align 16, !tbaa !16
  %arrayinit.element57 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element48, i64 1
  %a58 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element57, i32 0, i32 0
  %call59 = call <4 x float> @simde_mm_set_ps(float noundef 5.900000e+01, float noundef 0xC05757AE20000000, float noundef 0xC08D306660000000, float noundef 0x408D11AE20000000)
  store <4 x float> %call59, ptr %a58, align 16, !tbaa !16
  %b60 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element57, i32 0, i32 1
  %call61 = call <4 x float> @simde_mm_set_ps(float noundef 0xC082828F60000000, float noundef 0x407A44F5C0000000, float noundef 0xC06D6B8520000000, float noundef 0xC074FFAE20000000)
  store <4 x float> %call61, ptr %b60, align 16, !tbaa !16
  %mask62 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element57, i32 0, i32 2
  %call63 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1, i32 noundef 1, i32 noundef 1, i32 noundef 1)
  store <2 x i64> %call63, ptr %mask62, align 16, !tbaa !16
  %r64 = getelementptr inbounds %struct.anon.8, ptr %arrayinit.element57, i32 0, i32 3
  %call65 = call <4 x float> @simde_mm_set_ps(float noundef 5.900000e+01, float noundef 0xC05757AE20000000, float noundef 0xC08D306660000000, float noundef 0x408D11AE20000000)
  store <4 x float> %call65, ptr %r64, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup78

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r66) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.8], ptr %test_vec, i64 0, i64 %1
  %a67 = getelementptr inbounds %struct.anon.8, ptr %arrayidx, i32 0, i32 0
  %2 = load <4 x float>, ptr %a67, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx68 = getelementptr inbounds [8 x %struct.anon.8], ptr %test_vec, i64 0, i64 %3
  %b69 = getelementptr inbounds %struct.anon.8, ptr %arrayidx68, i32 0, i32 1
  %4 = load <4 x float>, ptr %b69, align 16, !tbaa !16
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx70 = getelementptr inbounds [8 x %struct.anon.8], ptr %test_vec, i64 0, i64 %5
  %mask71 = getelementptr inbounds %struct.anon.8, ptr %arrayidx70, i32 0, i32 2
  %6 = load <2 x i64>, ptr %mask71, align 16, !tbaa !16
  %call72 = call <4 x float> @simde_mm_castsi128_ps(<2 x i64> noundef %6)
  %call73 = call <4 x float> @simde_mm_blendv_ps(<4 x float> noundef %2, <4 x float> noundef %4, <4 x float> noundef %call72)
  store <4 x float> %call73, ptr %r66, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %7 = load <4 x float>, ptr %r66, align 16, !tbaa !16
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx74 = getelementptr inbounds [8 x %struct.anon.8], ptr %test_vec, i64 0, i64 %8
  %r75 = getelementptr inbounds %struct.anon.8, ptr %arrayidx74, i32 0, i32 3
  %9 = load <4 x float>, ptr %r75, align 16, !tbaa !16
  %call76 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call77 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %7, <4 x float> noundef %9, float noundef %call76, ptr noundef @.str.72, i32 noundef 597, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call77, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r66) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup78 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %10, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup78:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest79 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest79, label %cleanup80 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup78
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup80

cleanup80:                                        ; preds = %for.end, %cleanup78
  call void @llvm.lifetime.end.p0(i64 512, ptr %test_vec) #10
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_ceil_pd() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.9], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r36 = alloca <2 x double>, align 16
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.9], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.9, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x double> @simde_mm_set_pd(double noundef 2.413900e+02, double noundef 5.532600e+02)
  store <2 x double> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.9, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x double> @simde_mm_set_pd(double noundef 2.420000e+02, double noundef 5.540000e+02)
  store <2 x double> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.9, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x double> @simde_mm_set_pd(double noundef 3.078300e+02, double noundef 3.773700e+02)
  store <2 x double> %call3, ptr %a2, align 16, !tbaa !16
  %r4 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x double> @simde_mm_set_pd(double noundef 3.080000e+02, double noundef 3.780000e+02)
  store <2 x double> %call5, ptr %r4, align 16, !tbaa !16
  %arrayinit.element6 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element, i64 1
  %a7 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element6, i32 0, i32 0
  %call8 = call <2 x double> @simde_mm_set_pd(double noundef 5.581600e+02, double noundef -4.045500e+02)
  store <2 x double> %call8, ptr %a7, align 16, !tbaa !16
  %r9 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element6, i32 0, i32 1
  %call10 = call <2 x double> @simde_mm_set_pd(double noundef 5.590000e+02, double noundef -4.040000e+02)
  store <2 x double> %call10, ptr %r9, align 16, !tbaa !16
  %arrayinit.element11 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element6, i64 1
  %a12 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element11, i32 0, i32 0
  %call13 = call <2 x double> @simde_mm_set_pd(double noundef 2.191500e+02, double noundef 0x4089915C28F5C28F)
  store <2 x double> %call13, ptr %a12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element11, i32 0, i32 1
  %call15 = call <2 x double> @simde_mm_set_pd(double noundef 2.200000e+02, double noundef 8.190000e+02)
  store <2 x double> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element11, i64 1
  %a17 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x double> @simde_mm_set_pd(double noundef 2.583000e+01, double noundef -2.309400e+02)
  store <2 x double> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x double> @simde_mm_set_pd(double noundef 2.600000e+01, double noundef -2.300000e+02)
  store <2 x double> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element16, i64 1
  %a22 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x double> @simde_mm_set_pd(double noundef 1.735200e+02, double noundef 6.450000e+01)
  store <2 x double> %call23, ptr %a22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x double> @simde_mm_set_pd(double noundef 1.740000e+02, double noundef 6.500000e+01)
  store <2 x double> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element21, i64 1
  %a27 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <2 x double> @simde_mm_set_pd(double noundef -4.531100e+02, double noundef -8.457700e+02)
  store <2 x double> %call28, ptr %a27, align 16, !tbaa !16
  %r29 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <2 x double> @simde_mm_set_pd(double noundef -4.530000e+02, double noundef -8.450000e+02)
  store <2 x double> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element26, i64 1
  %a32 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x double> @simde_mm_set_pd(double noundef -5.098000e+01, double noundef -1.795500e+02)
  store <2 x double> %call33, ptr %a32, align 16, !tbaa !16
  %r34 = getelementptr inbounds %struct.anon.9, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x double> @simde_mm_set_pd(double noundef -5.000000e+01, double noundef -1.790000e+02)
  store <2 x double> %call35, ptr %r34, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup43

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r36) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.9], ptr %test_vec, i64 0, i64 %1
  %a37 = getelementptr inbounds %struct.anon.9, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x double>, ptr %a37, align 16, !tbaa !16
  %call38 = call <2 x double> @simde_mm_ceil_pd(<2 x double> noundef %2)
  store <2 x double> %call38, ptr %r36, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <2 x double>, ptr %r36, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx39 = getelementptr inbounds [8 x %struct.anon.9], ptr %test_vec, i64 0, i64 %4
  %r40 = getelementptr inbounds %struct.anon.9, ptr %arrayidx39, i32 0, i32 1
  %5 = load <2 x double>, ptr %r40, align 16, !tbaa !16
  %call41 = call double @simde_test_f64_precision_to_slop(i32 noundef 1)
  %call42 = call i32 @simde_test_x86_assert_equal_f64x2_(<2 x double> noundef %3, <2 x double> noundef %5, double noundef %call41, ptr noundef @.str.72, i32 noundef 629, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call42, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r36) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup43 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup43:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest44 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest44, label %cleanup45 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup43
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup45

cleanup45:                                        ; preds = %for.end, %cleanup43
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_ceil_ps() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.10], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r36 = alloca <4 x float>, align 16
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.10], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.10, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <4 x float> @simde_mm_set_ps(float noundef 0xC083878520000000, float noundef -2.432500e+02, float noundef 0xC04ED0A3E0000000, float noundef 0xC08DA5D700000000)
  store <4 x float> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.10, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <4 x float> @simde_mm_set_ps(float noundef -6.240000e+02, float noundef -2.430000e+02, float noundef -6.100000e+01, float noundef -9.480000e+02)
  store <4 x float> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.10, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <4 x float> @simde_mm_set_ps(float noundef 0xC08C550A40000000, float noundef 0xC06D8D70A0000000, float noundef 0x4081DC1480000000, float noundef 0x408384F5C0000000)
  store <4 x float> %call3, ptr %a2, align 16, !tbaa !16
  %r4 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <4 x float> @simde_mm_set_ps(float noundef -9.060000e+02, float noundef -2.360000e+02, float noundef 5.720000e+02, float noundef 6.250000e+02)
  store <4 x float> %call5, ptr %r4, align 16, !tbaa !16
  %arrayinit.element6 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element, i64 1
  %a7 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element6, i32 0, i32 0
  %call8 = call <4 x float> @simde_mm_set_ps(float noundef 0x407F7D99A0000000, float noundef 0xC073D82900000000, float noundef 0xC0808A6660000000, float noundef 0xC08B3F1EC0000000)
  store <4 x float> %call8, ptr %a7, align 16, !tbaa !16
  %r9 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element6, i32 0, i32 1
  %call10 = call <4 x float> @simde_mm_set_ps(float noundef 5.040000e+02, float noundef -3.170000e+02, float noundef -5.290000e+02, float noundef -8.710000e+02)
  store <4 x float> %call10, ptr %r9, align 16, !tbaa !16
  %arrayinit.element11 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element6, i64 1
  %a12 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element11, i32 0, i32 0
  %call13 = call <4 x float> @simde_mm_set_ps(float noundef 0x4081DBEB80000000, float noundef 0xC06038A3E0000000, float noundef 0xC0871DAE20000000, float noundef 0x4079D2E140000000)
  store <4 x float> %call13, ptr %a12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element11, i32 0, i32 1
  %call15 = call <4 x float> @simde_mm_set_ps(float noundef 5.720000e+02, float noundef -1.290000e+02, float noundef -7.390000e+02, float noundef 4.140000e+02)
  store <4 x float> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element11, i64 1
  %a17 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <4 x float> @simde_mm_set_ps(float noundef 0x407B6599A0000000, float noundef 0x4080283D80000000, float noundef 0x4071675C20000000, float noundef 0xC08482E140000000)
  store <4 x float> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <4 x float> @simde_mm_set_ps(float noundef 4.390000e+02, float noundef 5.180000e+02, float noundef 2.790000e+02, float noundef -6.560000e+02)
  store <4 x float> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element16, i64 1
  %a22 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <4 x float> @simde_mm_set_ps(float noundef 0xC063ECCCC0000000, float noundef 0xC089168F60000000, float noundef 0x4084BDAE20000000, float noundef 0x40675B8520000000)
  store <4 x float> %call23, ptr %a22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <4 x float> @simde_mm_set_ps(float noundef -1.590000e+02, float noundef -8.020000e+02, float noundef 6.640000e+02, float noundef 1.870000e+02)
  store <4 x float> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element21, i64 1
  %a27 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <4 x float> @simde_mm_set_ps(float noundef 0xC06477AE20000000, float noundef 0x407E58A3E0000000, float noundef 0x40614570A0000000, float noundef 0x4088D55C20000000)
  store <4 x float> %call28, ptr %a27, align 16, !tbaa !16
  %r29 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <4 x float> @simde_mm_set_ps(float noundef -1.630000e+02, float noundef 4.860000e+02, float noundef 1.390000e+02, float noundef 7.950000e+02)
  store <4 x float> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element26, i64 1
  %a32 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <4 x float> @simde_mm_set_ps(float noundef 0xC07D55C280000000, float noundef 0xC07A23D700000000, float noundef -4.192500e+02, float noundef 0x4078675C20000000)
  store <4 x float> %call33, ptr %a32, align 16, !tbaa !16
  %r34 = getelementptr inbounds %struct.anon.10, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <4 x float> @simde_mm_set_ps(float noundef -4.690000e+02, float noundef -4.180000e+02, float noundef -4.190000e+02, float noundef 3.910000e+02)
  store <4 x float> %call35, ptr %r34, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup43

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r36) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.10], ptr %test_vec, i64 0, i64 %1
  %a37 = getelementptr inbounds %struct.anon.10, ptr %arrayidx, i32 0, i32 0
  %2 = load <4 x float>, ptr %a37, align 16, !tbaa !16
  %call38 = call <4 x float> @simde_mm_ceil_ps(<4 x float> noundef %2)
  store <4 x float> %call38, ptr %r36, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <4 x float>, ptr %r36, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx39 = getelementptr inbounds [8 x %struct.anon.10], ptr %test_vec, i64 0, i64 %4
  %r40 = getelementptr inbounds %struct.anon.10, ptr %arrayidx39, i32 0, i32 1
  %5 = load <4 x float>, ptr %r40, align 16, !tbaa !16
  %call41 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call42 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %3, <4 x float> noundef %5, float noundef %call41, ptr noundef @.str.72, i32 noundef 661, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call42, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r36) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup43 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup43:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest44 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest44, label %cleanup45 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup43
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup45

cleanup45:                                        ; preds = %for.end, %cleanup43
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_ceil_sd() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.11], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <2 x double>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.11], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.11, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x double> @simde_mm_set_pd(double noundef 0xC0831170A3D70A3D, double noundef 1.722100e+02)
  store <2 x double> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.11, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x double> @simde_mm_set_pd(double noundef 2.344000e+02, double noundef -3.398400e+02)
  store <2 x double> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.11, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x double> @simde_mm_set_pd(double noundef 0xC0831170A3D70A3D, double noundef -3.390000e+02)
  store <2 x double> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.11, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x double> @simde_mm_set_pd(double noundef -4.675200e+02, double noundef 0x408C463D70A3D70A)
  store <2 x double> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x double> @simde_mm_set_pd(double noundef -5.273900e+02, double noundef -1.156300e+02)
  store <2 x double> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <2 x double> @simde_mm_set_pd(double noundef -4.675200e+02, double noundef -1.150000e+02)
  store <2 x double> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <2 x double> @simde_mm_set_pd(double noundef 1.912400e+02, double noundef 0x4089BE3D70A3D70A)
  store <2 x double> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <2 x double> @simde_mm_set_pd(double noundef 8.352700e+02, double noundef 7.448100e+02)
  store <2 x double> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <2 x double> @simde_mm_set_pd(double noundef 1.912400e+02, double noundef 7.450000e+02)
  store <2 x double> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x double> @simde_mm_set_pd(double noundef -4.925000e+01, double noundef -6.959500e+02)
  store <2 x double> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x double> @simde_mm_set_pd(double noundef 8.006200e+02, double noundef 8.538400e+02)
  store <2 x double> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <2 x double> @simde_mm_set_pd(double noundef -4.925000e+01, double noundef 8.540000e+02)
  store <2 x double> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <2 x double> @simde_mm_set_pd(double noundef 6.688300e+02, double noundef -1.827300e+02)
  store <2 x double> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <2 x double> @simde_mm_set_pd(double noundef -8.754600e+02, double noundef 7.521000e+02)
  store <2 x double> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <2 x double> @simde_mm_set_pd(double noundef 6.688300e+02, double noundef 7.530000e+02)
  store <2 x double> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x double> @simde_mm_set_pd(double noundef 2.425700e+02, double noundef -9.060000e+02)
  store <2 x double> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x double> @simde_mm_set_pd(double noundef -8.162200e+02, double noundef 3.390300e+02)
  store <2 x double> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x double> @simde_mm_set_pd(double noundef 2.425700e+02, double noundef 3.400000e+02)
  store <2 x double> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x double> @simde_mm_set_pd(double noundef 0xC087493333333333, double noundef 0xC0874051EB851EB8)
  store <2 x double> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x double> @simde_mm_set_pd(double noundef -8.028100e+02, double noundef 0x408BD651EB851EB8)
  store <2 x double> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <2 x double> @simde_mm_set_pd(double noundef 0xC087493333333333, double noundef 8.910000e+02)
  store <2 x double> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <2 x double> @simde_mm_set_pd(double noundef 2.384800e+02, double noundef -1.672800e+02)
  store <2 x double> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <2 x double> @simde_mm_set_pd(double noundef -4.845100e+02, double noundef 1.759500e+02)
  store <2 x double> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.11, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <2 x double> @simde_mm_set_pd(double noundef 2.384800e+02, double noundef 1.760000e+02)
  store <2 x double> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup60

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.11], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.11, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x double>, ptr %a52, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx53 = getelementptr inbounds [8 x %struct.anon.11], ptr %test_vec, i64 0, i64 %3
  %b54 = getelementptr inbounds %struct.anon.11, ptr %arrayidx53, i32 0, i32 1
  %4 = load <2 x double>, ptr %b54, align 16, !tbaa !16
  %call55 = call <2 x double> @simde_mm_ceil_sd(<2 x double> noundef %2, <2 x double> noundef %4)
  store <2 x double> %call55, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x double>, ptr %r51, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx56 = getelementptr inbounds [8 x %struct.anon.11], ptr %test_vec, i64 0, i64 %6
  %r57 = getelementptr inbounds %struct.anon.11, ptr %arrayidx56, i32 0, i32 2
  %7 = load <2 x double>, ptr %r57, align 16, !tbaa !16
  %call58 = call double @simde_test_f64_precision_to_slop(i32 noundef 1)
  %call59 = call i32 @simde_test_x86_assert_equal_f64x2_(<2 x double> noundef %5, <2 x double> noundef %7, double noundef %call58, ptr noundef @.str.72, i32 noundef 702, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call59, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup60 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup60:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest61 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest61, label %cleanup62 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup60
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup62

cleanup62:                                        ; preds = %for.end, %cleanup60
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_ceil_ss() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.12], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <4 x float>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.12], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.12, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <4 x float> @simde_mm_set_ps(float noundef 0xC05F1CCCC0000000, float noundef 0x408C78F5C0000000, float noundef 0x408C242900000000, float noundef 0xC07D4EB860000000)
  store <4 x float> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.12, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <4 x float> @simde_mm_set_ps(float noundef 0xC03F8F5C20000000, float noundef 0xC03DC28F60000000, float noundef 0xC08D5ACCC0000000, float noundef 0x407CBB5C20000000)
  store <4 x float> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.12, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <4 x float> @simde_mm_set_ps(float noundef 0xC05F1CCCC0000000, float noundef 0x408C78F5C0000000, float noundef 0x408C242900000000, float noundef 4.600000e+02)
  store <4 x float> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.12, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <4 x float> @simde_mm_set_ps(float noundef 0x408011C280000000, float noundef 0xC08E638520000000, float noundef 0xC08C661480000000, float noundef 0xC0898C2900000000)
  store <4 x float> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <4 x float> @simde_mm_set_ps(float noundef 0xC0863E3D80000000, float noundef 0x407E99EB80000000, float noundef 0xC05B6147A0000000, float noundef 0xC000147AE0000000)
  store <4 x float> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <4 x float> @simde_mm_set_ps(float noundef 0x408011C280000000, float noundef 0xC08E638520000000, float noundef 0xC08C661480000000, float noundef -2.000000e+00)
  store <4 x float> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <4 x float> @simde_mm_set_ps(float noundef 0xC070DE1480000000, float noundef 0xC08B5ECCC0000000, float noundef 0xC06168A3E0000000, float noundef 0xC08A4C7AE0000000)
  store <4 x float> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <4 x float> @simde_mm_set_ps(float noundef 0x407F50CCC0000000, float noundef 0x407186E140000000, float noundef 0xC065BD1EC0000000, float noundef 0x4084235C20000000)
  store <4 x float> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <4 x float> @simde_mm_set_ps(float noundef 0xC070DE1480000000, float noundef 0xC08B5ECCC0000000, float noundef 0xC06168A3E0000000, float noundef 6.450000e+02)
  store <4 x float> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <4 x float> @simde_mm_set_ps(float noundef 0xC0841A1480000000, float noundef 0x408343D700000000, float noundef 0x408A1A3D80000000, float noundef 0x40807C2900000000)
  store <4 x float> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <4 x float> @simde_mm_set_ps(float noundef 0x4083E3D700000000, float noundef 0xC04747AE20000000, float noundef 0xC08BDEB860000000, float noundef 0x408DA370A0000000)
  store <4 x float> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <4 x float> @simde_mm_set_ps(float noundef 0xC0841A1480000000, float noundef 0x408343D700000000, float noundef 0x408A1A3D80000000, float noundef 9.490000e+02)
  store <4 x float> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <4 x float> @simde_mm_set_ps(float noundef 0x40090A3D80000000, float noundef 0xC08472E140000000, float noundef 0xC08F17D700000000, float noundef 0xC0629E6660000000)
  store <4 x float> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <4 x float> @simde_mm_set_ps(float noundef 0x4089313340000000, float noundef 0x40808A51E0000000, float noundef 0xC089235C20000000, float noundef 0x4079830A40000000)
  store <4 x float> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <4 x float> @simde_mm_set_ps(float noundef 0x40090A3D80000000, float noundef 0xC08472E140000000, float noundef 0xC08F17D700000000, float noundef 4.090000e+02)
  store <4 x float> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <4 x float> @simde_mm_set_ps(float noundef 0xC06145C280000000, float noundef 0xC07BE7AE20000000, float noundef 0xC079DF3340000000, float noundef 0xC06F8999A0000000)
  store <4 x float> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <4 x float> @simde_mm_set_ps(float noundef 0x408DED70A0000000, float noundef 0x40775599A0000000, float noundef 0x4070FFAE20000000, float noundef 0xC0846F70A0000000)
  store <4 x float> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <4 x float> @simde_mm_set_ps(float noundef 0xC06145C280000000, float noundef 0xC07BE7AE20000000, float noundef 0xC079DF3340000000, float noundef -6.530000e+02)
  store <4 x float> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <4 x float> @simde_mm_set_ps(float noundef 0x405F1999A0000000, float noundef 0xC08B1547A0000000, float noundef 0x4072091EC0000000, float noundef 0xC08623AE20000000)
  store <4 x float> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <4 x float> @simde_mm_set_ps(float noundef 0x4085691EC0000000, float noundef 7.760000e+02, float noundef 0x407C58F5C0000000, float noundef 0xC05C33D700000000)
  store <4 x float> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <4 x float> @simde_mm_set_ps(float noundef 0x405F1999A0000000, float noundef 0xC08B1547A0000000, float noundef 0x4072091EC0000000, float noundef -1.120000e+02)
  store <4 x float> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <4 x float> @simde_mm_set_ps(float noundef -2.327500e+02, float noundef 0xC0613199A0000000, float noundef 0x40492147A0000000, float noundef 0xC067B6B860000000)
  store <4 x float> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <4 x float> @simde_mm_set_ps(float noundef 0xC0720AB860000000, float noundef 0xC05C3CCCC0000000, float noundef 0x4088C3C280000000, float noundef 0xC06908A3E0000000)
  store <4 x float> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.12, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <4 x float> @simde_mm_set_ps(float noundef -2.327500e+02, float noundef 0xC0613199A0000000, float noundef 0x40492147A0000000, float noundef -2.000000e+02)
  store <4 x float> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup60

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.12], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.12, ptr %arrayidx, i32 0, i32 0
  %2 = load <4 x float>, ptr %a52, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx53 = getelementptr inbounds [8 x %struct.anon.12], ptr %test_vec, i64 0, i64 %3
  %b54 = getelementptr inbounds %struct.anon.12, ptr %arrayidx53, i32 0, i32 1
  %4 = load <4 x float>, ptr %b54, align 16, !tbaa !16
  %call55 = call <4 x float> @simde_mm_ceil_ss(<4 x float> noundef %2, <4 x float> noundef %4)
  store <4 x float> %call55, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <4 x float>, ptr %r51, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx56 = getelementptr inbounds [8 x %struct.anon.12], ptr %test_vec, i64 0, i64 %6
  %r57 = getelementptr inbounds %struct.anon.12, ptr %arrayidx56, i32 0, i32 2
  %7 = load <4 x float>, ptr %r57, align 16, !tbaa !16
  %call58 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call59 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %5, <4 x float> noundef %7, float noundef %call58, ptr noundef @.str.72, i32 noundef 743, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call59, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup60 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup60:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest61 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest61, label %cleanup62 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup60
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup62

cleanup62:                                        ; preds = %for.end, %cleanup60
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_cmpeq_epi64() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.13], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.13], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.13, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef -5177034516057011466, i64 noundef 5229646237911669536)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.13, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef -5177034516057011466, i64 noundef 5229646237911669536)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.13, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef -1, i64 noundef -1)
  store <2 x i64> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.13, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef -4407008241172347879, i64 noundef -381329487337966458)
  store <2 x i64> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 7896134184979754273, i64 noundef -381329487337966458)
  store <2 x i64> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 0, i64 noundef -1)
  store <2 x i64> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 8088434365645432882, i64 noundef 2110149590601129498)
  store <2 x i64> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef -5552435934851412680, i64 noundef 7645444803376971084)
  store <2 x i64> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 0, i64 noundef 0)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 6900998750312547586, i64 noundef -7331078247542744741)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 253910074237567150, i64 noundef -7331078247542744741)
  store <2 x i64> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 0, i64 noundef -1)
  store <2 x i64> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef -2932796482172033299, i64 noundef 6346622963553980783)
  store <2 x i64> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 1894817647097843127, i64 noundef 9019647896255166506)
  store <2 x i64> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 0, i64 noundef 0)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 189073800069710221, i64 noundef 5830713182261233236)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef 189073800069710221, i64 noundef 8422068610497871432)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef -1, i64 noundef 0)
  store <2 x i64> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef -1330914404980339230, i64 noundef -7288517408682976495)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef -1330914404980339230, i64 noundef -7288517408682976495)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef -1, i64 noundef -1)
  store <2 x i64> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef -8902856774418471570, i64 noundef -3532746838777859745)
  store <2 x i64> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef -8902856774418471570, i64 noundef -5961095087551504783)
  store <2 x i64> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.13, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <2 x i64> @simde_x_mm_set_epu64x(i64 noundef -1, i64 noundef 0)
  store <2 x i64> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup59

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.13], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.13, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a52, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx53 = getelementptr inbounds [8 x %struct.anon.13], ptr %test_vec, i64 0, i64 %3
  %b54 = getelementptr inbounds %struct.anon.13, ptr %arrayidx53, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b54, align 16, !tbaa !16
  %call55 = call <2 x i64> @simde_mm_cmpeq_epi64(<2 x i64> noundef %2, <2 x i64> noundef %4)
  store <2 x i64> %call55, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r51, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx56 = getelementptr inbounds [8 x %struct.anon.13], ptr %test_vec, i64 0, i64 %6
  %r57 = getelementptr inbounds %struct.anon.13, ptr %arrayidx56, i32 0, i32 2
  %7 = load <2 x i64>, ptr %r57, align 16, !tbaa !16
  %call58 = call i32 @simde_test_x86_assert_equal_i64x2_(<2 x i64> noundef %5, <2 x i64> noundef %7, ptr noundef @.str.72, i32 noundef 784, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call58, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup59 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup59:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest60 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest60, label %cleanup61 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup59
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup61

cleanup61:                                        ; preds = %for.end, %cleanup59
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_cvtepi8_epi16() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.14], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r36 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.14], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.14, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -34, i8 noundef signext 20, i8 noundef signext 53, i8 noundef signext 81, i8 noundef signext 37, i8 noundef signext -97, i8 noundef signext -59, i8 noundef signext 127, i8 noundef signext -43, i8 noundef signext -82, i8 noundef signext 84, i8 noundef signext -127, i8 noundef signext 11, i8 noundef signext 120, i8 noundef signext -98, i8 noundef signext -80)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.14, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -43, i16 noundef signext -82, i16 noundef signext 84, i16 noundef signext -127, i16 noundef signext 11, i16 noundef signext 120, i16 noundef signext -98, i16 noundef signext -80)
  store <2 x i64> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.14, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 66, i8 noundef signext 57, i8 noundef signext 40, i8 noundef signext -113, i8 noundef signext 71, i8 noundef signext -5, i8 noundef signext 70, i8 noundef signext 22, i8 noundef signext -70, i8 noundef signext 14, i8 noundef signext -76, i8 noundef signext -101, i8 noundef signext 13, i8 noundef signext 64, i8 noundef signext -86, i8 noundef signext 34)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %r4 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -70, i16 noundef signext 14, i16 noundef signext -76, i16 noundef signext -101, i16 noundef signext 13, i16 noundef signext 64, i16 noundef signext -86, i16 noundef signext 34)
  store <2 x i64> %call5, ptr %r4, align 16, !tbaa !16
  %arrayinit.element6 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element, i64 1
  %a7 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element6, i32 0, i32 0
  %call8 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 87, i8 noundef signext 115, i8 noundef signext 108, i8 noundef signext -88, i8 noundef signext 113, i8 noundef signext 91, i8 noundef signext -95, i8 noundef signext -69, i8 noundef signext 32, i8 noundef signext 98, i8 noundef signext -16, i8 noundef signext -55, i8 noundef signext 11, i8 noundef signext -23, i8 noundef signext 72, i8 noundef signext 121)
  store <2 x i64> %call8, ptr %a7, align 16, !tbaa !16
  %r9 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element6, i32 0, i32 1
  %call10 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 32, i16 noundef signext 98, i16 noundef signext -16, i16 noundef signext -55, i16 noundef signext 11, i16 noundef signext -23, i16 noundef signext 72, i16 noundef signext 121)
  store <2 x i64> %call10, ptr %r9, align 16, !tbaa !16
  %arrayinit.element11 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element6, i64 1
  %a12 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element11, i32 0, i32 0
  %call13 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 88, i8 noundef signext 68, i8 noundef signext -76, i8 noundef signext 35, i8 noundef signext -119, i8 noundef signext -67, i8 noundef signext 52, i8 noundef signext 58, i8 noundef signext 7, i8 noundef signext 70, i8 noundef signext -26, i8 noundef signext 55, i8 noundef signext 126, i8 noundef signext 69, i8 noundef signext 105, i8 noundef signext 40)
  store <2 x i64> %call13, ptr %a12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element11, i32 0, i32 1
  %call15 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 7, i16 noundef signext 70, i16 noundef signext -26, i16 noundef signext 55, i16 noundef signext 126, i16 noundef signext 69, i16 noundef signext 105, i16 noundef signext 40)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element11, i64 1
  %a17 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 110, i8 noundef signext -4, i8 noundef signext 41, i8 noundef signext -98, i8 noundef signext -91, i8 noundef signext 117, i8 noundef signext -33, i8 noundef signext -110, i8 noundef signext 126, i8 noundef signext -63, i8 noundef signext -65, i8 noundef signext -86, i8 noundef signext -108, i8 noundef signext -64, i8 noundef signext -4, i8 noundef signext 25)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 126, i16 noundef signext -63, i16 noundef signext -65, i16 noundef signext -86, i16 noundef signext -108, i16 noundef signext -64, i16 noundef signext -4, i16 noundef signext 25)
  store <2 x i64> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element16, i64 1
  %a22 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 105, i8 noundef signext -31, i8 noundef signext -57, i8 noundef signext -74, i8 noundef signext 119, i8 noundef signext 56, i8 noundef signext -36, i8 noundef signext -128, i8 noundef signext 102, i8 noundef signext 57, i8 noundef signext -27, i8 noundef signext 19, i8 noundef signext -50, i8 noundef signext -15, i8 noundef signext 36, i8 noundef signext -124)
  store <2 x i64> %call23, ptr %a22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 102, i16 noundef signext 57, i16 noundef signext -27, i16 noundef signext 19, i16 noundef signext -50, i16 noundef signext -15, i16 noundef signext 36, i16 noundef signext -124)
  store <2 x i64> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element21, i64 1
  %a27 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 44, i8 noundef signext -84, i8 noundef signext -61, i8 noundef signext 59, i8 noundef signext 18, i8 noundef signext -118, i8 noundef signext 6, i8 noundef signext 56, i8 noundef signext -11, i8 noundef signext 78, i8 noundef signext -64, i8 noundef signext -28, i8 noundef signext -85, i8 noundef signext -77, i8 noundef signext -25, i8 noundef signext -100)
  store <2 x i64> %call28, ptr %a27, align 16, !tbaa !16
  %r29 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -11, i16 noundef signext 78, i16 noundef signext -64, i16 noundef signext -28, i16 noundef signext -85, i16 noundef signext -77, i16 noundef signext -25, i16 noundef signext -100)
  store <2 x i64> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element26, i64 1
  %a32 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -13, i8 noundef signext -24, i8 noundef signext 94, i8 noundef signext 58, i8 noundef signext 1, i8 noundef signext -14, i8 noundef signext -90, i8 noundef signext -123, i8 noundef signext -101, i8 noundef signext 71, i8 noundef signext -51, i8 noundef signext 87, i8 noundef signext -34, i8 noundef signext 77, i8 noundef signext 124, i8 noundef signext -63)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %r34 = getelementptr inbounds %struct.anon.14, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -101, i16 noundef signext 71, i16 noundef signext -51, i16 noundef signext 87, i16 noundef signext -34, i16 noundef signext 77, i16 noundef signext 124, i16 noundef signext -63)
  store <2 x i64> %call35, ptr %r34, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup42

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r36) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.14], ptr %test_vec, i64 0, i64 %1
  %a37 = getelementptr inbounds %struct.anon.14, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a37, align 16, !tbaa !16
  %call38 = call <2 x i64> @simde_mm_cvtepi8_epi16(<2 x i64> noundef %2)
  store <2 x i64> %call38, ptr %r36, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <2 x i64>, ptr %r36, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx39 = getelementptr inbounds [8 x %struct.anon.14], ptr %test_vec, i64 0, i64 %4
  %r40 = getelementptr inbounds %struct.anon.14, ptr %arrayidx39, i32 0, i32 1
  %5 = load <2 x i64>, ptr %r40, align 16, !tbaa !16
  %call41 = call i32 @simde_test_x86_assert_equal_i16x8_(<2 x i64> noundef %3, <2 x i64> noundef %5, ptr noundef @.str.72, i32 noundef 952, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call41, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r36) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup42 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup42:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest43 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest43, label %cleanup44 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup42
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup44

cleanup44:                                        ; preds = %for.end, %cleanup42
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_cvtepi8_epi32() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.15], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r36 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.15], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.15, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -34, i8 noundef signext 20, i8 noundef signext 53, i8 noundef signext 81, i8 noundef signext 37, i8 noundef signext -97, i8 noundef signext -59, i8 noundef signext 127, i8 noundef signext -43, i8 noundef signext -82, i8 noundef signext 84, i8 noundef signext -127, i8 noundef signext 11, i8 noundef signext 120, i8 noundef signext -98, i8 noundef signext -80)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.15, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 11, i32 noundef 120, i32 noundef -98, i32 noundef -80)
  store <2 x i64> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.15, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 66, i8 noundef signext 57, i8 noundef signext 40, i8 noundef signext -113, i8 noundef signext 71, i8 noundef signext -5, i8 noundef signext 70, i8 noundef signext 22, i8 noundef signext -70, i8 noundef signext 14, i8 noundef signext -76, i8 noundef signext -101, i8 noundef signext 13, i8 noundef signext 64, i8 noundef signext -86, i8 noundef signext 34)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %r4 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 13, i32 noundef 64, i32 noundef -86, i32 noundef 34)
  store <2 x i64> %call5, ptr %r4, align 16, !tbaa !16
  %arrayinit.element6 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element, i64 1
  %a7 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element6, i32 0, i32 0
  %call8 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 87, i8 noundef signext 115, i8 noundef signext 108, i8 noundef signext -88, i8 noundef signext 113, i8 noundef signext 91, i8 noundef signext -95, i8 noundef signext -69, i8 noundef signext 32, i8 noundef signext 98, i8 noundef signext -16, i8 noundef signext -55, i8 noundef signext 11, i8 noundef signext -23, i8 noundef signext 72, i8 noundef signext 121)
  store <2 x i64> %call8, ptr %a7, align 16, !tbaa !16
  %r9 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element6, i32 0, i32 1
  %call10 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 11, i32 noundef -23, i32 noundef 72, i32 noundef 121)
  store <2 x i64> %call10, ptr %r9, align 16, !tbaa !16
  %arrayinit.element11 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element6, i64 1
  %a12 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element11, i32 0, i32 0
  %call13 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 88, i8 noundef signext 68, i8 noundef signext -76, i8 noundef signext 35, i8 noundef signext -119, i8 noundef signext -67, i8 noundef signext 52, i8 noundef signext 58, i8 noundef signext 7, i8 noundef signext 70, i8 noundef signext -26, i8 noundef signext 55, i8 noundef signext 126, i8 noundef signext 69, i8 noundef signext 105, i8 noundef signext 40)
  store <2 x i64> %call13, ptr %a12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element11, i32 0, i32 1
  %call15 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 126, i32 noundef 69, i32 noundef 105, i32 noundef 40)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element11, i64 1
  %a17 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 110, i8 noundef signext -4, i8 noundef signext 41, i8 noundef signext -98, i8 noundef signext -91, i8 noundef signext 117, i8 noundef signext -33, i8 noundef signext -110, i8 noundef signext 126, i8 noundef signext -63, i8 noundef signext -65, i8 noundef signext -86, i8 noundef signext -108, i8 noundef signext -64, i8 noundef signext -4, i8 noundef signext 25)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -108, i32 noundef -64, i32 noundef -4, i32 noundef 25)
  store <2 x i64> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element16, i64 1
  %a22 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 105, i8 noundef signext -31, i8 noundef signext -57, i8 noundef signext -74, i8 noundef signext 119, i8 noundef signext 56, i8 noundef signext -36, i8 noundef signext -128, i8 noundef signext 102, i8 noundef signext 57, i8 noundef signext -27, i8 noundef signext 19, i8 noundef signext -50, i8 noundef signext -15, i8 noundef signext 36, i8 noundef signext -124)
  store <2 x i64> %call23, ptr %a22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -50, i32 noundef -15, i32 noundef 36, i32 noundef -124)
  store <2 x i64> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element21, i64 1
  %a27 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 44, i8 noundef signext -84, i8 noundef signext -61, i8 noundef signext 59, i8 noundef signext 18, i8 noundef signext -118, i8 noundef signext 6, i8 noundef signext 56, i8 noundef signext -11, i8 noundef signext 78, i8 noundef signext -64, i8 noundef signext -28, i8 noundef signext -85, i8 noundef signext -77, i8 noundef signext -25, i8 noundef signext -100)
  store <2 x i64> %call28, ptr %a27, align 16, !tbaa !16
  %r29 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -85, i32 noundef -77, i32 noundef -25, i32 noundef -100)
  store <2 x i64> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element26, i64 1
  %a32 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -13, i8 noundef signext -24, i8 noundef signext 94, i8 noundef signext 58, i8 noundef signext 1, i8 noundef signext -14, i8 noundef signext -90, i8 noundef signext -123, i8 noundef signext -101, i8 noundef signext 71, i8 noundef signext -51, i8 noundef signext 87, i8 noundef signext -34, i8 noundef signext 77, i8 noundef signext 124, i8 noundef signext -63)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %r34 = getelementptr inbounds %struct.anon.15, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -34, i32 noundef 77, i32 noundef 124, i32 noundef -63)
  store <2 x i64> %call35, ptr %r34, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup42

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r36) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.15], ptr %test_vec, i64 0, i64 %1
  %a37 = getelementptr inbounds %struct.anon.15, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a37, align 16, !tbaa !16
  %call38 = call <2 x i64> @simde_mm_cvtepi8_epi32(<2 x i64> noundef %2)
  store <2 x i64> %call38, ptr %r36, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <2 x i64>, ptr %r36, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx39 = getelementptr inbounds [8 x %struct.anon.15], ptr %test_vec, i64 0, i64 %4
  %r40 = getelementptr inbounds %struct.anon.15, ptr %arrayidx39, i32 0, i32 1
  %5 = load <2 x i64>, ptr %r40, align 16, !tbaa !16
  %call41 = call i32 @simde_test_x86_assert_equal_i32x4_(<2 x i64> noundef %3, <2 x i64> noundef %5, ptr noundef @.str.72, i32 noundef 1008, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call41, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r36) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup42 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup42:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest43 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest43, label %cleanup44 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup42
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup44

cleanup44:                                        ; preds = %for.end, %cleanup42
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_cvtepi8_epi64() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.16], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r36 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.16], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.16, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -34, i8 noundef signext 20, i8 noundef signext 53, i8 noundef signext 81, i8 noundef signext 37, i8 noundef signext -97, i8 noundef signext -59, i8 noundef signext 127, i8 noundef signext -43, i8 noundef signext -82, i8 noundef signext 84, i8 noundef signext -127, i8 noundef signext 11, i8 noundef signext 120, i8 noundef signext -98, i8 noundef signext -80)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.16, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -98, i64 noundef -80)
  store <2 x i64> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.16, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 66, i8 noundef signext 57, i8 noundef signext 40, i8 noundef signext -113, i8 noundef signext 71, i8 noundef signext -5, i8 noundef signext 70, i8 noundef signext 22, i8 noundef signext -70, i8 noundef signext 14, i8 noundef signext -76, i8 noundef signext -101, i8 noundef signext 13, i8 noundef signext 64, i8 noundef signext -86, i8 noundef signext 34)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %r4 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -86, i64 noundef 34)
  store <2 x i64> %call5, ptr %r4, align 16, !tbaa !16
  %arrayinit.element6 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element, i64 1
  %a7 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element6, i32 0, i32 0
  %call8 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 87, i8 noundef signext 115, i8 noundef signext 108, i8 noundef signext -88, i8 noundef signext 113, i8 noundef signext 91, i8 noundef signext -95, i8 noundef signext -69, i8 noundef signext 32, i8 noundef signext 98, i8 noundef signext -16, i8 noundef signext -55, i8 noundef signext 11, i8 noundef signext -23, i8 noundef signext 72, i8 noundef signext 121)
  store <2 x i64> %call8, ptr %a7, align 16, !tbaa !16
  %r9 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element6, i32 0, i32 1
  %call10 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 72, i64 noundef 121)
  store <2 x i64> %call10, ptr %r9, align 16, !tbaa !16
  %arrayinit.element11 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element6, i64 1
  %a12 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element11, i32 0, i32 0
  %call13 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 88, i8 noundef signext 68, i8 noundef signext -76, i8 noundef signext 35, i8 noundef signext -119, i8 noundef signext -67, i8 noundef signext 52, i8 noundef signext 58, i8 noundef signext 7, i8 noundef signext 70, i8 noundef signext -26, i8 noundef signext 55, i8 noundef signext 126, i8 noundef signext 69, i8 noundef signext 105, i8 noundef signext 40)
  store <2 x i64> %call13, ptr %a12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element11, i32 0, i32 1
  %call15 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 105, i64 noundef 40)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element11, i64 1
  %a17 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 110, i8 noundef signext -4, i8 noundef signext 41, i8 noundef signext -98, i8 noundef signext -91, i8 noundef signext 117, i8 noundef signext -33, i8 noundef signext -110, i8 noundef signext 126, i8 noundef signext -63, i8 noundef signext -65, i8 noundef signext -86, i8 noundef signext -108, i8 noundef signext -64, i8 noundef signext -4, i8 noundef signext 25)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -4, i64 noundef 25)
  store <2 x i64> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element16, i64 1
  %a22 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 105, i8 noundef signext -31, i8 noundef signext -57, i8 noundef signext -74, i8 noundef signext 119, i8 noundef signext 56, i8 noundef signext -36, i8 noundef signext -128, i8 noundef signext 102, i8 noundef signext 57, i8 noundef signext -27, i8 noundef signext 19, i8 noundef signext -50, i8 noundef signext -15, i8 noundef signext 36, i8 noundef signext -124)
  store <2 x i64> %call23, ptr %a22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 36, i64 noundef -124)
  store <2 x i64> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element21, i64 1
  %a27 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 44, i8 noundef signext -84, i8 noundef signext -61, i8 noundef signext 59, i8 noundef signext 18, i8 noundef signext -118, i8 noundef signext 6, i8 noundef signext 56, i8 noundef signext -11, i8 noundef signext 78, i8 noundef signext -64, i8 noundef signext -28, i8 noundef signext -85, i8 noundef signext -77, i8 noundef signext -25, i8 noundef signext -100)
  store <2 x i64> %call28, ptr %a27, align 16, !tbaa !16
  %r29 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -25, i64 noundef -100)
  store <2 x i64> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element26, i64 1
  %a32 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -13, i8 noundef signext -24, i8 noundef signext 94, i8 noundef signext 58, i8 noundef signext 1, i8 noundef signext -14, i8 noundef signext -90, i8 noundef signext -123, i8 noundef signext -101, i8 noundef signext 71, i8 noundef signext -51, i8 noundef signext 87, i8 noundef signext -34, i8 noundef signext 77, i8 noundef signext 124, i8 noundef signext -63)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %r34 = getelementptr inbounds %struct.anon.16, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 124, i64 noundef -63)
  store <2 x i64> %call35, ptr %r34, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup42

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r36) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.16], ptr %test_vec, i64 0, i64 %1
  %a37 = getelementptr inbounds %struct.anon.16, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a37, align 16, !tbaa !16
  %call38 = call <2 x i64> @simde_mm_cvtepi8_epi64(<2 x i64> noundef %2)
  store <2 x i64> %call38, ptr %r36, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <2 x i64>, ptr %r36, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx39 = getelementptr inbounds [8 x %struct.anon.16], ptr %test_vec, i64 0, i64 %4
  %r40 = getelementptr inbounds %struct.anon.16, ptr %arrayidx39, i32 0, i32 1
  %5 = load <2 x i64>, ptr %r40, align 16, !tbaa !16
  %call41 = call i32 @simde_test_x86_assert_equal_i64x2_(<2 x i64> noundef %3, <2 x i64> noundef %5, ptr noundef @.str.72, i32 noundef 1064, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call41, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r36) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup42 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup42:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest43 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest43, label %cleanup44 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup42
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup44

cleanup44:                                        ; preds = %for.end, %cleanup42
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_cvtepu8_epi16() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.17], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r36 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.17], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.17, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -123, i8 noundef zeroext 55, i8 noundef zeroext 102, i8 noundef zeroext -126, i8 noundef zeroext -59, i8 noundef zeroext 52, i8 noundef zeroext -31, i8 noundef zeroext 87, i8 noundef zeroext -38, i8 noundef zeroext 15, i8 noundef zeroext -42, i8 noundef zeroext -104, i8 noundef zeroext 108, i8 noundef zeroext 18, i8 noundef zeroext 104, i8 noundef zeroext 3)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.17, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 218, i16 noundef signext 15, i16 noundef signext 214, i16 noundef signext 152, i16 noundef signext 108, i16 noundef signext 18, i16 noundef signext 104, i16 noundef signext 3)
  store <2 x i64> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.17, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 51, i8 noundef zeroext 122, i8 noundef zeroext -89, i8 noundef zeroext -24, i8 noundef zeroext 3, i8 noundef zeroext -89, i8 noundef zeroext 89, i8 noundef zeroext -50, i8 noundef zeroext 96, i8 noundef zeroext -21, i8 noundef zeroext -128, i8 noundef zeroext -122, i8 noundef zeroext -69, i8 noundef zeroext -66, i8 noundef zeroext -24, i8 noundef zeroext 112)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %r4 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 96, i16 noundef signext 235, i16 noundef signext 128, i16 noundef signext 134, i16 noundef signext 187, i16 noundef signext 190, i16 noundef signext 232, i16 noundef signext 112)
  store <2 x i64> %call5, ptr %r4, align 16, !tbaa !16
  %arrayinit.element6 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element, i64 1
  %a7 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element6, i32 0, i32 0
  %call8 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 15, i8 noundef zeroext 99, i8 noundef zeroext -28, i8 noundef zeroext 12, i8 noundef zeroext -101, i8 noundef zeroext -118, i8 noundef zeroext 87, i8 noundef zeroext 96, i8 noundef zeroext 98, i8 noundef zeroext 66, i8 noundef zeroext 96, i8 noundef zeroext 53, i8 noundef zeroext 65, i8 noundef zeroext -69, i8 noundef zeroext -73, i8 noundef zeroext 114)
  store <2 x i64> %call8, ptr %a7, align 16, !tbaa !16
  %r9 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element6, i32 0, i32 1
  %call10 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 98, i16 noundef signext 66, i16 noundef signext 96, i16 noundef signext 53, i16 noundef signext 65, i16 noundef signext 187, i16 noundef signext 183, i16 noundef signext 114)
  store <2 x i64> %call10, ptr %r9, align 16, !tbaa !16
  %arrayinit.element11 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element6, i64 1
  %a12 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element11, i32 0, i32 0
  %call13 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 58, i8 noundef zeroext 51, i8 noundef zeroext -46, i8 noundef zeroext 42, i8 noundef zeroext -124, i8 noundef zeroext 100, i8 noundef zeroext 83, i8 noundef zeroext 44, i8 noundef zeroext 115, i8 noundef zeroext -52, i8 noundef zeroext -61, i8 noundef zeroext 11, i8 noundef zeroext 48, i8 noundef zeroext 39, i8 noundef zeroext 37, i8 noundef zeroext -73)
  store <2 x i64> %call13, ptr %a12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element11, i32 0, i32 1
  %call15 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 115, i16 noundef signext 204, i16 noundef signext 195, i16 noundef signext 11, i16 noundef signext 48, i16 noundef signext 39, i16 noundef signext 37, i16 noundef signext 183)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element11, i64 1
  %a17 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 56, i8 noundef zeroext 101, i8 noundef zeroext -94, i8 noundef zeroext 107, i8 noundef zeroext 59, i8 noundef zeroext 91, i8 noundef zeroext 63, i8 noundef zeroext -127, i8 noundef zeroext -67, i8 noundef zeroext 4, i8 noundef zeroext 9, i8 noundef zeroext -101, i8 noundef zeroext -106, i8 noundef zeroext 39, i8 noundef zeroext -116, i8 noundef zeroext 87)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 189, i16 noundef signext 4, i16 noundef signext 9, i16 noundef signext 155, i16 noundef signext 150, i16 noundef signext 39, i16 noundef signext 140, i16 noundef signext 87)
  store <2 x i64> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element16, i64 1
  %a22 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -53, i8 noundef zeroext -98, i8 noundef zeroext -81, i8 noundef zeroext 0, i8 noundef zeroext 27, i8 noundef zeroext 64, i8 noundef zeroext -127, i8 noundef zeroext 41, i8 noundef zeroext -48, i8 noundef zeroext -76, i8 noundef zeroext -82, i8 noundef zeroext 83, i8 noundef zeroext -114, i8 noundef zeroext -58, i8 noundef zeroext 36, i8 noundef zeroext -98)
  store <2 x i64> %call23, ptr %a22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 208, i16 noundef signext 180, i16 noundef signext 174, i16 noundef signext 83, i16 noundef signext 142, i16 noundef signext 198, i16 noundef signext 36, i16 noundef signext 158)
  store <2 x i64> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element21, i64 1
  %a27 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 48, i8 noundef zeroext -117, i8 noundef zeroext 69, i8 noundef zeroext 42, i8 noundef zeroext -17, i8 noundef zeroext -1, i8 noundef zeroext 84, i8 noundef zeroext -30, i8 noundef zeroext -76, i8 noundef zeroext -52, i8 noundef zeroext 81, i8 noundef zeroext -123, i8 noundef zeroext -26, i8 noundef zeroext 25, i8 noundef zeroext -38, i8 noundef zeroext -117)
  store <2 x i64> %call28, ptr %a27, align 16, !tbaa !16
  %r29 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 180, i16 noundef signext 204, i16 noundef signext 81, i16 noundef signext 133, i16 noundef signext 230, i16 noundef signext 25, i16 noundef signext 218, i16 noundef signext 139)
  store <2 x i64> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element26, i64 1
  %a32 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -43, i8 noundef zeroext 5, i8 noundef zeroext 37, i8 noundef zeroext -13, i8 noundef zeroext -60, i8 noundef zeroext -15, i8 noundef zeroext 11, i8 noundef zeroext 32, i8 noundef zeroext -119, i8 noundef zeroext 5, i8 noundef zeroext -40, i8 noundef zeroext -13, i8 noundef zeroext 25, i8 noundef zeroext 23, i8 noundef zeroext -44, i8 noundef zeroext 57)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %r34 = getelementptr inbounds %struct.anon.17, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 137, i16 noundef signext 5, i16 noundef signext 216, i16 noundef signext 243, i16 noundef signext 25, i16 noundef signext 23, i16 noundef signext 212, i16 noundef signext 57)
  store <2 x i64> %call35, ptr %r34, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup42

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r36) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.17], ptr %test_vec, i64 0, i64 %1
  %a37 = getelementptr inbounds %struct.anon.17, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a37, align 16, !tbaa !16
  %call38 = call <2 x i64> @simde_mm_cvtepu8_epi16(<2 x i64> noundef %2)
  store <2 x i64> %call38, ptr %r36, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <2 x i64>, ptr %r36, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx39 = getelementptr inbounds [8 x %struct.anon.17], ptr %test_vec, i64 0, i64 %4
  %r40 = getelementptr inbounds %struct.anon.17, ptr %arrayidx39, i32 0, i32 1
  %5 = load <2 x i64>, ptr %r40, align 16, !tbaa !16
  %call41 = call i32 @simde_test_x86_assert_equal_i16x8_(<2 x i64> noundef %3, <2 x i64> noundef %5, ptr noundef @.str.72, i32 noundef 1128, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call41, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r36) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup42 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup42:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest43 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest43, label %cleanup44 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup42
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup44

cleanup44:                                        ; preds = %for.end, %cleanup42
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_cvtepu8_epi32() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.18], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r36 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.18], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.18, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -40, i8 noundef zeroext 58, i8 noundef zeroext 77, i8 noundef zeroext -40, i8 noundef zeroext -77, i8 noundef zeroext -2, i8 noundef zeroext 83, i8 noundef zeroext 42, i8 noundef zeroext -77, i8 noundef zeroext -45, i8 noundef zeroext 84, i8 noundef zeroext 116, i8 noundef zeroext -45, i8 noundef zeroext -114, i8 noundef zeroext 19, i8 noundef zeroext -9)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.18, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 211, i32 noundef 142, i32 noundef 19, i32 noundef 247)
  store <2 x i64> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.18, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -95, i8 noundef zeroext 70, i8 noundef zeroext 71, i8 noundef zeroext 24, i8 noundef zeroext 62, i8 noundef zeroext 44, i8 noundef zeroext 28, i8 noundef zeroext 40, i8 noundef zeroext 34, i8 noundef zeroext -75, i8 noundef zeroext 114, i8 noundef zeroext 59, i8 noundef zeroext 33, i8 noundef zeroext 122, i8 noundef zeroext 68, i8 noundef zeroext -58)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %r4 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 33, i32 noundef 122, i32 noundef 68, i32 noundef 198)
  store <2 x i64> %call5, ptr %r4, align 16, !tbaa !16
  %arrayinit.element6 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element, i64 1
  %a7 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element6, i32 0, i32 0
  %call8 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -111, i8 noundef zeroext -96, i8 noundef zeroext 60, i8 noundef zeroext -116, i8 noundef zeroext 53, i8 noundef zeroext 127, i8 noundef zeroext 68, i8 noundef zeroext -21, i8 noundef zeroext -31, i8 noundef zeroext -113, i8 noundef zeroext -12, i8 noundef zeroext 79, i8 noundef zeroext 20, i8 noundef zeroext 67, i8 noundef zeroext -83, i8 noundef zeroext -47)
  store <2 x i64> %call8, ptr %a7, align 16, !tbaa !16
  %r9 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element6, i32 0, i32 1
  %call10 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 20, i32 noundef 67, i32 noundef 173, i32 noundef 209)
  store <2 x i64> %call10, ptr %r9, align 16, !tbaa !16
  %arrayinit.element11 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element6, i64 1
  %a12 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element11, i32 0, i32 0
  %call13 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 117, i8 noundef zeroext -110, i8 noundef zeroext 120, i8 noundef zeroext 54, i8 noundef zeroext -113, i8 noundef zeroext -14, i8 noundef zeroext -115, i8 noundef zeroext -107, i8 noundef zeroext 73, i8 noundef zeroext 58, i8 noundef zeroext 87, i8 noundef zeroext 32, i8 noundef zeroext -57, i8 noundef zeroext -73, i8 noundef zeroext -54, i8 noundef zeroext 12)
  store <2 x i64> %call13, ptr %a12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element11, i32 0, i32 1
  %call15 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 199, i32 noundef 183, i32 noundef 202, i32 noundef 12)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element11, i64 1
  %a17 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 40, i8 noundef zeroext 57, i8 noundef zeroext 16, i8 noundef zeroext 79, i8 noundef zeroext 103, i8 noundef zeroext -7, i8 noundef zeroext -113, i8 noundef zeroext -59, i8 noundef zeroext -42, i8 noundef zeroext 78, i8 noundef zeroext -55, i8 noundef zeroext 95, i8 noundef zeroext 85, i8 noundef zeroext 53, i8 noundef zeroext -9, i8 noundef zeroext -122)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 85, i32 noundef 53, i32 noundef 247, i32 noundef 134)
  store <2 x i64> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element16, i64 1
  %a22 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 72, i8 noundef zeroext -93, i8 noundef zeroext -45, i8 noundef zeroext 103, i8 noundef zeroext -104, i8 noundef zeroext 114, i8 noundef zeroext 2, i8 noundef zeroext -116, i8 noundef zeroext 52, i8 noundef zeroext 64, i8 noundef zeroext 1, i8 noundef zeroext 9, i8 noundef zeroext -72, i8 noundef zeroext -111, i8 noundef zeroext -66, i8 noundef zeroext -11)
  store <2 x i64> %call23, ptr %a22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 184, i32 noundef 145, i32 noundef 190, i32 noundef 245)
  store <2 x i64> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element21, i64 1
  %a27 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 7, i8 noundef zeroext 28, i8 noundef zeroext -109, i8 noundef zeroext 3, i8 noundef zeroext 70, i8 noundef zeroext 73, i8 noundef zeroext -97, i8 noundef zeroext 19, i8 noundef zeroext 118, i8 noundef zeroext 122, i8 noundef zeroext 100, i8 noundef zeroext 52, i8 noundef zeroext -20, i8 noundef zeroext 17, i8 noundef zeroext -121, i8 noundef zeroext 121)
  store <2 x i64> %call28, ptr %a27, align 16, !tbaa !16
  %r29 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 236, i32 noundef 17, i32 noundef 135, i32 noundef 121)
  store <2 x i64> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element26, i64 1
  %a32 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 100, i8 noundef zeroext -23, i8 noundef zeroext -57, i8 noundef zeroext 97, i8 noundef zeroext -98, i8 noundef zeroext -16, i8 noundef zeroext 121, i8 noundef zeroext 115, i8 noundef zeroext -114, i8 noundef zeroext -110, i8 noundef zeroext -97, i8 noundef zeroext 107, i8 noundef zeroext -54, i8 noundef zeroext -32, i8 noundef zeroext -100, i8 noundef zeroext -107)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %r34 = getelementptr inbounds %struct.anon.18, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 202, i32 noundef 224, i32 noundef 156, i32 noundef 149)
  store <2 x i64> %call35, ptr %r34, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup42

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r36) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.18], ptr %test_vec, i64 0, i64 %1
  %a37 = getelementptr inbounds %struct.anon.18, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a37, align 16, !tbaa !16
  %call38 = call <2 x i64> @simde_mm_cvtepu8_epi32(<2 x i64> noundef %2)
  store <2 x i64> %call38, ptr %r36, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <2 x i64>, ptr %r36, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx39 = getelementptr inbounds [8 x %struct.anon.18], ptr %test_vec, i64 0, i64 %4
  %r40 = getelementptr inbounds %struct.anon.18, ptr %arrayidx39, i32 0, i32 1
  %5 = load <2 x i64>, ptr %r40, align 16, !tbaa !16
  %call41 = call i32 @simde_test_x86_assert_equal_i32x4_(<2 x i64> noundef %3, <2 x i64> noundef %5, ptr noundef @.str.72, i32 noundef 1168, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call41, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r36) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup42 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup42:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest43 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest43, label %cleanup44 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup42
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup44

cleanup44:                                        ; preds = %for.end, %cleanup42
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_cvtepu8_epi64() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.19], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r36 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.19], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.19, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -91, i8 noundef zeroext -118, i8 noundef zeroext 9, i8 noundef zeroext -63, i8 noundef zeroext -57, i8 noundef zeroext -43, i8 noundef zeroext 108, i8 noundef zeroext 127, i8 noundef zeroext 76, i8 noundef zeroext 44, i8 noundef zeroext 97, i8 noundef zeroext 43, i8 noundef zeroext 10, i8 noundef zeroext 41, i8 noundef zeroext -30, i8 noundef zeroext -122)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.19, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 226, i64 noundef 134)
  store <2 x i64> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.19, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -50, i8 noundef zeroext -40, i8 noundef zeroext -28, i8 noundef zeroext 95, i8 noundef zeroext 16, i8 noundef zeroext -21, i8 noundef zeroext 117, i8 noundef zeroext -7, i8 noundef zeroext 118, i8 noundef zeroext -87, i8 noundef zeroext 43, i8 noundef zeroext 125, i8 noundef zeroext -117, i8 noundef zeroext 7, i8 noundef zeroext 78, i8 noundef zeroext 91)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %r4 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 78, i64 noundef 91)
  store <2 x i64> %call5, ptr %r4, align 16, !tbaa !16
  %arrayinit.element6 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element, i64 1
  %a7 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element6, i32 0, i32 0
  %call8 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -39, i8 noundef zeroext 54, i8 noundef zeroext 70, i8 noundef zeroext 24, i8 noundef zeroext 18, i8 noundef zeroext -71, i8 noundef zeroext 8, i8 noundef zeroext 83, i8 noundef zeroext -118, i8 noundef zeroext 127, i8 noundef zeroext -85, i8 noundef zeroext -24, i8 noundef zeroext 25, i8 noundef zeroext 28, i8 noundef zeroext -69, i8 noundef zeroext -84)
  store <2 x i64> %call8, ptr %a7, align 16, !tbaa !16
  %r9 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element6, i32 0, i32 1
  %call10 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 187, i64 noundef 172)
  store <2 x i64> %call10, ptr %r9, align 16, !tbaa !16
  %arrayinit.element11 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element6, i64 1
  %a12 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element11, i32 0, i32 0
  %call13 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -117, i8 noundef zeroext -92, i8 noundef zeroext -126, i8 noundef zeroext -54, i8 noundef zeroext -12, i8 noundef zeroext 121, i8 noundef zeroext 41, i8 noundef zeroext -100, i8 noundef zeroext -69, i8 noundef zeroext 51, i8 noundef zeroext 98, i8 noundef zeroext 32, i8 noundef zeroext -77, i8 noundef zeroext -64, i8 noundef zeroext -42, i8 noundef zeroext -76)
  store <2 x i64> %call13, ptr %a12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element11, i32 0, i32 1
  %call15 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 214, i64 noundef 180)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element11, i64 1
  %a17 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -40, i8 noundef zeroext 40, i8 noundef zeroext -3, i8 noundef zeroext -77, i8 noundef zeroext -122, i8 noundef zeroext -57, i8 noundef zeroext 8, i8 noundef zeroext 38, i8 noundef zeroext -87, i8 noundef zeroext -3, i8 noundef zeroext 114, i8 noundef zeroext 51, i8 noundef zeroext -28, i8 noundef zeroext 119, i8 noundef zeroext 103, i8 noundef zeroext -101)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 103, i64 noundef 155)
  store <2 x i64> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element16, i64 1
  %a22 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -59, i8 noundef zeroext -87, i8 noundef zeroext 70, i8 noundef zeroext -21, i8 noundef zeroext 100, i8 noundef zeroext -6, i8 noundef zeroext 64, i8 noundef zeroext 127, i8 noundef zeroext 118, i8 noundef zeroext -94, i8 noundef zeroext 19, i8 noundef zeroext -83, i8 noundef zeroext 116, i8 noundef zeroext -76, i8 noundef zeroext 7, i8 noundef zeroext -40)
  store <2 x i64> %call23, ptr %a22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 7, i64 noundef 216)
  store <2 x i64> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element21, i64 1
  %a27 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 50, i8 noundef zeroext 69, i8 noundef zeroext 69, i8 noundef zeroext -29, i8 noundef zeroext 69, i8 noundef zeroext 0, i8 noundef zeroext 34, i8 noundef zeroext -24, i8 noundef zeroext 24, i8 noundef zeroext 46, i8 noundef zeroext -115, i8 noundef zeroext -128, i8 noundef zeroext 115, i8 noundef zeroext -99, i8 noundef zeroext 112, i8 noundef zeroext 71)
  store <2 x i64> %call28, ptr %a27, align 16, !tbaa !16
  %r29 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 112, i64 noundef 71)
  store <2 x i64> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element26, i64 1
  %a32 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 120, i8 noundef zeroext 3, i8 noundef zeroext -59, i8 noundef zeroext -117, i8 noundef zeroext 31, i8 noundef zeroext -56, i8 noundef zeroext -6, i8 noundef zeroext 106, i8 noundef zeroext -37, i8 noundef zeroext 4, i8 noundef zeroext -50, i8 noundef zeroext 64, i8 noundef zeroext -39, i8 noundef zeroext -25, i8 noundef zeroext -27, i8 noundef zeroext 14)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %r34 = getelementptr inbounds %struct.anon.19, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 229, i64 noundef 14)
  store <2 x i64> %call35, ptr %r34, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup42

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r36) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.19], ptr %test_vec, i64 0, i64 %1
  %a37 = getelementptr inbounds %struct.anon.19, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a37, align 16, !tbaa !16
  %call38 = call <2 x i64> @simde_mm_cvtepu8_epi64(<2 x i64> noundef %2)
  store <2 x i64> %call38, ptr %r36, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <2 x i64>, ptr %r36, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx39 = getelementptr inbounds [8 x %struct.anon.19], ptr %test_vec, i64 0, i64 %4
  %r40 = getelementptr inbounds %struct.anon.19, ptr %arrayidx39, i32 0, i32 1
  %5 = load <2 x i64>, ptr %r40, align 16, !tbaa !16
  %call41 = call i32 @simde_test_x86_assert_equal_i64x2_(<2 x i64> noundef %3, <2 x i64> noundef %5, ptr noundef @.str.72, i32 noundef 1224, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call41, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r36) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup42 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup42:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest43 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest43, label %cleanup44 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup42
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup44

cleanup44:                                        ; preds = %for.end, %cleanup42
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_cvtepi16_epi32() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.20], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r36 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.20], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.20, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -15854, i16 noundef signext 0, i16 noundef signext -12807, i16 noundef signext 5951, i16 noundef signext 29318, i16 noundef signext -11078, i16 noundef signext -2252, i16 noundef signext 10096)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.20, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 29318, i32 noundef -11078, i32 noundef -2252, i32 noundef 10096)
  store <2 x i64> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.20, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 24388, i16 noundef signext 32521, i16 noundef signext -30980, i16 noundef signext -12289, i16 noundef signext 27092, i16 noundef signext 24521, i16 noundef signext 12106, i16 noundef signext -27709)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %r4 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 27092, i32 noundef 24521, i32 noundef 12106, i32 noundef -27709)
  store <2 x i64> %call5, ptr %r4, align 16, !tbaa !16
  %arrayinit.element6 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element, i64 1
  %a7 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element6, i32 0, i32 0
  %call8 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -11871, i16 noundef signext 15750, i16 noundef signext -7986, i16 noundef signext 4594, i16 noundef signext 22346, i16 noundef signext 1400, i16 noundef signext -21386, i16 noundef signext 7662)
  store <2 x i64> %call8, ptr %a7, align 16, !tbaa !16
  %r9 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element6, i32 0, i32 1
  %call10 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 22346, i32 noundef 1400, i32 noundef -21386, i32 noundef 7662)
  store <2 x i64> %call10, ptr %r9, align 16, !tbaa !16
  %arrayinit.element11 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element6, i64 1
  %a12 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element11, i32 0, i32 0
  %call13 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -15687, i16 noundef signext -15477, i16 noundef signext -26077, i16 noundef signext -28781, i16 noundef signext -29737, i16 noundef signext -30311, i16 noundef signext 16950, i16 noundef signext 14614)
  store <2 x i64> %call13, ptr %a12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element11, i32 0, i32 1
  %call15 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -29737, i32 noundef -30311, i32 noundef 16950, i32 noundef 14614)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element11, i64 1
  %a17 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -30646, i16 noundef signext 13049, i16 noundef signext -24166, i16 noundef signext 637, i16 noundef signext 7297, i16 noundef signext -627, i16 noundef signext 6143, i16 noundef signext -26200)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 7297, i32 noundef -627, i32 noundef 6143, i32 noundef -26200)
  store <2 x i64> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element16, i64 1
  %a22 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 30171, i16 noundef signext 1922, i16 noundef signext -122, i16 noundef signext -17991, i16 noundef signext 30806, i16 noundef signext 12552, i16 noundef signext -28515, i16 noundef signext -9185)
  store <2 x i64> %call23, ptr %a22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 30806, i32 noundef 12552, i32 noundef -28515, i32 noundef -9185)
  store <2 x i64> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element21, i64 1
  %a27 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 29385, i16 noundef signext 21267, i16 noundef signext -10152, i16 noundef signext 25553, i16 noundef signext 20674, i16 noundef signext 6661, i16 noundef signext -29222, i16 noundef signext -19848)
  store <2 x i64> %call28, ptr %a27, align 16, !tbaa !16
  %r29 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 20674, i32 noundef 6661, i32 noundef -29222, i32 noundef -19848)
  store <2 x i64> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element26, i64 1
  %a32 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 24527, i16 noundef signext 18305, i16 noundef signext 30094, i16 noundef signext -5437, i16 noundef signext -26652, i16 noundef signext 20361, i16 noundef signext 10408, i16 noundef signext -4948)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %r34 = getelementptr inbounds %struct.anon.20, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -26652, i32 noundef 20361, i32 noundef 10408, i32 noundef -4948)
  store <2 x i64> %call35, ptr %r34, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup42

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r36) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.20], ptr %test_vec, i64 0, i64 %1
  %a37 = getelementptr inbounds %struct.anon.20, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a37, align 16, !tbaa !16
  %call38 = call <2 x i64> @simde_mm_cvtepi16_epi32(<2 x i64> noundef %2)
  store <2 x i64> %call38, ptr %r36, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <2 x i64>, ptr %r36, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx39 = getelementptr inbounds [8 x %struct.anon.20], ptr %test_vec, i64 0, i64 %4
  %r40 = getelementptr inbounds %struct.anon.20, ptr %arrayidx39, i32 0, i32 1
  %5 = load <2 x i64>, ptr %r40, align 16, !tbaa !16
  %call41 = call i32 @simde_test_x86_assert_equal_i32x4_(<2 x i64> noundef %3, <2 x i64> noundef %5, ptr noundef @.str.72, i32 noundef 816, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call41, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r36) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup42 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup42:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest43 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest43, label %cleanup44 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup42
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup44

cleanup44:                                        ; preds = %for.end, %cleanup42
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_cvtepi16_epi64() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.21], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r36 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.21], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.21, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -25288, i16 noundef signext 737, i16 noundef signext -31366, i16 noundef signext -21360, i16 noundef signext 1927, i16 noundef signext 32195, i16 noundef signext -4472, i16 noundef signext -2085)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.21, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -4472, i64 noundef -2085)
  store <2 x i64> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.21, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -30817, i16 noundef signext 5734, i16 noundef signext -6209, i16 noundef signext -18846, i16 noundef signext 14970, i16 noundef signext 30345, i16 noundef signext -8853, i16 noundef signext -31121)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %r4 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -8853, i64 noundef -31121)
  store <2 x i64> %call5, ptr %r4, align 16, !tbaa !16
  %arrayinit.element6 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element, i64 1
  %a7 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element6, i32 0, i32 0
  %call8 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -970, i16 noundef signext -11861, i16 noundef signext -11667, i16 noundef signext 14936, i16 noundef signext 21732, i16 noundef signext -17006, i16 noundef signext -2668, i16 noundef signext 30170)
  store <2 x i64> %call8, ptr %a7, align 16, !tbaa !16
  %r9 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element6, i32 0, i32 1
  %call10 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -2668, i64 noundef 30170)
  store <2 x i64> %call10, ptr %r9, align 16, !tbaa !16
  %arrayinit.element11 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element6, i64 1
  %a12 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element11, i32 0, i32 0
  %call13 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 2721, i16 noundef signext -13375, i16 noundef signext -1976, i16 noundef signext 30833, i16 noundef signext -18247, i16 noundef signext 16242, i16 noundef signext 4569, i16 noundef signext 10132)
  store <2 x i64> %call13, ptr %a12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element11, i32 0, i32 1
  %call15 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 4569, i64 noundef 10132)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element11, i64 1
  %a17 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext -22879, i16 noundef signext -24842, i16 noundef signext -29886, i16 noundef signext -13312, i16 noundef signext 24862, i16 noundef signext -30679, i16 noundef signext 6258, i16 noundef signext -19461)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 6258, i64 noundef -19461)
  store <2 x i64> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element16, i64 1
  %a22 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 15048, i16 noundef signext 5334, i16 noundef signext 21517, i16 noundef signext 10106, i16 noundef signext -25890, i16 noundef signext -8759, i16 noundef signext 21361, i16 noundef signext 17584)
  store <2 x i64> %call23, ptr %a22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 21361, i64 noundef 17584)
  store <2 x i64> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element21, i64 1
  %a27 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 18353, i16 noundef signext 9848, i16 noundef signext 20583, i16 noundef signext -28706, i16 noundef signext 28353, i16 noundef signext 979, i16 noundef signext -15312, i16 noundef signext -4296)
  store <2 x i64> %call28, ptr %a27, align 16, !tbaa !16
  %r29 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -15312, i64 noundef -4296)
  store <2 x i64> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element26, i64 1
  %a32 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_mm_set_epi16(i16 noundef signext 21066, i16 noundef signext 26185, i16 noundef signext 29520, i16 noundef signext -9848, i16 noundef signext -20587, i16 noundef signext -254, i16 noundef signext -19969, i16 noundef signext -2307)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %r34 = getelementptr inbounds %struct.anon.21, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -19969, i64 noundef -2307)
  store <2 x i64> %call35, ptr %r34, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup42

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r36) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.21], ptr %test_vec, i64 0, i64 %1
  %a37 = getelementptr inbounds %struct.anon.21, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a37, align 16, !tbaa !16
  %call38 = call <2 x i64> @simde_mm_cvtepi16_epi64(<2 x i64> noundef %2)
  store <2 x i64> %call38, ptr %r36, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <2 x i64>, ptr %r36, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx39 = getelementptr inbounds [8 x %struct.anon.21], ptr %test_vec, i64 0, i64 %4
  %r40 = getelementptr inbounds %struct.anon.21, ptr %arrayidx39, i32 0, i32 1
  %5 = load <2 x i64>, ptr %r40, align 16, !tbaa !16
  %call41 = call i32 @simde_test_x86_assert_equal_i64x2_(<2 x i64> noundef %3, <2 x i64> noundef %5, ptr noundef @.str.72, i32 noundef 856, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call41, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r36) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup42 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup42:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest43 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest43, label %cleanup44 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup42
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup44

cleanup44:                                        ; preds = %for.end, %cleanup42
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_cvtepu16_epi32() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.22], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r36 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.22], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.22, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -19539, i16 noundef zeroext -10655, i16 noundef zeroext 8073, i16 noundef zeroext -15483, i16 noundef zeroext -32023, i16 noundef zeroext -5042, i16 noundef zeroext -21083, i16 noundef zeroext -30087)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.22, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 33513, i32 noundef 60494, i32 noundef 44453, i32 noundef 35449)
  store <2 x i64> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.22, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 29322, i16 noundef zeroext -5224, i16 noundef zeroext 23894, i16 noundef zeroext 5611, i16 noundef zeroext -22367, i16 noundef zeroext -29358, i16 noundef zeroext 30857, i16 noundef zeroext 27437)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %r4 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 43169, i32 noundef 36178, i32 noundef 30857, i32 noundef 27437)
  store <2 x i64> %call5, ptr %r4, align 16, !tbaa !16
  %arrayinit.element6 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element, i64 1
  %a7 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element6, i32 0, i32 0
  %call8 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -29371, i16 noundef zeroext 32250, i16 noundef zeroext 32420, i16 noundef zeroext -11453, i16 noundef zeroext -27941, i16 noundef zeroext 6323, i16 noundef zeroext 24868, i16 noundef zeroext 13806)
  store <2 x i64> %call8, ptr %a7, align 16, !tbaa !16
  %r9 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element6, i32 0, i32 1
  %call10 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 37595, i32 noundef 6323, i32 noundef 24868, i32 noundef 13806)
  store <2 x i64> %call10, ptr %r9, align 16, !tbaa !16
  %arrayinit.element11 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element6, i64 1
  %a12 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element11, i32 0, i32 0
  %call13 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -18063, i16 noundef zeroext 25142, i16 noundef zeroext -11562, i16 noundef zeroext 29717, i16 noundef zeroext -26936, i16 noundef zeroext -28104, i16 noundef zeroext -31679, i16 noundef zeroext 7799)
  store <2 x i64> %call13, ptr %a12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element11, i32 0, i32 1
  %call15 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 38600, i32 noundef 37432, i32 noundef 33857, i32 noundef 7799)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element11, i64 1
  %a17 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 9476, i16 noundef zeroext -16374, i16 noundef zeroext -6436, i16 noundef zeroext -19340, i16 noundef zeroext -26133, i16 noundef zeroext -32357, i16 noundef zeroext -23504, i16 noundef zeroext 16407)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 39403, i32 noundef 33179, i32 noundef 42032, i32 noundef 16407)
  store <2 x i64> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element16, i64 1
  %a22 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 13947, i16 noundef zeroext 14884, i16 noundef zeroext -2073, i16 noundef zeroext -4651, i16 noundef zeroext -20741, i16 noundef zeroext -7959, i16 noundef zeroext 9399, i16 noundef zeroext -10796)
  store <2 x i64> %call23, ptr %a22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 44795, i32 noundef 57577, i32 noundef 9399, i32 noundef 54740)
  store <2 x i64> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element21, i64 1
  %a27 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 16348, i16 noundef zeroext -24273, i16 noundef zeroext 29933, i16 noundef zeroext 7966, i16 noundef zeroext 11747, i16 noundef zeroext -19728, i16 noundef zeroext 10076, i16 noundef zeroext -12902)
  store <2 x i64> %call28, ptr %a27, align 16, !tbaa !16
  %r29 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 11747, i32 noundef 45808, i32 noundef 10076, i32 noundef 52634)
  store <2 x i64> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element26, i64 1
  %a32 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -20615, i16 noundef zeroext 31426, i16 noundef zeroext -14883, i16 noundef zeroext -26525, i16 noundef zeroext 15796, i16 noundef zeroext 28031, i16 noundef zeroext -15188, i16 noundef zeroext -30106)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %r34 = getelementptr inbounds %struct.anon.22, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 15796, i32 noundef 28031, i32 noundef 50348, i32 noundef 35430)
  store <2 x i64> %call35, ptr %r34, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup42

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r36) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.22], ptr %test_vec, i64 0, i64 %1
  %a37 = getelementptr inbounds %struct.anon.22, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a37, align 16, !tbaa !16
  %call38 = call <2 x i64> @simde_mm_cvtepu16_epi32(<2 x i64> noundef %2)
  store <2 x i64> %call38, ptr %r36, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <2 x i64>, ptr %r36, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx39 = getelementptr inbounds [8 x %struct.anon.22], ptr %test_vec, i64 0, i64 %4
  %r40 = getelementptr inbounds %struct.anon.22, ptr %arrayidx39, i32 0, i32 1
  %5 = load <2 x i64>, ptr %r40, align 16, !tbaa !16
  %call41 = call i32 @simde_test_x86_assert_equal_i32x4_(<2 x i64> noundef %3, <2 x i64> noundef %5, ptr noundef @.str.72, i32 noundef 1264, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call41, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r36) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup42 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup42:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest43 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest43, label %cleanup44 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup42
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup44

cleanup44:                                        ; preds = %for.end, %cleanup42
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_cvtepu16_epi64() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.23], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r36 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.23], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.23, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -28592, i16 noundef zeroext -17896, i16 noundef zeroext 2187, i16 noundef zeroext 10560, i16 noundef zeroext 1923, i16 noundef zeroext -13519, i16 noundef zeroext -24346, i16 noundef zeroext -14155)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.23, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 41190, i64 noundef 51381)
  store <2 x i64> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.23, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -6426, i16 noundef zeroext 781, i16 noundef zeroext 2267, i16 noundef zeroext 32518, i16 noundef zeroext 16361, i16 noundef zeroext 14242, i16 noundef zeroext 28197, i16 noundef zeroext 27455)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %r4 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 28197, i64 noundef 27455)
  store <2 x i64> %call5, ptr %r4, align 16, !tbaa !16
  %arrayinit.element6 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element, i64 1
  %a7 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element6, i32 0, i32 0
  %call8 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -20224, i16 noundef zeroext 9417, i16 noundef zeroext -12220, i16 noundef zeroext -10622, i16 noundef zeroext 6651, i16 noundef zeroext -32543, i16 noundef zeroext -14402, i16 noundef zeroext 31066)
  store <2 x i64> %call8, ptr %a7, align 16, !tbaa !16
  %r9 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element6, i32 0, i32 1
  %call10 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 51134, i64 noundef 31066)
  store <2 x i64> %call10, ptr %r9, align 16, !tbaa !16
  %arrayinit.element11 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element6, i64 1
  %a12 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element11, i32 0, i32 0
  %call13 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 6198, i16 noundef zeroext -23540, i16 noundef zeroext -31279, i16 noundef zeroext 1856, i16 noundef zeroext -11230, i16 noundef zeroext -7543, i16 noundef zeroext 28922, i16 noundef zeroext 25456)
  store <2 x i64> %call13, ptr %a12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element11, i32 0, i32 1
  %call15 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 28922, i64 noundef 25456)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element11, i64 1
  %a17 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -12724, i16 noundef zeroext 10727, i16 noundef zeroext 10105, i16 noundef zeroext 31173, i16 noundef zeroext 2196, i16 noundef zeroext -27387, i16 noundef zeroext 12797, i16 noundef zeroext -8815)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 12797, i64 noundef 56721)
  store <2 x i64> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element16, i64 1
  %a22 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -21643, i16 noundef zeroext 22212, i16 noundef zeroext -10363, i16 noundef zeroext -26029, i16 noundef zeroext 17371, i16 noundef zeroext 1379, i16 noundef zeroext -28031, i16 noundef zeroext -13778)
  store <2 x i64> %call23, ptr %a22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 37505, i64 noundef 51758)
  store <2 x i64> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element21, i64 1
  %a27 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 10102, i16 noundef zeroext -6507, i16 noundef zeroext 11878, i16 noundef zeroext -8248, i16 noundef zeroext -1581, i16 noundef zeroext -3093, i16 noundef zeroext 1106, i16 noundef zeroext -32693)
  store <2 x i64> %call28, ptr %a27, align 16, !tbaa !16
  %r29 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 1106, i64 noundef 32843)
  store <2 x i64> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element26, i64 1
  %a32 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 7384, i16 noundef zeroext 18925, i16 noundef zeroext -3872, i16 noundef zeroext -3380, i16 noundef zeroext -1307, i16 noundef zeroext 12260, i16 noundef zeroext 17269, i16 noundef zeroext 165)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %r34 = getelementptr inbounds %struct.anon.23, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 17269, i64 noundef 165)
  store <2 x i64> %call35, ptr %r34, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup42

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r36) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.23], ptr %test_vec, i64 0, i64 %1
  %a37 = getelementptr inbounds %struct.anon.23, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a37, align 16, !tbaa !16
  %call38 = call <2 x i64> @simde_mm_cvtepu16_epi64(<2 x i64> noundef %2)
  store <2 x i64> %call38, ptr %r36, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <2 x i64>, ptr %r36, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx39 = getelementptr inbounds [8 x %struct.anon.23], ptr %test_vec, i64 0, i64 %4
  %r40 = getelementptr inbounds %struct.anon.23, ptr %arrayidx39, i32 0, i32 1
  %5 = load <2 x i64>, ptr %r40, align 16, !tbaa !16
  %call41 = call i32 @simde_test_x86_assert_equal_i64x2_(<2 x i64> noundef %3, <2 x i64> noundef %5, ptr noundef @.str.72, i32 noundef 1304, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call41, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r36) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup42 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup42:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest43 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest43, label %cleanup44 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup42
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup44

cleanup44:                                        ; preds = %for.end, %cleanup42
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_cvtepi32_epi64() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.24], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r36 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.24], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.24, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1750586859, i32 noundef 1743108010, i32 noundef -56370522, i32 noundef 214732685)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.24, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -56370522, i64 noundef 214732685)
  store <2 x i64> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.24, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1019578476, i32 noundef 2006962808, i32 noundef 1356966666, i32 noundef 443191452)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %r4 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 1356966666, i64 noundef 443191452)
  store <2 x i64> %call5, ptr %r4, align 16, !tbaa !16
  %arrayinit.element6 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element, i64 1
  %a7 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element6, i32 0, i32 0
  %call8 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 811952499, i32 noundef 1388789927, i32 noundef 1562076587, i32 noundef 1374574189)
  store <2 x i64> %call8, ptr %a7, align 16, !tbaa !16
  %r9 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element6, i32 0, i32 1
  %call10 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 1562076587, i64 noundef 1374574189)
  store <2 x i64> %call10, ptr %r9, align 16, !tbaa !16
  %arrayinit.element11 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element6, i64 1
  %a12 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element11, i32 0, i32 0
  %call13 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1130424581, i32 noundef -754503048, i32 noundef -175987570, i32 noundef 252857640)
  store <2 x i64> %call13, ptr %a12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element11, i32 0, i32 1
  %call15 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -175987570, i64 noundef 252857640)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element11, i64 1
  %a17 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -662885345, i32 noundef -469769762, i32 noundef 1876427062, i32 noundef -1227144336)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 1876427062, i64 noundef -1227144336)
  store <2 x i64> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element16, i64 1
  %a22 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1459145913, i32 noundef -624950308, i32 noundef -1740403350, i32 noundef -2023012954)
  store <2 x i64> %call23, ptr %a22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -1740403350, i64 noundef -2023012954)
  store <2 x i64> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element21, i64 1
  %a27 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 807996884, i32 noundef -721517626, i32 noundef -1345085365, i32 noundef 3500292)
  store <2 x i64> %call28, ptr %a27, align 16, !tbaa !16
  %r29 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -1345085365, i64 noundef 3500292)
  store <2 x i64> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element26, i64 1
  %a32 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1631614297, i32 noundef -2082769218, i32 noundef 285385405, i32 noundef -1874296921)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %r34 = getelementptr inbounds %struct.anon.24, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 285385405, i64 noundef -1874296921)
  store <2 x i64> %call35, ptr %r34, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup42

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r36) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.24], ptr %test_vec, i64 0, i64 %1
  %a37 = getelementptr inbounds %struct.anon.24, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a37, align 16, !tbaa !16
  %call38 = call <2 x i64> @simde_mm_cvtepi32_epi64(<2 x i64> noundef %2)
  store <2 x i64> %call38, ptr %r36, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <2 x i64>, ptr %r36, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx39 = getelementptr inbounds [8 x %struct.anon.24], ptr %test_vec, i64 0, i64 %4
  %r40 = getelementptr inbounds %struct.anon.24, ptr %arrayidx39, i32 0, i32 1
  %5 = load <2 x i64>, ptr %r40, align 16, !tbaa !16
  %call41 = call i32 @simde_test_x86_assert_equal_i64x2_(<2 x i64> noundef %3, <2 x i64> noundef %5, ptr noundef @.str.72, i32 noundef 888, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call41, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r36) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup42 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup42:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest43 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest43, label %cleanup44 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup42
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup44

cleanup44:                                        ; preds = %for.end, %cleanup42
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_cvtepu32_epi64() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.25], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r36 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.25], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.25, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1089356158, i32 noundef 716812601, i32 noundef -1694615011, i32 noundef 851998215)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.25, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 2600352285, i64 noundef 851998215)
  store <2 x i64> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.25, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 2083471993, i32 noundef -299303601, i32 noundef 718227173, i32 noundef -649497714)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %r4 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 718227173, i64 noundef 3645469582)
  store <2 x i64> %call5, ptr %r4, align 16, !tbaa !16
  %arrayinit.element6 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element, i64 1
  %a7 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element6, i32 0, i32 0
  %call8 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1173423010, i32 noundef 583537062, i32 noundef 362422775, i32 noundef -418886684)
  store <2 x i64> %call8, ptr %a7, align 16, !tbaa !16
  %r9 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element6, i32 0, i32 1
  %call10 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 362422775, i64 noundef 3876080612)
  store <2 x i64> %call10, ptr %r9, align 16, !tbaa !16
  %arrayinit.element11 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element6, i64 1
  %a12 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element11, i32 0, i32 0
  %call13 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 336299187, i32 noundef 1772325077, i32 noundef -135945928, i32 noundef -397118072)
  store <2 x i64> %call13, ptr %a12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element11, i32 0, i32 1
  %call15 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 4159021368, i64 noundef 3897849224)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element11, i64 1
  %a17 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1680824530, i32 noundef -558971541, i32 noundef -1414267508, i32 noundef 410975381)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 2880699788, i64 noundef 410975381)
  store <2 x i64> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element16, i64 1
  %a22 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1710147937, i32 noundef -2016690814, i32 noundef -1207188036, i32 noundef -1721140953)
  store <2 x i64> %call23, ptr %a22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 3087779260, i64 noundef 2573826343)
  store <2 x i64> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element21, i64 1
  %a27 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 809379705, i32 noundef 343015345, i32 noundef 434582428, i32 noundef 776037113)
  store <2 x i64> %call28, ptr %a27, align 16, !tbaa !16
  %r29 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 434582428, i64 noundef 776037113)
  store <2 x i64> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element26, i64 1
  %a32 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1820133953, i32 noundef 1439643533, i32 noundef -1087425062, i32 noundef -1386984349)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %r34 = getelementptr inbounds %struct.anon.25, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 3207542234, i64 noundef 2907982947)
  store <2 x i64> %call35, ptr %r34, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup42

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r36) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.25], ptr %test_vec, i64 0, i64 %1
  %a37 = getelementptr inbounds %struct.anon.25, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a37, align 16, !tbaa !16
  %call38 = call <2 x i64> @simde_mm_cvtepu32_epi64(<2 x i64> noundef %2)
  store <2 x i64> %call38, ptr %r36, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <2 x i64>, ptr %r36, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx39 = getelementptr inbounds [8 x %struct.anon.25], ptr %test_vec, i64 0, i64 %4
  %r40 = getelementptr inbounds %struct.anon.25, ptr %arrayidx39, i32 0, i32 1
  %5 = load <2 x i64>, ptr %r40, align 16, !tbaa !16
  %call41 = call i32 @simde_test_x86_assert_equal_i64x2_(<2 x i64> noundef %3, <2 x i64> noundef %5, ptr noundef @.str.72, i32 noundef 1336, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call41, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r36) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup42 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup42:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest43 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest43, label %cleanup44 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup42
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup44

cleanup44:                                        ; preds = %for.end, %cleanup42
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_dp_pd() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <2 x double>, align 16
  %b = alloca <2 x double>, align 16
  %r = alloca <2 x double>, align 16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup38

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %a) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.26], ptr @test_simde_mm_dp_pd.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.26, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [2 x double], ptr %a1, i64 0, i64 0
  %call = call <2 x double> @simde_mm_loadu_pd(ptr noundef %arraydecay)
  store <2 x double> %call, ptr %a, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %b) #10
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.26], ptr @test_simde_mm_dp_pd.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.26, ptr %arrayidx2, i32 0, i32 1
  %arraydecay4 = getelementptr inbounds [2 x double], ptr %b3, i64 0, i64 0
  %call5 = call <2 x double> @simde_mm_loadu_pd(ptr noundef %arraydecay4)
  store <2 x double> %call5, ptr %b, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #10
  %3 = load <2 x double>, ptr %a, align 16, !tbaa !16
  %4 = load <2 x double>, ptr %b, align 16, !tbaa !16
  %call6 = call <2 x double> @simde_mm_dp_pd(<2 x double> noundef %3, <2 x double> noundef %4, i32 noundef 255)
  store <2 x double> %call6, ptr %r, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x double>, ptr %r, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx7 = getelementptr inbounds [8 x %struct.anon.26], ptr @test_simde_mm_dp_pd.test_vec, i64 0, i64 %6
  %rff = getelementptr inbounds %struct.anon.26, ptr %arrayidx7, i32 0, i32 2
  %arraydecay8 = getelementptr inbounds [2 x double], ptr %rff, i64 0, i64 0
  %call9 = call <2 x double> @simde_mm_loadu_pd(ptr noundef %arraydecay8)
  %call10 = call double @simde_test_f64_precision_to_slop(i32 noundef 1)
  %call11 = call i32 @simde_test_x86_assert_equal_f64x2_(<2 x double> noundef %5, <2 x double> noundef %call9, double noundef %call10, ptr noundef @.str.72, i32 noundef 1399, ptr noundef @.str.73, ptr noundef @.str.78)
  %tobool = icmp ne i32 %call11, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  %7 = load <2 x double>, ptr %a, align 16, !tbaa !16
  %8 = load <2 x double>, ptr %b, align 16, !tbaa !16
  %call12 = call <2 x double> @simde_mm_dp_pd(<2 x double> noundef %7, <2 x double> noundef %8, i32 noundef 19)
  store <2 x double> %call12, ptr %r, align 16, !tbaa !16
  br label %do.body13

do.body13:                                        ; preds = %do.end
  %9 = load <2 x double>, ptr %r, align 16, !tbaa !16
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx14 = getelementptr inbounds [8 x %struct.anon.26], ptr @test_simde_mm_dp_pd.test_vec, i64 0, i64 %10
  %r13 = getelementptr inbounds %struct.anon.26, ptr %arrayidx14, i32 0, i32 3
  %arraydecay15 = getelementptr inbounds [2 x double], ptr %r13, i64 0, i64 0
  %call16 = call <2 x double> @simde_mm_loadu_pd(ptr noundef %arraydecay15)
  %call17 = call double @simde_test_f64_precision_to_slop(i32 noundef 1)
  %call18 = call i32 @simde_test_x86_assert_equal_f64x2_(<2 x double> noundef %9, <2 x double> noundef %call16, double noundef %call17, ptr noundef @.str.72, i32 noundef 1401, ptr noundef @.str.73, ptr noundef @.str.79)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %do.body13
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end21:                                         ; preds = %do.body13
  br label %do.cond22

do.cond22:                                        ; preds = %if.end21
  br label %do.end23

do.end23:                                         ; preds = %do.cond22
  %11 = load <2 x double>, ptr %a, align 16, !tbaa !16
  %12 = load <2 x double>, ptr %b, align 16, !tbaa !16
  %call24 = call <2 x double> @simde_mm_dp_pd(<2 x double> noundef %11, <2 x double> noundef %12, i32 noundef 66)
  store <2 x double> %call24, ptr %r, align 16, !tbaa !16
  br label %do.body25

do.body25:                                        ; preds = %do.end23
  %13 = load <2 x double>, ptr %r, align 16, !tbaa !16
  %14 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx26 = getelementptr inbounds [8 x %struct.anon.26], ptr @test_simde_mm_dp_pd.test_vec, i64 0, i64 %14
  %r42 = getelementptr inbounds %struct.anon.26, ptr %arrayidx26, i32 0, i32 4
  %arraydecay27 = getelementptr inbounds [2 x double], ptr %r42, i64 0, i64 0
  %call28 = call <2 x double> @simde_mm_loadu_pd(ptr noundef %arraydecay27)
  %call29 = call double @simde_test_f64_precision_to_slop(i32 noundef 1)
  %call30 = call i32 @simde_test_x86_assert_equal_f64x2_(<2 x double> noundef %13, <2 x double> noundef %call28, double noundef %call29, ptr noundef @.str.72, i32 noundef 1403, ptr noundef @.str.73, ptr noundef @.str.80)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %do.body25
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end33:                                         ; preds = %do.body25
  br label %do.cond34

do.cond34:                                        ; preds = %if.end33
  br label %do.end35

do.end35:                                         ; preds = %do.cond34
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end35, %if.then32, %if.then20, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %b) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup38 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %15 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %15, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup38:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest39 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest39, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup38
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup38
  %16 = load i32, ptr %retval, align 4
  ret i32 %16

unreachable:                                      ; preds = %cleanup38
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_dp_ps() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <4 x float>, align 16
  %b = alloca <4 x float>, align 16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup37

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %a) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.27], ptr @test_simde_mm_dp_ps.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.27, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [4 x float], ptr %a1, i64 0, i64 0
  %call = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay)
  store <4 x float> %call, ptr %a, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %b) #10
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.27], ptr @test_simde_mm_dp_ps.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.27, ptr %arrayidx2, i32 0, i32 1
  %arraydecay4 = getelementptr inbounds [4 x float], ptr %b3, i64 0, i64 0
  %call5 = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay4)
  store <4 x float> %call5, ptr %b, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <4 x float>, ptr %a, align 16, !tbaa !16
  %4 = load <4 x float>, ptr %b, align 16, !tbaa !16
  %call6 = call <4 x float> @simde_mm_dp_ps(<4 x float> noundef %3, <4 x float> noundef %4, i32 noundef 255)
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx7 = getelementptr inbounds [8 x %struct.anon.27], ptr @test_simde_mm_dp_ps.test_vec, i64 0, i64 %5
  %rff = getelementptr inbounds %struct.anon.27, ptr %arrayidx7, i32 0, i32 2
  %arraydecay8 = getelementptr inbounds [4 x float], ptr %rff, i64 0, i64 0
  %call9 = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay8)
  %call10 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call11 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %call6, <4 x float> noundef %call9, float noundef %call10, ptr noundef @.str.72, i32 noundef 1465, ptr noundef @.str.81, ptr noundef @.str.82)
  %tobool = icmp ne i32 %call11, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  br label %do.body12

do.body12:                                        ; preds = %do.end
  %6 = load <4 x float>, ptr %a, align 16, !tbaa !16
  %7 = load <4 x float>, ptr %b, align 16, !tbaa !16
  %call13 = call <4 x float> @simde_mm_dp_ps(<4 x float> noundef %6, <4 x float> noundef %7, i32 noundef 127)
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx14 = getelementptr inbounds [8 x %struct.anon.27], ptr @test_simde_mm_dp_ps.test_vec, i64 0, i64 %8
  %r7f = getelementptr inbounds %struct.anon.27, ptr %arrayidx14, i32 0, i32 3
  %arraydecay15 = getelementptr inbounds [4 x float], ptr %r7f, i64 0, i64 0
  %call16 = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay15)
  %call17 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call18 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %call13, <4 x float> noundef %call16, float noundef %call17, ptr noundef @.str.72, i32 noundef 1466, ptr noundef @.str.83, ptr noundef @.str.84)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %do.body12
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end21:                                         ; preds = %do.body12
  br label %do.cond22

do.cond22:                                        ; preds = %if.end21
  br label %do.end23

do.end23:                                         ; preds = %do.cond22
  br label %do.body24

do.body24:                                        ; preds = %do.end23
  %9 = load <4 x float>, ptr %a, align 16, !tbaa !16
  %10 = load <4 x float>, ptr %b, align 16, !tbaa !16
  %call25 = call <4 x float> @simde_mm_dp_ps(<4 x float> noundef %9, <4 x float> noundef %10, i32 noundef 42)
  %11 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx26 = getelementptr inbounds [8 x %struct.anon.27], ptr @test_simde_mm_dp_ps.test_vec, i64 0, i64 %11
  %r2a = getelementptr inbounds %struct.anon.27, ptr %arrayidx26, i32 0, i32 4
  %arraydecay27 = getelementptr inbounds [4 x float], ptr %r2a, i64 0, i64 0
  %call28 = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay27)
  %call29 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call30 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %call25, <4 x float> noundef %call28, float noundef %call29, ptr noundef @.str.72, i32 noundef 1467, ptr noundef @.str.85, ptr noundef @.str.86)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %do.body24
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end33:                                         ; preds = %do.body24
  br label %do.cond34

do.cond34:                                        ; preds = %if.end33
  br label %do.end35

do.end35:                                         ; preds = %do.cond34
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end35, %if.then32, %if.then20, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %b) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup37 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %12 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %12, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup37:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest38 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest38, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup37
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup37
  %13 = load i32, ptr %retval, align 4
  ret i32 %13

unreachable:                                      ; preds = %cleanup37
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_extract_epi8() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.28], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r28 = alloca i8, align 1
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.28], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.28, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -105, i8 noundef signext -107, i8 noundef signext -84, i8 noundef signext -57, i8 noundef signext 13, i8 noundef signext -101, i8 noundef signext -59, i8 noundef signext -93, i8 noundef signext 53, i8 noundef signext 83, i8 noundef signext -28, i8 noundef signext 126, i8 noundef signext -111, i8 noundef signext -97, i8 noundef signext 25, i8 noundef signext -72)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.28, ptr %arrayinit.begin, i32 0, i32 1
  store i8 -97, ptr %r, align 16, !tbaa !17
  %arrayinit.element = getelementptr inbounds %struct.anon.28, ptr %arrayinit.begin, i64 1
  %a1 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element, i32 0, i32 0
  %call2 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -76, i8 noundef signext -25, i8 noundef signext 36, i8 noundef signext -92, i8 noundef signext -6, i8 noundef signext 77, i8 noundef signext -49, i8 noundef signext -126, i8 noundef signext -50, i8 noundef signext 79, i8 noundef signext -93, i8 noundef signext -95, i8 noundef signext -54, i8 noundef signext -116, i8 noundef signext -84, i8 noundef signext 66)
  store <2 x i64> %call2, ptr %a1, align 16, !tbaa !16
  %r3 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element, i32 0, i32 1
  store i8 -116, ptr %r3, align 16, !tbaa !17
  %arrayinit.element4 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element, i64 1
  %a5 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element4, i32 0, i32 0
  %call6 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 83, i8 noundef signext 123, i8 noundef signext 120, i8 noundef signext -66, i8 noundef signext -3, i8 noundef signext 66, i8 noundef signext 110, i8 noundef signext 76, i8 noundef signext 0, i8 noundef signext 83, i8 noundef signext 20, i8 noundef signext -12, i8 noundef signext 83, i8 noundef signext 4, i8 noundef signext -39, i8 noundef signext 118)
  store <2 x i64> %call6, ptr %a5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element4, i32 0, i32 1
  store i8 4, ptr %r7, align 16, !tbaa !17
  %arrayinit.element8 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element4, i64 1
  %a9 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element8, i32 0, i32 0
  %call10 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 32, i8 noundef signext 30, i8 noundef signext 127, i8 noundef signext -79, i8 noundef signext -10, i8 noundef signext 64, i8 noundef signext -45, i8 noundef signext 101, i8 noundef signext 44, i8 noundef signext -25, i8 noundef signext -110, i8 noundef signext 105, i8 noundef signext 83, i8 noundef signext 27, i8 noundef signext 15, i8 noundef signext 3)
  store <2 x i64> %call10, ptr %a9, align 16, !tbaa !16
  %r11 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element8, i32 0, i32 1
  store i8 27, ptr %r11, align 16, !tbaa !17
  %arrayinit.element12 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element8, i64 1
  %a13 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element12, i32 0, i32 0
  %call14 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 79, i8 noundef signext 95, i8 noundef signext -109, i8 noundef signext 26, i8 noundef signext -81, i8 noundef signext -5, i8 noundef signext -84, i8 noundef signext 115, i8 noundef signext -48, i8 noundef signext 104, i8 noundef signext 67, i8 noundef signext 26, i8 noundef signext -41, i8 noundef signext -30, i8 noundef signext 94, i8 noundef signext -19)
  store <2 x i64> %call14, ptr %a13, align 16, !tbaa !16
  %r15 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element12, i32 0, i32 1
  store i8 -30, ptr %r15, align 16, !tbaa !17
  %arrayinit.element16 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element12, i64 1
  %a17 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -81, i8 noundef signext -80, i8 noundef signext -109, i8 noundef signext -14, i8 noundef signext 65, i8 noundef signext 10, i8 noundef signext 95, i8 noundef signext 83, i8 noundef signext 123, i8 noundef signext 45, i8 noundef signext 39, i8 noundef signext 106, i8 noundef signext -16, i8 noundef signext -123, i8 noundef signext -27, i8 noundef signext 56)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element16, i32 0, i32 1
  store i8 -123, ptr %r19, align 16, !tbaa !17
  %arrayinit.element20 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element16, i64 1
  %a21 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element20, i32 0, i32 0
  %call22 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 86, i8 noundef signext 79, i8 noundef signext 41, i8 noundef signext -51, i8 noundef signext 97, i8 noundef signext 42, i8 noundef signext 117, i8 noundef signext -119, i8 noundef signext -18, i8 noundef signext -127, i8 noundef signext 28, i8 noundef signext -21, i8 noundef signext -101, i8 noundef signext -61, i8 noundef signext -63, i8 noundef signext 13)
  store <2 x i64> %call22, ptr %a21, align 16, !tbaa !16
  %r23 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element20, i32 0, i32 1
  store i8 -61, ptr %r23, align 16, !tbaa !17
  %arrayinit.element24 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element20, i64 1
  %a25 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element24, i32 0, i32 0
  %call26 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -22, i8 noundef signext -42, i8 noundef signext 109, i8 noundef signext -75, i8 noundef signext -84, i8 noundef signext 60, i8 noundef signext -44, i8 noundef signext 8, i8 noundef signext 118, i8 noundef signext 102, i8 noundef signext -6, i8 noundef signext 0, i8 noundef signext -28, i8 noundef signext -81, i8 noundef signext 2, i8 noundef signext 94)
  store <2 x i64> %call26, ptr %a25, align 16, !tbaa !16
  %r27 = getelementptr inbounds %struct.anon.28, ptr %arrayinit.element24, i32 0, i32 1
  store i8 -81, ptr %r27, align 16, !tbaa !17
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup34

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %r28) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.28], ptr %test_vec, i64 0, i64 %1
  %a29 = getelementptr inbounds %struct.anon.28, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a29, align 16, !tbaa !16
  %call30 = call signext i8 @simde_mm_extract_epi8(<2 x i64> noundef %2, i32 noundef 2)
  store i8 %call30, ptr %r28, align 1, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load i8, ptr %r28, align 1, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx31 = getelementptr inbounds [8 x %struct.anon.28], ptr %test_vec, i64 0, i64 %4
  %r32 = getelementptr inbounds %struct.anon.28, ptr %arrayidx31, i32 0, i32 1
  %5 = load i8, ptr %r32, align 16, !tbaa !17
  %call33 = call i32 @simde_assert_equal_i8_(i8 noundef signext %3, i8 noundef signext %5, ptr noundef @.str.72, i32 noundef 1523, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call33, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 1, ptr %r28) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup34 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup34:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest35 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest35, label %cleanup36 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup34
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup36

cleanup36:                                        ; preds = %for.end, %cleanup34
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_extract_epi32() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.29], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r28 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.29], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.29, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi32(i32 noundef -989914365, i32 noundef -320568713, i32 noundef 764201252, i32 noundef -823076780)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.29, ptr %arrayinit.begin, i32 0, i32 1
  store i32 -320568713, ptr %r, align 16, !tbaa !19
  %arrayinit.element = getelementptr inbounds %struct.anon.29, ptr %arrayinit.begin, i64 1
  %a1 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element, i32 0, i32 0
  %call2 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1872661147, i32 noundef 1704933787, i32 noundef -552294669, i32 noundef -1494809408)
  store <2 x i64> %call2, ptr %a1, align 16, !tbaa !16
  %r3 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element, i32 0, i32 1
  store i32 1704933787, ptr %r3, align 16, !tbaa !19
  %arrayinit.element4 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element, i64 1
  %a5 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element4, i32 0, i32 0
  %call6 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1741332044, i32 noundef 170998046, i32 noundef 1368723621, i32 noundef -2071088920)
  store <2 x i64> %call6, ptr %a5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element4, i32 0, i32 1
  store i32 170998046, ptr %r7, align 16, !tbaa !19
  %arrayinit.element8 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element4, i64 1
  %a9 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element8, i32 0, i32 0
  %call10 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1942216470, i32 noundef -1426359243, i32 noundef 862877610, i32 noundef 898094861)
  store <2 x i64> %call10, ptr %a9, align 16, !tbaa !16
  %r11 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element8, i32 0, i32 1
  store i32 -1426359243, ptr %r11, align 16, !tbaa !19
  %arrayinit.element12 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element8, i64 1
  %a13 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element12, i32 0, i32 0
  %call14 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 998704029, i32 noundef 2083244310, i32 noundef 1997200410, i32 noundef -459833332)
  store <2 x i64> %call14, ptr %a13, align 16, !tbaa !16
  %r15 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element12, i32 0, i32 1
  store i32 2083244310, ptr %r15, align 16, !tbaa !19
  %arrayinit.element16 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element12, i64 1
  %a17 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1256369906, i32 noundef 953394288, i32 noundef 1499034833, i32 noundef 990189413)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element16, i32 0, i32 1
  store i32 953394288, ptr %r19, align 16, !tbaa !19
  %arrayinit.element20 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element16, i64 1
  %a21 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element20, i32 0, i32 0
  %call22 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1704589159, i32 noundef -719174981, i32 noundef -821402820, i32 noundef -969954348)
  store <2 x i64> %call22, ptr %a21, align 16, !tbaa !16
  %r23 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element20, i32 0, i32 1
  store i32 -719174981, ptr %r23, align 16, !tbaa !19
  %arrayinit.element24 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element20, i64 1
  %a25 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element24, i32 0, i32 0
  %call26 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 29062750, i32 noundef 1388055657, i32 noundef 1520861645, i32 noundef -1651761160)
  store <2 x i64> %call26, ptr %a25, align 16, !tbaa !16
  %r27 = getelementptr inbounds %struct.anon.29, ptr %arrayinit.element24, i32 0, i32 1
  store i32 1388055657, ptr %r27, align 16, !tbaa !19
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup34

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 4, ptr %r28) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.29], ptr %test_vec, i64 0, i64 %1
  %a29 = getelementptr inbounds %struct.anon.29, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a29, align 16, !tbaa !16
  %call30 = call i32 @simde_mm_extract_epi32(<2 x i64> noundef %2, i32 noundef 2)
  store i32 %call30, ptr %r28, align 4, !tbaa !5
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load i32, ptr %r28, align 4, !tbaa !5
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx31 = getelementptr inbounds [8 x %struct.anon.29], ptr %test_vec, i64 0, i64 %4
  %r32 = getelementptr inbounds %struct.anon.29, ptr %arrayidx31, i32 0, i32 1
  %5 = load i32, ptr %r32, align 16, !tbaa !19
  %call33 = call i32 @simde_assert_equal_i32_(i32 noundef %3, i32 noundef %5, ptr noundef @.str.72, i32 noundef 1555, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call33, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %r28) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup34 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup34:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest35 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest35, label %cleanup36 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup34
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup36

cleanup36:                                        ; preds = %for.end, %cleanup34
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_extract_epi64() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.30], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r28 = alloca i64, align 8
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.30], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.30, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 3272238239526171606, i64 noundef 1654850679014379440)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.30, ptr %arrayinit.begin, i32 0, i32 1
  store i64 3272238239526171606, ptr %r, align 16, !tbaa !21
  %arrayinit.element = getelementptr inbounds %struct.anon.30, ptr %arrayinit.begin, i64 1
  %a1 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element, i32 0, i32 0
  %call2 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -6129313439874067621, i64 noundef 8613384435853876616)
  store <2 x i64> %call2, ptr %a1, align 16, !tbaa !16
  %r3 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element, i32 0, i32 1
  store i64 -6129313439874067621, ptr %r3, align 16, !tbaa !21
  %arrayinit.element4 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element, i64 1
  %a5 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element4, i32 0, i32 0
  %call6 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -6049641799095753965, i64 noundef -2810493496227171537)
  store <2 x i64> %call6, ptr %a5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element4, i32 0, i32 1
  store i64 -6049641799095753965, ptr %r7, align 16, !tbaa !21
  %arrayinit.element8 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element4, i64 1
  %a9 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element8, i32 0, i32 0
  %call10 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 1486209521702266950, i64 noundef -7779883419844099734)
  store <2 x i64> %call10, ptr %a9, align 16, !tbaa !16
  %r11 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element8, i32 0, i32 1
  store i64 1486209521702266950, ptr %r11, align 16, !tbaa !21
  %arrayinit.element12 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element8, i64 1
  %a13 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element12, i32 0, i32 0
  %call14 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -4910022048576872084, i64 noundef -5820696718361059251)
  store <2 x i64> %call14, ptr %a13, align 16, !tbaa !16
  %r15 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element12, i32 0, i32 1
  store i64 -4910022048576872084, ptr %r15, align 16, !tbaa !21
  %arrayinit.element16 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element12, i64 1
  %a17 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -1923881977407946859, i64 noundef -5589720307210562868)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element16, i32 0, i32 1
  store i64 -1923881977407946859, ptr %r19, align 16, !tbaa !21
  %arrayinit.element20 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element16, i64 1
  %a21 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element20, i32 0, i32 0
  %call22 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -3527421069943215520, i64 noundef 4545940692351426251)
  store <2 x i64> %call22, ptr %a21, align 16, !tbaa !16
  %r23 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element20, i32 0, i32 1
  store i64 -3527421069943215520, ptr %r23, align 16, !tbaa !21
  %arrayinit.element24 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element20, i64 1
  %a25 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element24, i32 0, i32 0
  %call26 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 6123229719758625458, i64 noundef 1813312819011147191)
  store <2 x i64> %call26, ptr %a25, align 16, !tbaa !16
  %r27 = getelementptr inbounds %struct.anon.30, ptr %arrayinit.element24, i32 0, i32 1
  store i64 6123229719758625458, ptr %r27, align 16, !tbaa !21
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup34

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 8, ptr %r28) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.30], ptr %test_vec, i64 0, i64 %1
  %a29 = getelementptr inbounds %struct.anon.30, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a29, align 16, !tbaa !16
  %call30 = call i64 @simde_mm_extract_epi64(<2 x i64> noundef %2, i32 noundef 1)
  store i64 %call30, ptr %r28, align 8, !tbaa !11
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load i64, ptr %r28, align 8, !tbaa !11
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx31 = getelementptr inbounds [8 x %struct.anon.30], ptr %test_vec, i64 0, i64 %4
  %r32 = getelementptr inbounds %struct.anon.30, ptr %arrayidx31, i32 0, i32 1
  %5 = load i64, ptr %r32, align 16, !tbaa !21
  %call33 = call i32 @simde_assert_equal_i64_(i64 noundef %3, i64 noundef %5, ptr noundef @.str.72, i32 noundef 1587, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call33, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 8, ptr %r28) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup34 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup34:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest35 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest35, label %cleanup36 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup34
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup36

cleanup36:                                        ; preds = %for.end, %cleanup34
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_extract_ps() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <4 x float>, align 16
  %r = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup7

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %a) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.31], ptr @test_simde_mm_extract_ps.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.31, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [4 x float], ptr %a1, i64 0, i64 0
  %call = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay)
  store <4 x float> %call, ptr %a, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 4, ptr %r) #10
  %2 = load <4 x float>, ptr %a, align 16, !tbaa !16
  %call2 = call i32 @simde_mm_extract_ps(<4 x float> noundef %2, i32 noundef 0)
  store i32 %call2, ptr %r, align 4, !tbaa !5
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load i32, ptr %r, align 4, !tbaa !5
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx3 = getelementptr inbounds [8 x %struct.anon.31], ptr @test_simde_mm_extract_ps.test_vec, i64 0, i64 %4
  %r4 = getelementptr inbounds %struct.anon.31, ptr %arrayidx3, i32 0, i32 1
  %5 = load i32, ptr %r4, align 4, !tbaa !19
  %call5 = call i32 @simde_assert_equal_i32_(i32 noundef %3, i32 noundef %5, ptr noundef @.str.72, i32 noundef 1620, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %r) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup7 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup7:                                         ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest8 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest8, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup7
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup7
  %7 = load i32, ptr %retval, align 4
  ret i32 %7

unreachable:                                      ; preds = %cleanup7
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_floor_pd() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.32], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r36 = alloca <2 x double>, align 16
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.32], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.32, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x double> @simde_mm_set_pd(double noundef -6.382400e+02, double noundef 0x408818147AE147AE)
  store <2 x double> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.32, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x double> @simde_mm_set_pd(double noundef -6.390000e+02, double noundef 7.710000e+02)
  store <2 x double> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.32, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x double> @simde_mm_set_pd(double noundef 0xC053FC28F5C28F5C, double noundef 5.365500e+02)
  store <2 x double> %call3, ptr %a2, align 16, !tbaa !16
  %r4 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x double> @simde_mm_set_pd(double noundef -8.000000e+01, double noundef 5.360000e+02)
  store <2 x double> %call5, ptr %r4, align 16, !tbaa !16
  %arrayinit.element6 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element, i64 1
  %a7 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element6, i32 0, i32 0
  %call8 = call <2 x double> @simde_mm_set_pd(double noundef 1.457400e+02, double noundef 1.247700e+02)
  store <2 x double> %call8, ptr %a7, align 16, !tbaa !16
  %r9 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element6, i32 0, i32 1
  %call10 = call <2 x double> @simde_mm_set_pd(double noundef 1.450000e+02, double noundef 1.240000e+02)
  store <2 x double> %call10, ptr %r9, align 16, !tbaa !16
  %arrayinit.element11 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element6, i64 1
  %a12 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element11, i32 0, i32 0
  %call13 = call <2 x double> @simde_mm_set_pd(double noundef 3.098900e+02, double noundef 0xC08D0F5C28F5C28F)
  store <2 x double> %call13, ptr %a12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element11, i32 0, i32 1
  %call15 = call <2 x double> @simde_mm_set_pd(double noundef 3.090000e+02, double noundef -9.300000e+02)
  store <2 x double> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element11, i64 1
  %a17 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x double> @simde_mm_set_pd(double noundef 1.387200e+02, double noundef 5.029500e+02)
  store <2 x double> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x double> @simde_mm_set_pd(double noundef 1.380000e+02, double noundef 5.020000e+02)
  store <2 x double> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element16, i64 1
  %a22 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x double> @simde_mm_set_pd(double noundef 5.122200e+02, double noundef 1.873400e+02)
  store <2 x double> %call23, ptr %a22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x double> @simde_mm_set_pd(double noundef 5.120000e+02, double noundef 1.870000e+02)
  store <2 x double> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element21, i64 1
  %a27 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <2 x double> @simde_mm_set_pd(double noundef 5.601700e+02, double noundef 4.201000e+02)
  store <2 x double> %call28, ptr %a27, align 16, !tbaa !16
  %r29 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <2 x double> @simde_mm_set_pd(double noundef 5.600000e+02, double noundef 4.200000e+02)
  store <2 x double> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element26, i64 1
  %a32 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x double> @simde_mm_set_pd(double noundef 3.673000e+02, double noundef 0x4083595C28F5C28F)
  store <2 x double> %call33, ptr %a32, align 16, !tbaa !16
  %r34 = getelementptr inbounds %struct.anon.32, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x double> @simde_mm_set_pd(double noundef 3.670000e+02, double noundef 6.190000e+02)
  store <2 x double> %call35, ptr %r34, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup43

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r36) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.32], ptr %test_vec, i64 0, i64 %1
  %a37 = getelementptr inbounds %struct.anon.32, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x double>, ptr %a37, align 16, !tbaa !16
  %call38 = call <2 x double> @simde_mm_floor_pd(<2 x double> noundef %2)
  store <2 x double> %call38, ptr %r36, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <2 x double>, ptr %r36, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx39 = getelementptr inbounds [8 x %struct.anon.32], ptr %test_vec, i64 0, i64 %4
  %r40 = getelementptr inbounds %struct.anon.32, ptr %arrayidx39, i32 0, i32 1
  %5 = load <2 x double>, ptr %r40, align 16, !tbaa !16
  %call41 = call double @simde_test_f64_precision_to_slop(i32 noundef 1)
  %call42 = call i32 @simde_test_x86_assert_equal_f64x2_(<2 x double> noundef %3, <2 x double> noundef %5, double noundef %call41, ptr noundef @.str.72, i32 noundef 1652, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call42, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r36) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup43 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup43:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest44 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest44, label %cleanup45 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup43
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup45

cleanup45:                                        ; preds = %for.end, %cleanup43
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_floor_ps() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.33], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r36 = alloca <4 x float>, align 16
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.33], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.33, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <4 x float> @simde_mm_set_ps(float noundef 0x4049666660000000, float noundef 0x407CB4CCC0000000, float noundef 0xC08A11AE20000000, float noundef 0x40894399A0000000)
  store <4 x float> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.33, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <4 x float> @simde_mm_set_ps(float noundef 5.000000e+01, float noundef 4.590000e+02, float noundef -8.350000e+02, float noundef 8.080000e+02)
  store <4 x float> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.33, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <4 x float> @simde_mm_set_ps(float noundef 0xC0844199A0000000, float noundef 0x408800CCC0000000, float noundef 0xC08BA8E140000000, float noundef 0xC06453D700000000)
  store <4 x float> %call3, ptr %a2, align 16, !tbaa !16
  %r4 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <4 x float> @simde_mm_set_ps(float noundef -6.490000e+02, float noundef 7.680000e+02, float noundef -8.860000e+02, float noundef -1.630000e+02)
  store <4 x float> %call5, ptr %r4, align 16, !tbaa !16
  %arrayinit.element6 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element, i64 1
  %a7 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element6, i32 0, i32 0
  %call8 = call <4 x float> @simde_mm_set_ps(float noundef 0xC0610A8F60000000, float noundef 0x40769F3340000000, float noundef 0xC086C947A0000000, float noundef 0xC088935C20000000)
  store <4 x float> %call8, ptr %a7, align 16, !tbaa !16
  %r9 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element6, i32 0, i32 1
  %call10 = call <4 x float> @simde_mm_set_ps(float noundef -1.370000e+02, float noundef 3.610000e+02, float noundef -7.300000e+02, float noundef -7.870000e+02)
  store <4 x float> %call10, ptr %r9, align 16, !tbaa !16
  %arrayinit.element11 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element6, i64 1
  %a12 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element11, i32 0, i32 0
  %call13 = call <4 x float> @simde_mm_set_ps(float noundef 0xC0821F1EC0000000, float noundef 0x404BA8F5C0000000, float noundef 0xC08F301480000000, float noundef 0x4067F4CCC0000000)
  store <4 x float> %call13, ptr %a12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element11, i32 0, i32 1
  %call15 = call <4 x float> @simde_mm_set_ps(float noundef -5.800000e+02, float noundef 5.500000e+01, float noundef -9.990000e+02, float noundef 1.910000e+02)
  store <4 x float> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element11, i64 1
  %a17 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <4 x float> @simde_mm_set_ps(float noundef 0x408868CCC0000000, float noundef 0x408BA7D700000000, float noundef 0x408C39C280000000, float noundef 0x408E241480000000)
  store <4 x float> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <4 x float> @simde_mm_set_ps(float noundef 7.810000e+02, float noundef 8.840000e+02, float noundef 9.030000e+02, float noundef 9.640000e+02)
  store <4 x float> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element16, i64 1
  %a22 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <4 x float> @simde_mm_set_ps(float noundef 0x406FE38520000000, float noundef 0x408D0A1480000000, float noundef 0x408B2C6660000000, float noundef 0xC0876BC280000000)
  store <4 x float> %call23, ptr %a22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <4 x float> @simde_mm_set_ps(float noundef 2.550000e+02, float noundef 9.290000e+02, float noundef 8.690000e+02, float noundef -7.500000e+02)
  store <4 x float> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element21, i64 1
  %a27 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <4 x float> @simde_mm_set_ps(float noundef 0xC08ADB70A0000000, float noundef 0x4077CD99A0000000, float noundef 0xC08DE5EB80000000, float noundef 0xC07E65C280000000)
  store <4 x float> %call28, ptr %a27, align 16, !tbaa !16
  %r29 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <4 x float> @simde_mm_set_ps(float noundef -8.600000e+02, float noundef 3.800000e+02, float noundef -9.570000e+02, float noundef -4.870000e+02)
  store <4 x float> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element26, i64 1
  %a32 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <4 x float> @simde_mm_set_ps(float noundef 0x40635F5C20000000, float noundef 0x40755E3D80000000, float noundef 0xC07AF07AE0000000, float noundef 0xC0857DEB80000000)
  store <4 x float> %call33, ptr %a32, align 16, !tbaa !16
  %r34 = getelementptr inbounds %struct.anon.33, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <4 x float> @simde_mm_set_ps(float noundef 1.540000e+02, float noundef 3.410000e+02, float noundef -4.320000e+02, float noundef -6.880000e+02)
  store <4 x float> %call35, ptr %r34, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup43

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r36) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.33], ptr %test_vec, i64 0, i64 %1
  %a37 = getelementptr inbounds %struct.anon.33, ptr %arrayidx, i32 0, i32 0
  %2 = load <4 x float>, ptr %a37, align 16, !tbaa !16
  %call38 = call <4 x float> @simde_mm_floor_ps(<4 x float> noundef %2)
  store <4 x float> %call38, ptr %r36, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <4 x float>, ptr %r36, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx39 = getelementptr inbounds [8 x %struct.anon.33], ptr %test_vec, i64 0, i64 %4
  %r40 = getelementptr inbounds %struct.anon.33, ptr %arrayidx39, i32 0, i32 1
  %5 = load <4 x float>, ptr %r40, align 16, !tbaa !16
  %call41 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call42 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %3, <4 x float> noundef %5, float noundef %call41, ptr noundef @.str.72, i32 noundef 1684, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call42, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r36) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup43 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup43:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest44 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest44, label %cleanup45 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup43
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup45

cleanup45:                                        ; preds = %for.end, %cleanup43
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_floor_sd() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.34], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <2 x double>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.34], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.34, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x double> @simde_mm_set_pd(double noundef -6.518700e+02, double noundef 0x4083835C28F5C28F)
  store <2 x double> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.34, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x double> @simde_mm_set_pd(double noundef 6.345600e+02, double noundef -4.432700e+02)
  store <2 x double> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.34, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x double> @simde_mm_set_pd(double noundef -6.518700e+02, double noundef -4.440000e+02)
  store <2 x double> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.34, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x double> @simde_mm_set_pd(double noundef -6.505700e+02, double noundef -3.887000e+02)
  store <2 x double> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x double> @simde_mm_set_pd(double noundef 0x408AF55C28F5C28F, double noundef -8.473200e+02)
  store <2 x double> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <2 x double> @simde_mm_set_pd(double noundef -6.505700e+02, double noundef -8.480000e+02)
  store <2 x double> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <2 x double> @simde_mm_set_pd(double noundef -4.296000e+02, double noundef 0xC08CFE7AE147AE14)
  store <2 x double> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <2 x double> @simde_mm_set_pd(double noundef 5.165200e+02, double noundef -1.093800e+02)
  store <2 x double> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <2 x double> @simde_mm_set_pd(double noundef -4.296000e+02, double noundef -1.100000e+02)
  store <2 x double> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x double> @simde_mm_set_pd(double noundef 1.199200e+02, double noundef 5.712600e+02)
  store <2 x double> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x double> @simde_mm_set_pd(double noundef 1.501000e+01, double noundef 0x40899E147AE147AE)
  store <2 x double> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <2 x double> @simde_mm_set_pd(double noundef 1.199200e+02, double noundef 8.190000e+02)
  store <2 x double> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <2 x double> @simde_mm_set_pd(double noundef -6.252700e+02, double noundef 9.988400e+02)
  store <2 x double> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <2 x double> @simde_mm_set_pd(double noundef -5.701900e+02, double noundef -8.539000e+01)
  store <2 x double> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <2 x double> @simde_mm_set_pd(double noundef -6.252700e+02, double noundef -8.600000e+01)
  store <2 x double> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x double> @simde_mm_set_pd(double noundef 1.056100e+02, double noundef -3.452000e+02)
  store <2 x double> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x double> @simde_mm_set_pd(double noundef -7.050200e+02, double noundef -9.390000e+01)
  store <2 x double> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x double> @simde_mm_set_pd(double noundef 1.056100e+02, double noundef -9.400000e+01)
  store <2 x double> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x double> @simde_mm_set_pd(double noundef -8.249700e+02, double noundef -3.965700e+02)
  store <2 x double> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x double> @simde_mm_set_pd(double noundef -8.400000e+02, double noundef 0x40830B0A3D70A3D7)
  store <2 x double> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <2 x double> @simde_mm_set_pd(double noundef -8.249700e+02, double noundef 6.090000e+02)
  store <2 x double> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <2 x double> @simde_mm_set_pd(double noundef 4.880900e+02, double noundef -6.470000e+01)
  store <2 x double> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <2 x double> @simde_mm_set_pd(double noundef 0x40573F5C28F5C28F, double noundef 5.317900e+02)
  store <2 x double> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.34, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <2 x double> @simde_mm_set_pd(double noundef 4.880900e+02, double noundef 5.310000e+02)
  store <2 x double> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup60

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.34], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.34, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x double>, ptr %a52, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx53 = getelementptr inbounds [8 x %struct.anon.34], ptr %test_vec, i64 0, i64 %3
  %b54 = getelementptr inbounds %struct.anon.34, ptr %arrayidx53, i32 0, i32 1
  %4 = load <2 x double>, ptr %b54, align 16, !tbaa !16
  %call55 = call <2 x double> @simde_mm_floor_sd(<2 x double> noundef %2, <2 x double> noundef %4)
  store <2 x double> %call55, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x double>, ptr %r51, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx56 = getelementptr inbounds [8 x %struct.anon.34], ptr %test_vec, i64 0, i64 %6
  %r57 = getelementptr inbounds %struct.anon.34, ptr %arrayidx56, i32 0, i32 2
  %7 = load <2 x double>, ptr %r57, align 16, !tbaa !16
  %call58 = call double @simde_test_f64_precision_to_slop(i32 noundef 1)
  %call59 = call i32 @simde_test_x86_assert_equal_f64x2_(<2 x double> noundef %5, <2 x double> noundef %7, double noundef %call58, ptr noundef @.str.72, i32 noundef 1725, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call59, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup60 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup60:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest61 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest61, label %cleanup62 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup60
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup62

cleanup62:                                        ; preds = %for.end, %cleanup60
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_floor_ss() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.35], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <4 x float>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.35], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.35, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <4 x float> @simde_mm_set_ps(float noundef 0x408D2799A0000000, float noundef 0x408D96CCC0000000, float noundef 0xC08B17AE20000000, float noundef 0x4077FAE140000000)
  store <4 x float> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.35, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <4 x float> @simde_mm_set_ps(float noundef 0x4054BD70A0000000, float noundef 0x4080E9AE20000000, float noundef 0x40728851E0000000, float noundef 0x40852CB860000000)
  store <4 x float> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.35, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <4 x float> @simde_mm_set_ps(float noundef 0x408D2799A0000000, float noundef 0x408D96CCC0000000, float noundef 0xC08B17AE20000000, float noundef 6.770000e+02)
  store <4 x float> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.35, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <4 x float> @simde_mm_set_ps(float noundef 0xC089C28F60000000, float noundef 0xC08CE38520000000, float noundef 0xC0463999A0000000, float noundef 0x407549EB80000000)
  store <4 x float> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <4 x float> @simde_mm_set_ps(float noundef 0x40881ECCC0000000, float noundef 0xC083DF47A0000000, float noundef 0x4086155C20000000, float noundef 0x407DD51EC0000000)
  store <4 x float> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <4 x float> @simde_mm_set_ps(float noundef 0xC089C28F60000000, float noundef 0xC08CE38520000000, float noundef 0xC0463999A0000000, float noundef 4.770000e+02)
  store <4 x float> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <4 x float> @simde_mm_set_ps(float noundef 0x408EFF8520000000, float noundef 0x408CB23D80000000, float noundef 0xC0834AE140000000, float noundef 0x408D202900000000)
  store <4 x float> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <4 x float> @simde_mm_set_ps(float noundef 0xC035FD70A0000000, float noundef 0x4071247AE0000000, float noundef 0x40899C6660000000, float noundef 0xC08DE9C280000000)
  store <4 x float> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <4 x float> @simde_mm_set_ps(float noundef 0x408EFF8520000000, float noundef 0x408CB23D80000000, float noundef 0xC0834AE140000000, float noundef -9.580000e+02)
  store <4 x float> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <4 x float> @simde_mm_set_ps(float noundef 0x40664AE140000000, float noundef 0xC08E090A40000000, float noundef 0x408DACCCC0000000, float noundef 0xC0863CF5C0000000)
  store <4 x float> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <4 x float> @simde_mm_set_ps(float noundef 0xC08DBCE140000000, float noundef 0x404AF70A40000000, float noundef 0x40778CA3E0000000, float noundef 0xC08BE18520000000)
  store <4 x float> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <4 x float> @simde_mm_set_ps(float noundef 0x40664AE140000000, float noundef 0xC08E090A40000000, float noundef 0x408DACCCC0000000, float noundef -8.930000e+02)
  store <4 x float> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <4 x float> @simde_mm_set_ps(float noundef 0xC08AD66660000000, float noundef 7.217500e+02, float noundef 0x407A6B3340000000, float noundef 0xC081EC6660000000)
  store <4 x float> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <4 x float> @simde_mm_set_ps(float noundef 0x407D9CF5C0000000, float noundef 0xC07D97AE20000000, float noundef 0x40897D8520000000, float noundef 5.207500e+02)
  store <4 x float> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <4 x float> @simde_mm_set_ps(float noundef 0xC08AD66660000000, float noundef 7.217500e+02, float noundef 0x407A6B3340000000, float noundef 5.200000e+02)
  store <4 x float> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <4 x float> @simde_mm_set_ps(float noundef 0xC08A8B0A40000000, float noundef 0x4019CCCCC0000000, float noundef 0xC08CFB99A0000000, float noundef 0xC061F8F5C0000000)
  store <4 x float> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <4 x float> @simde_mm_set_ps(float noundef 0x40828CB860000000, float noundef 0x4073A851E0000000, float noundef 0x405CF33340000000, float noundef 3.692500e+02)
  store <4 x float> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <4 x float> @simde_mm_set_ps(float noundef 0xC08A8B0A40000000, float noundef 0x4019CCCCC0000000, float noundef 0xC08CFB99A0000000, float noundef 3.690000e+02)
  store <4 x float> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <4 x float> @simde_mm_set_ps(float noundef 0xC0365C2900000000, float noundef 0x408BDD1EC0000000, float noundef 0x408730CCC0000000, float noundef 0x402B5C2900000000)
  store <4 x float> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <4 x float> @simde_mm_set_ps(float noundef 0x408C261480000000, float noundef 0xC086E8B860000000, float noundef 0xC061233340000000, float noundef 0xC05685C280000000)
  store <4 x float> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <4 x float> @simde_mm_set_ps(float noundef 0xC0365C2900000000, float noundef 0x408BDD1EC0000000, float noundef 0x408730CCC0000000, float noundef -9.100000e+01)
  store <4 x float> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <4 x float> @simde_mm_set_ps(float noundef 0xC08E89C280000000, float noundef 0xC058BEB860000000, float noundef 0xC06FA8A3E0000000, float noundef 0x4084C01480000000)
  store <4 x float> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <4 x float> @simde_mm_set_ps(float noundef 0x406F9F0A40000000, float noundef 0x4070A91EC0000000, float noundef 0xC0301C2900000000, float noundef 0xC0794547A0000000)
  store <4 x float> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.35, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <4 x float> @simde_mm_set_ps(float noundef 0xC08E89C280000000, float noundef 0xC058BEB860000000, float noundef 0xC06FA8A3E0000000, float noundef -4.050000e+02)
  store <4 x float> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup60

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.35], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.35, ptr %arrayidx, i32 0, i32 0
  %2 = load <4 x float>, ptr %a52, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx53 = getelementptr inbounds [8 x %struct.anon.35], ptr %test_vec, i64 0, i64 %3
  %b54 = getelementptr inbounds %struct.anon.35, ptr %arrayidx53, i32 0, i32 1
  %4 = load <4 x float>, ptr %b54, align 16, !tbaa !16
  %call55 = call <4 x float> @simde_mm_floor_ss(<4 x float> noundef %2, <4 x float> noundef %4)
  store <4 x float> %call55, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <4 x float>, ptr %r51, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx56 = getelementptr inbounds [8 x %struct.anon.35], ptr %test_vec, i64 0, i64 %6
  %r57 = getelementptr inbounds %struct.anon.35, ptr %arrayidx56, i32 0, i32 2
  %7 = load <4 x float>, ptr %r57, align 16, !tbaa !16
  %call58 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call59 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %5, <4 x float> noundef %7, float noundef %call58, ptr noundef @.str.72, i32 noundef 1766, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call59, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup60 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup60:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest61 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest61, label %cleanup62 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup60
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup62

cleanup62:                                        ; preds = %for.end, %cleanup60
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_insert_epi8() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.36], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r43 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.36], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.36, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 10, i8 noundef signext -18, i8 noundef signext -117, i8 noundef signext 95, i8 noundef signext -108, i8 noundef signext 57, i8 noundef signext 54, i8 noundef signext -50, i8 noundef signext 60, i8 noundef signext -68, i8 noundef signext 115, i8 noundef signext 14, i8 noundef signext -71, i8 noundef signext -40, i8 noundef signext 34, i8 noundef signext 112)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.36, ptr %arrayinit.begin, i32 0, i32 1
  store i32 6, ptr %b, align 16, !tbaa !23
  %r = getelementptr inbounds %struct.anon.36, ptr %arrayinit.begin, i32 0, i32 2
  %call1 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 10, i8 noundef signext -18, i8 noundef signext -117, i8 noundef signext 6, i8 noundef signext -108, i8 noundef signext 57, i8 noundef signext 54, i8 noundef signext -50, i8 noundef signext 60, i8 noundef signext -68, i8 noundef signext 115, i8 noundef signext 14, i8 noundef signext -71, i8 noundef signext -40, i8 noundef signext 34, i8 noundef signext 112)
  store <2 x i64> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.36, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -117, i8 noundef signext 67, i8 noundef signext -105, i8 noundef signext 26, i8 noundef signext 118, i8 noundef signext 67, i8 noundef signext 72, i8 noundef signext 120, i8 noundef signext -74, i8 noundef signext -8, i8 noundef signext -126, i8 noundef signext -39, i8 noundef signext 53, i8 noundef signext 74, i8 noundef signext 64, i8 noundef signext -74)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %b4 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element, i32 0, i32 1
  store i32 13, ptr %b4, align 16, !tbaa !23
  %r5 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element, i32 0, i32 2
  %call6 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -117, i8 noundef signext 67, i8 noundef signext -105, i8 noundef signext 13, i8 noundef signext 118, i8 noundef signext 67, i8 noundef signext 72, i8 noundef signext 120, i8 noundef signext -74, i8 noundef signext -8, i8 noundef signext -126, i8 noundef signext -39, i8 noundef signext 53, i8 noundef signext 74, i8 noundef signext 64, i8 noundef signext -74)
  store <2 x i64> %call6, ptr %r5, align 16, !tbaa !16
  %arrayinit.element7 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element, i64 1
  %a8 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element7, i32 0, i32 0
  %call9 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 10, i8 noundef signext -114, i8 noundef signext 116, i8 noundef signext -108, i8 noundef signext 36, i8 noundef signext -74, i8 noundef signext 76, i8 noundef signext -2, i8 noundef signext 118, i8 noundef signext -60, i8 noundef signext 3, i8 noundef signext 48, i8 noundef signext 76, i8 noundef signext -18, i8 noundef signext -69, i8 noundef signext -110)
  store <2 x i64> %call9, ptr %a8, align 16, !tbaa !16
  %b10 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element7, i32 0, i32 1
  store i32 13, ptr %b10, align 16, !tbaa !23
  %r11 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element7, i32 0, i32 2
  %call12 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 10, i8 noundef signext -114, i8 noundef signext 116, i8 noundef signext 13, i8 noundef signext 36, i8 noundef signext -74, i8 noundef signext 76, i8 noundef signext -2, i8 noundef signext 118, i8 noundef signext -60, i8 noundef signext 3, i8 noundef signext 48, i8 noundef signext 76, i8 noundef signext -18, i8 noundef signext -69, i8 noundef signext -110)
  store <2 x i64> %call12, ptr %r11, align 16, !tbaa !16
  %arrayinit.element13 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element7, i64 1
  %a14 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element13, i32 0, i32 0
  %call15 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -48, i8 noundef signext -33, i8 noundef signext -9, i8 noundef signext -27, i8 noundef signext -99, i8 noundef signext 29, i8 noundef signext 111, i8 noundef signext 85, i8 noundef signext 104, i8 noundef signext -59, i8 noundef signext -17, i8 noundef signext 23, i8 noundef signext 113, i8 noundef signext 8, i8 noundef signext 94, i8 noundef signext -32)
  store <2 x i64> %call15, ptr %a14, align 16, !tbaa !16
  %b16 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element13, i32 0, i32 1
  store i32 0, ptr %b16, align 16, !tbaa !23
  %r17 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element13, i32 0, i32 2
  %call18 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -48, i8 noundef signext -33, i8 noundef signext -9, i8 noundef signext 0, i8 noundef signext -99, i8 noundef signext 29, i8 noundef signext 111, i8 noundef signext 85, i8 noundef signext 104, i8 noundef signext -59, i8 noundef signext -17, i8 noundef signext 23, i8 noundef signext 113, i8 noundef signext 8, i8 noundef signext 94, i8 noundef signext -32)
  store <2 x i64> %call18, ptr %r17, align 16, !tbaa !16
  %arrayinit.element19 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element13, i64 1
  %a20 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element19, i32 0, i32 0
  %call21 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -15, i8 noundef signext -126, i8 noundef signext 63, i8 noundef signext 14, i8 noundef signext 2, i8 noundef signext 88, i8 noundef signext -73, i8 noundef signext 22, i8 noundef signext -36, i8 noundef signext 60, i8 noundef signext -75, i8 noundef signext -26, i8 noundef signext -12, i8 noundef signext -126, i8 noundef signext 44, i8 noundef signext -36)
  store <2 x i64> %call21, ptr %a20, align 16, !tbaa !16
  %b22 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element19, i32 0, i32 1
  store i32 8, ptr %b22, align 16, !tbaa !23
  %r23 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element19, i32 0, i32 2
  %call24 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -15, i8 noundef signext -126, i8 noundef signext 63, i8 noundef signext 8, i8 noundef signext 2, i8 noundef signext 88, i8 noundef signext -73, i8 noundef signext 22, i8 noundef signext -36, i8 noundef signext 60, i8 noundef signext -75, i8 noundef signext -26, i8 noundef signext -12, i8 noundef signext -126, i8 noundef signext 44, i8 noundef signext -36)
  store <2 x i64> %call24, ptr %r23, align 16, !tbaa !16
  %arrayinit.element25 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element19, i64 1
  %a26 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element25, i32 0, i32 0
  %call27 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 41, i8 noundef signext -102, i8 noundef signext 115, i8 noundef signext 65, i8 noundef signext 22, i8 noundef signext -32, i8 noundef signext -29, i8 noundef signext 85, i8 noundef signext -61, i8 noundef signext 79, i8 noundef signext -107, i8 noundef signext -9, i8 noundef signext 89, i8 noundef signext -3, i8 noundef signext -124, i8 noundef signext 71)
  store <2 x i64> %call27, ptr %a26, align 16, !tbaa !16
  %b28 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element25, i32 0, i32 1
  store i32 4, ptr %b28, align 16, !tbaa !23
  %r29 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element25, i32 0, i32 2
  %call30 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 41, i8 noundef signext -102, i8 noundef signext 115, i8 noundef signext 4, i8 noundef signext 22, i8 noundef signext -32, i8 noundef signext -29, i8 noundef signext 85, i8 noundef signext -61, i8 noundef signext 79, i8 noundef signext -107, i8 noundef signext -9, i8 noundef signext 89, i8 noundef signext -3, i8 noundef signext -124, i8 noundef signext 71)
  store <2 x i64> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element25, i64 1
  %a32 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 109, i8 noundef signext -46, i8 noundef signext -71, i8 noundef signext 107, i8 noundef signext 105, i8 noundef signext 123, i8 noundef signext -72, i8 noundef signext 72, i8 noundef signext -43, i8 noundef signext 111, i8 noundef signext 75, i8 noundef signext 60, i8 noundef signext 47, i8 noundef signext 78, i8 noundef signext -45, i8 noundef signext -101)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %b34 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element31, i32 0, i32 1
  store i32 7, ptr %b34, align 16, !tbaa !23
  %r35 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element31, i32 0, i32 2
  %call36 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 109, i8 noundef signext -46, i8 noundef signext -71, i8 noundef signext 7, i8 noundef signext 105, i8 noundef signext 123, i8 noundef signext -72, i8 noundef signext 72, i8 noundef signext -43, i8 noundef signext 111, i8 noundef signext 75, i8 noundef signext 60, i8 noundef signext 47, i8 noundef signext 78, i8 noundef signext -45, i8 noundef signext -101)
  store <2 x i64> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element31, i64 1
  %a38 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -15, i8 noundef signext -23, i8 noundef signext 43, i8 noundef signext 15, i8 noundef signext -126, i8 noundef signext 102, i8 noundef signext 109, i8 noundef signext 84, i8 noundef signext -63, i8 noundef signext 80, i8 noundef signext -127, i8 noundef signext -46, i8 noundef signext -119, i8 noundef signext 111, i8 noundef signext -57, i8 noundef signext 55)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element37, i32 0, i32 1
  store i32 15, ptr %b40, align 16, !tbaa !23
  %r41 = getelementptr inbounds %struct.anon.36, ptr %arrayinit.element37, i32 0, i32 2
  %call42 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -15, i8 noundef signext -23, i8 noundef signext 43, i8 noundef signext 15, i8 noundef signext -126, i8 noundef signext 102, i8 noundef signext 109, i8 noundef signext 84, i8 noundef signext -63, i8 noundef signext 80, i8 noundef signext -127, i8 noundef signext -46, i8 noundef signext -119, i8 noundef signext 111, i8 noundef signext -57, i8 noundef signext 55)
  store <2 x i64> %call42, ptr %r41, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup51

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r43) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.36], ptr %test_vec, i64 0, i64 %1
  %a44 = getelementptr inbounds %struct.anon.36, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a44, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx45 = getelementptr inbounds [8 x %struct.anon.36], ptr %test_vec, i64 0, i64 %3
  %b46 = getelementptr inbounds %struct.anon.36, ptr %arrayidx45, i32 0, i32 1
  %4 = load i32, ptr %b46, align 16, !tbaa !23
  %call47 = call <2 x i64> @simde_mm_insert_epi8(<2 x i64> noundef %2, i32 noundef %4, i32 noundef 12)
  store <2 x i64> %call47, ptr %r43, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r43, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx48 = getelementptr inbounds [8 x %struct.anon.36], ptr %test_vec, i64 0, i64 %6
  %r49 = getelementptr inbounds %struct.anon.36, ptr %arrayidx48, i32 0, i32 2
  %7 = load <2 x i64>, ptr %r49, align 16, !tbaa !16
  %call50 = call i32 @simde_test_x86_assert_equal_i8x16_(<2 x i64> noundef %5, <2 x i64> noundef %7, ptr noundef @.str.72, i32 noundef 1855, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call50, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r43) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup51 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup51:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest52 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest52, label %cleanup53 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup51
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup53

cleanup53:                                        ; preds = %for.end, %cleanup51
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_insert_epi32() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.37], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r43 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.37], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.37, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1714139829, i32 noundef 980372706, i32 noundef -2140490700, i32 noundef 1671335242)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.37, ptr %arrayinit.begin, i32 0, i32 1
  store i32 -570572581, ptr %b, align 16, !tbaa !23
  %r = getelementptr inbounds %struct.anon.37, ptr %arrayinit.begin, i32 0, i32 2
  %call1 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -570572581, i32 noundef 980372706, i32 noundef -2140490700, i32 noundef 1671335242)
  store <2 x i64> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.37, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -385110226, i32 noundef 1048550831, i32 noundef -768686987, i32 noundef -197993270)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %b4 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element, i32 0, i32 1
  store i32 292040766, ptr %b4, align 16, !tbaa !23
  %r5 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element, i32 0, i32 2
  %call6 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 292040766, i32 noundef 1048550831, i32 noundef -768686987, i32 noundef -197993270)
  store <2 x i64> %call6, ptr %r5, align 16, !tbaa !16
  %arrayinit.element7 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element, i64 1
  %a8 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element7, i32 0, i32 0
  %call9 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1804855856, i32 noundef -940421248, i32 noundef -2104492113, i32 noundef 529461525)
  store <2 x i64> %call9, ptr %a8, align 16, !tbaa !16
  %b10 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element7, i32 0, i32 1
  store i32 514665012, ptr %b10, align 16, !tbaa !23
  %r11 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element7, i32 0, i32 2
  %call12 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 514665012, i32 noundef -940421248, i32 noundef -2104492113, i32 noundef 529461525)
  store <2 x i64> %call12, ptr %r11, align 16, !tbaa !16
  %arrayinit.element13 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element7, i64 1
  %a14 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element13, i32 0, i32 0
  %call15 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -85551175, i32 noundef 885869319, i32 noundef 2003605165, i32 noundef -219227805)
  store <2 x i64> %call15, ptr %a14, align 16, !tbaa !16
  %b16 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element13, i32 0, i32 1
  store i32 1214139778, ptr %b16, align 16, !tbaa !23
  %r17 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element13, i32 0, i32 2
  %call18 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1214139778, i32 noundef 885869319, i32 noundef 2003605165, i32 noundef -219227805)
  store <2 x i64> %call18, ptr %r17, align 16, !tbaa !16
  %arrayinit.element19 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element13, i64 1
  %a20 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element19, i32 0, i32 0
  %call21 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -682699624, i32 noundef -729535744, i32 noundef -714850455, i32 noundef 418841580)
  store <2 x i64> %call21, ptr %a20, align 16, !tbaa !16
  %b22 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element19, i32 0, i32 1
  store i32 -606767281, ptr %b22, align 16, !tbaa !23
  %r23 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element19, i32 0, i32 2
  %call24 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -606767281, i32 noundef -729535744, i32 noundef -714850455, i32 noundef 418841580)
  store <2 x i64> %call24, ptr %r23, align 16, !tbaa !16
  %arrayinit.element25 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element19, i64 1
  %a26 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element25, i32 0, i32 0
  %call27 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1844877442, i32 noundef -1305620543, i32 noundef -803345723, i32 noundef -1617611400)
  store <2 x i64> %call27, ptr %a26, align 16, !tbaa !16
  %b28 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element25, i32 0, i32 1
  store i32 166894477, ptr %b28, align 16, !tbaa !23
  %r29 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element25, i32 0, i32 2
  %call30 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 166894477, i32 noundef -1305620543, i32 noundef -803345723, i32 noundef -1617611400)
  store <2 x i64> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element25, i64 1
  %a32 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1121577587, i32 noundef 1868325196, i32 noundef 567002451, i32 noundef -2029289287)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %b34 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element31, i32 0, i32 1
  store i32 566028624, ptr %b34, align 16, !tbaa !23
  %r35 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element31, i32 0, i32 2
  %call36 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 566028624, i32 noundef 1868325196, i32 noundef 567002451, i32 noundef -2029289287)
  store <2 x i64> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element31, i64 1
  %a38 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1745932520, i32 noundef 83968460, i32 noundef -1677360074, i32 noundef -664327669)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element37, i32 0, i32 1
  store i32 -2041481189, ptr %b40, align 16, !tbaa !23
  %r41 = getelementptr inbounds %struct.anon.37, ptr %arrayinit.element37, i32 0, i32 2
  %call42 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -2041481189, i32 noundef 83968460, i32 noundef -1677360074, i32 noundef -664327669)
  store <2 x i64> %call42, ptr %r41, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup51

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r43) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.37], ptr %test_vec, i64 0, i64 %1
  %a44 = getelementptr inbounds %struct.anon.37, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a44, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx45 = getelementptr inbounds [8 x %struct.anon.37], ptr %test_vec, i64 0, i64 %3
  %b46 = getelementptr inbounds %struct.anon.37, ptr %arrayidx45, i32 0, i32 1
  %4 = load i32, ptr %b46, align 16, !tbaa !23
  %call47 = call <2 x i64> @simde_mm_insert_epi32(<2 x i64> noundef %2, i32 noundef %4, i32 noundef 3)
  store <2 x i64> %call47, ptr %r43, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r43, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx48 = getelementptr inbounds [8 x %struct.anon.37], ptr %test_vec, i64 0, i64 %6
  %r49 = getelementptr inbounds %struct.anon.37, ptr %arrayidx48, i32 0, i32 2
  %7 = load <2 x i64>, ptr %r49, align 16, !tbaa !16
  %call50 = call i32 @simde_test_x86_assert_equal_i32x4_(<2 x i64> noundef %5, <2 x i64> noundef %7, ptr noundef @.str.72, i32 noundef 1896, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call50, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r43) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup51 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup51:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest52 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest52, label %cleanup53 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup51
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup53

cleanup53:                                        ; preds = %for.end, %cleanup51
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_insert_epi64() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.38], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r43 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.38], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.38, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 7362174507306405090, i64 noundef -9193337552220811958)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.38, ptr %arrayinit.begin, i32 0, i32 1
  store i64 -850374615753703205, ptr %b, align 16, !tbaa !25
  %r = getelementptr inbounds %struct.anon.38, ptr %arrayinit.begin, i32 0, i32 2
  %call1 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -850374615753703205, i64 noundef -9193337552220811958)
  store <2 x i64> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.38, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 1254305542978645806, i64 noundef 4503491530864903285)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %b4 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element, i32 0, i32 1
  store i64 -9038724799495474923, ptr %b4, align 16, !tbaa !25
  %r5 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element, i32 0, i32 2
  %call6 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -9038724799495474923, i64 noundef 4503491530864903285)
  store <2 x i64> %call6, ptr %r5, align 16, !tbaa !16
  %arrayinit.element7 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element, i64 1
  %a8 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element7, i32 0, i32 0
  %call9 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -941576252334200268, i64 noundef 7751796878868631424)
  store <2 x i64> %call9, ptr %a8, align 16, !tbaa !16
  %b10 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element7, i32 0, i32 1
  store i64 3804779755638396589, ptr %b10, align 16, !tbaa !25
  %r11 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element7, i32 0, i32 2
  %call12 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 3804779755638396589, i64 noundef 7751796878868631424)
  store <2 x i64> %call12, ptr %r11, align 16, !tbaa !16
  %arrayinit.element13 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element7, i64 1
  %a14 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element13, i32 0, i32 0
  %call15 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -3070259325336878100, i64 noundef 5214690643492116409)
  store <2 x i64> %call15, ptr %a14, align 16, !tbaa !16
  %b16 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element13, i32 0, i32 1
  store i64 -2932172554506065152, ptr %b16, align 16, !tbaa !25
  %r17 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element13, i32 0, i32 2
  %call18 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -2932172554506065152, i64 noundef 5214690643492116409)
  store <2 x i64> %call18, ptr %r17, align 16, !tbaa !16
  %arrayinit.element19 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element13, i64 1
  %a20 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element19, i32 0, i32 0
  %call21 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -5607597529679140155, i64 noundef -6947588056948574385)
  store <2 x i64> %call21, ptr %a20, align 16, !tbaa !16
  %b22 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element19, i32 0, i32 1
  store i64 716806322442901634, ptr %b22, align 16, !tbaa !25
  %r23 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element19, i32 0, i32 2
  %call24 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 716806322442901634, i64 noundef -6947588056948574385)
  store <2 x i64> %call24, ptr %r23, align 16, !tbaa !16
  %arrayinit.element25 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element19, i64 1
  %a26 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element25, i32 0, i32 0
  %call27 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 4817139057959919948, i64 noundef 2435256986062520505)
  store <2 x i64> %call27, ptr %a26, align 16, !tbaa !16
  %b28 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element25, i32 0, i32 1
  store i64 -2853265611616884400, ptr %b28, align 16, !tbaa !25
  %r29 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element25, i32 0, i32 2
  %call30 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -2853265611616884400, i64 noundef 2435256986062520505)
  store <2 x i64> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element25, i64 1
  %a32 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -8768094940408262424, i64 noundef 360641792213091382)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %b34 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element31, i32 0, i32 1
  store i64 -4200371864439390341, ptr %b34, align 16, !tbaa !25
  %r35 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element31, i32 0, i32 2
  %call36 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -4200371864439390341, i64 noundef 360641792213091382)
  store <2 x i64> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element31, i64 1
  %a38 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef -6597763380374804743, i64 noundef 8897544020142746680)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element37, i32 0, i32 1
  store i64 6543676199726157119, ptr %b40, align 16, !tbaa !25
  %r41 = getelementptr inbounds %struct.anon.38, ptr %arrayinit.element37, i32 0, i32 2
  %call42 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 6543676199726157119, i64 noundef 8897544020142746680)
  store <2 x i64> %call42, ptr %r41, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup51

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r43) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.38], ptr %test_vec, i64 0, i64 %1
  %a44 = getelementptr inbounds %struct.anon.38, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a44, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx45 = getelementptr inbounds [8 x %struct.anon.38], ptr %test_vec, i64 0, i64 %3
  %b46 = getelementptr inbounds %struct.anon.38, ptr %arrayidx45, i32 0, i32 1
  %4 = load i64, ptr %b46, align 16, !tbaa !25
  %call47 = call <2 x i64> @simde_mm_insert_epi64(<2 x i64> noundef %2, i64 noundef %4, i32 noundef 1)
  store <2 x i64> %call47, ptr %r43, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r43, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx48 = getelementptr inbounds [8 x %struct.anon.38], ptr %test_vec, i64 0, i64 %6
  %r49 = getelementptr inbounds %struct.anon.38, ptr %arrayidx48, i32 0, i32 2
  %7 = load <2 x i64>, ptr %r49, align 16, !tbaa !16
  %call50 = call i32 @simde_test_x86_assert_equal_i64x2_(<2 x i64> noundef %5, <2 x i64> noundef %7, ptr noundef @.str.72, i32 noundef 1937, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call50, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r43) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup51 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup51:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest52 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest52, label %cleanup53 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup51
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup53

cleanup53:                                        ; preds = %for.end, %cleanup51
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_insert_ps() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec_0 = alloca [8 x %struct.anon.39], align 16
  %test_vec_3 = alloca [8 x %struct.anon.40], align 16
  %test_vec_4 = alloca [8 x %struct.anon.41], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a51 = alloca <4 x float>, align 16
  %b54 = alloca <4 x float>, align 16
  %r59 = alloca <4 x float>, align 16
  %i71 = alloca i64, align 8
  %r76 = alloca <4 x float>, align 16
  %i100 = alloca i64, align 8
  %a105 = alloca <4 x float>, align 16
  %b110 = alloca <4 x float>, align 16
  %r115 = alloca <4 x float>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec_0) #10
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %test_vec_0, ptr align 16 @__const.test_simde_mm_insert_ps.test_vec_0, i64 384, i1 false)
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec_3) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.40], ptr %test_vec_3, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.40, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <4 x float> @simde_mm_set_ps(float noundef 0xC08A4A6660000000, float noundef 2.352500e+02, float noundef 0xC0850EA3E0000000, float noundef 0xC085E23D80000000)
  store <4 x float> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.40, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <4 x float> @simde_mm_set_ps(float noundef 0x405703D700000000, float noundef 0x4086FF99A0000000, float noundef 0x40657851E0000000, float noundef 0x408424CCC0000000)
  store <4 x float> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.40, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <4 x float> @simde_mm_set_ps(float noundef 0xC08A4A6660000000, float noundef 2.352500e+02, float noundef 0.000000e+00, float noundef 0.000000e+00)
  store <4 x float> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.40, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <4 x float> @simde_mm_set_ps(float noundef 0x408493C280000000, float noundef 0xC0781E3D80000000, float noundef 0x408CA451E0000000, float noundef 0xC08D487AE0000000)
  store <4 x float> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <4 x float> @simde_mm_set_ps(float noundef 0xC06A27AE20000000, float noundef -6.550000e+02, float noundef 0xC086943D80000000, float noundef 0xC07F668F60000000)
  store <4 x float> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <4 x float> @simde_mm_set_ps(float noundef 0x408493C280000000, float noundef 0xC0781E3D80000000, float noundef 0.000000e+00, float noundef 0.000000e+00)
  store <4 x float> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <4 x float> @simde_mm_set_ps(float noundef 0x4076C947A0000000, float noundef 0xC079273340000000, float noundef 0xC06F9851E0000000, float noundef 0x408069D700000000)
  store <4 x float> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <4 x float> @simde_mm_set_ps(float noundef 0xC084F3C280000000, float noundef 0x40860599A0000000, float noundef 0xC02B0A3D80000000, float noundef 0xC0748C7AE0000000)
  store <4 x float> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <4 x float> @simde_mm_set_ps(float noundef 0x4076C947A0000000, float noundef 0xC079273340000000, float noundef 0.000000e+00, float noundef 0.000000e+00)
  store <4 x float> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <4 x float> @simde_mm_set_ps(float noundef 0x407398CCC0000000, float noundef 0x4074EE3D80000000, float noundef 0xC08B6EF5C0000000, float noundef 0xC08E72CCC0000000)
  store <4 x float> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <4 x float> @simde_mm_set_ps(float noundef 0x4086271EC0000000, float noundef 0x404E251EC0000000, float noundef 0x407A0947A0000000, float noundef 0xC0668BD700000000)
  store <4 x float> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <4 x float> @simde_mm_set_ps(float noundef 0x407398CCC0000000, float noundef 0x4074EE3D80000000, float noundef 0.000000e+00, float noundef 0.000000e+00)
  store <4 x float> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <4 x float> @simde_mm_set_ps(float noundef 0x408ACC1480000000, float noundef 0x408511AE20000000, float noundef 0x408B951EC0000000, float noundef 0x406DCF0A40000000)
  store <4 x float> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <4 x float> @simde_mm_set_ps(float noundef 0x40816399A0000000, float noundef -2.807500e+02, float noundef 0xC089EE7AE0000000, float noundef 0x405C65C280000000)
  store <4 x float> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <4 x float> @simde_mm_set_ps(float noundef 0x408ACC1480000000, float noundef 0x408511AE20000000, float noundef 0.000000e+00, float noundef 0.000000e+00)
  store <4 x float> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <4 x float> @simde_mm_set_ps(float noundef 0x40804347A0000000, float noundef 0xC06F6AE140000000, float noundef 0x408C061480000000, float noundef 0xC07A375C20000000)
  store <4 x float> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <4 x float> @simde_mm_set_ps(float noundef 0x4055CCCCC0000000, float noundef 0x407668A3E0000000, float noundef 0x408AD82900000000, float noundef 0xC0716570A0000000)
  store <4 x float> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <4 x float> @simde_mm_set_ps(float noundef 0x40804347A0000000, float noundef 0xC06F6AE140000000, float noundef 0.000000e+00, float noundef 0.000000e+00)
  store <4 x float> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <4 x float> @simde_mm_set_ps(float noundef 0x4080AC1480000000, float noundef 0x408E435C20000000, float noundef 0xC074CE3D80000000, float noundef 0x406120F5C0000000)
  store <4 x float> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <4 x float> @simde_mm_set_ps(float noundef 0xC071573340000000, float noundef 0x4085EB3340000000, float noundef 0xC07F411EC0000000, float noundef 0xC088A2A3E0000000)
  store <4 x float> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <4 x float> @simde_mm_set_ps(float noundef 0x4080AC1480000000, float noundef 0x408E435C20000000, float noundef 0.000000e+00, float noundef 0.000000e+00)
  store <4 x float> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <4 x float> @simde_mm_set_ps(float noundef 0xC07D482900000000, float noundef 0xC0842399A0000000, float noundef 0xC07450F5C0000000, float noundef 0x408F127AE0000000)
  store <4 x float> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <4 x float> @simde_mm_set_ps(float noundef 0x40722B8520000000, float noundef 0x40824ACCC0000000, float noundef 0x4084EBD700000000, float noundef 0x4050447AE0000000)
  store <4 x float> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.40, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <4 x float> @simde_mm_set_ps(float noundef 0xC07D482900000000, float noundef 0xC0842399A0000000, float noundef 0.000000e+00, float noundef 0.000000e+00)
  store <4 x float> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec_4) #10
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %test_vec_4, ptr align 16 @__const.test_simde_mm_insert_ps.test_vec_4, i64 384, i1 false)
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup69

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %a51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.39], ptr %test_vec_0, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.39, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [4 x float], ptr %a52, i64 0, i64 0
  %call53 = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay)
  store <4 x float> %call53, ptr %a51, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %b54) #10
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx55 = getelementptr inbounds [8 x %struct.anon.39], ptr %test_vec_0, i64 0, i64 %2
  %b56 = getelementptr inbounds %struct.anon.39, ptr %arrayidx55, i32 0, i32 1
  %arraydecay57 = getelementptr inbounds [4 x float], ptr %b56, i64 0, i64 0
  %call58 = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay57)
  store <4 x float> %call58, ptr %b54, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r59) #10
  %3 = load <4 x float>, ptr %a51, align 16, !tbaa !16
  %4 = load <4 x float>, ptr %b54, align 16, !tbaa !16
  %call60 = call <4 x float> @simde_mm_insert_ps(<4 x float> noundef %3, <4 x float> noundef %4, i32 noundef 0)
  store <4 x float> %call60, ptr %r59, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <4 x float>, ptr %r59, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx61 = getelementptr inbounds [8 x %struct.anon.39], ptr %test_vec_0, i64 0, i64 %6
  %r62 = getelementptr inbounds %struct.anon.39, ptr %arrayidx61, i32 0, i32 2
  %arraydecay63 = getelementptr inbounds [4 x float], ptr %r62, i64 0, i64 0
  %call64 = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay63)
  %call65 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call66 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %5, <4 x float> noundef %call64, float noundef %call65, ptr noundef @.str.72, i32 noundef 2053, ptr noundef @.str.73, ptr noundef @.str.89)
  %tobool = icmp ne i32 %call66, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r59) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %b54) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup69 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %7 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %7, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup69:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest70 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest70, label %cleanup139 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup69
  call void @llvm.lifetime.start.p0(i64 8, ptr %i71) #10
  store i64 0, ptr %i71, align 8, !tbaa !11
  br label %for.cond72

for.cond72:                                       ; preds = %for.inc95, %for.end
  %8 = load i64, ptr %i71, align 8, !tbaa !11
  %cmp73 = icmp ult i64 %8, 8
  br i1 %cmp73, label %for.body75, label %for.cond.cleanup74

for.cond.cleanup74:                               ; preds = %for.cond72
  store i32 7, ptr %cleanup.dest.slot, align 4
  br label %cleanup97

for.body75:                                       ; preds = %for.cond72
  call void @llvm.lifetime.start.p0(i64 16, ptr %r76) #10
  %9 = load i64, ptr %i71, align 8, !tbaa !11
  %arrayidx77 = getelementptr inbounds [8 x %struct.anon.40], ptr %test_vec_3, i64 0, i64 %9
  %a78 = getelementptr inbounds %struct.anon.40, ptr %arrayidx77, i32 0, i32 0
  %10 = load <4 x float>, ptr %a78, align 16, !tbaa !16
  %11 = load i64, ptr %i71, align 8, !tbaa !11
  %arrayidx79 = getelementptr inbounds [8 x %struct.anon.40], ptr %test_vec_3, i64 0, i64 %11
  %b80 = getelementptr inbounds %struct.anon.40, ptr %arrayidx79, i32 0, i32 1
  %12 = load <4 x float>, ptr %b80, align 16, !tbaa !16
  %call81 = call <4 x float> @simde_mm_insert_ps(<4 x float> noundef %10, <4 x float> noundef %12, i32 noundef 3)
  store <4 x float> %call81, ptr %r76, align 16, !tbaa !16
  br label %do.body82

do.body82:                                        ; preds = %for.body75
  %13 = load <4 x float>, ptr %r76, align 16, !tbaa !16
  %14 = load i64, ptr %i71, align 8, !tbaa !11
  %arrayidx83 = getelementptr inbounds [8 x %struct.anon.40], ptr %test_vec_3, i64 0, i64 %14
  %r84 = getelementptr inbounds %struct.anon.40, ptr %arrayidx83, i32 0, i32 2
  %15 = load <4 x float>, ptr %r84, align 16, !tbaa !16
  %call85 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call86 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %13, <4 x float> noundef %15, float noundef %call85, ptr noundef @.str.72, i32 noundef 2059, ptr noundef @.str.73, ptr noundef @.str.90)
  %tobool87 = icmp ne i32 %call86, 0
  br i1 %tobool87, label %if.then88, label %if.end89

if.then88:                                        ; preds = %do.body82
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup92

if.end89:                                         ; preds = %do.body82
  br label %do.cond90

do.cond90:                                        ; preds = %if.end89
  br label %do.end91

do.end91:                                         ; preds = %do.cond90
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup92

cleanup92:                                        ; preds = %do.end91, %if.then88
  call void @llvm.lifetime.end.p0(i64 16, ptr %r76) #10
  %cleanup.dest93 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest93, label %cleanup97 [
    i32 0, label %cleanup.cont94
  ]

cleanup.cont94:                                   ; preds = %cleanup92
  br label %for.inc95

for.inc95:                                        ; preds = %cleanup.cont94
  %16 = load i64, ptr %i71, align 8, !tbaa !11
  %inc96 = add i64 %16, 1
  store i64 %inc96, ptr %i71, align 8, !tbaa !11
  br label %for.cond72

cleanup97:                                        ; preds = %cleanup92, %for.cond.cleanup74
  call void @llvm.lifetime.end.p0(i64 8, ptr %i71) #10
  %cleanup.dest98 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest98, label %cleanup139 [
    i32 7, label %for.end99
  ]

for.end99:                                        ; preds = %cleanup97
  call void @llvm.lifetime.start.p0(i64 8, ptr %i100) #10
  store i64 0, ptr %i100, align 8, !tbaa !11
  br label %for.cond101

for.cond101:                                      ; preds = %for.inc134, %for.end99
  %17 = load i64, ptr %i100, align 8, !tbaa !11
  %cmp102 = icmp ult i64 %17, 8
  br i1 %cmp102, label %for.body104, label %for.cond.cleanup103

for.cond.cleanup103:                              ; preds = %for.cond101
  store i32 12, ptr %cleanup.dest.slot, align 4
  br label %cleanup136

for.body104:                                      ; preds = %for.cond101
  call void @llvm.lifetime.start.p0(i64 16, ptr %a105) #10
  %18 = load i64, ptr %i100, align 8, !tbaa !11
  %arrayidx106 = getelementptr inbounds [8 x %struct.anon.41], ptr %test_vec_4, i64 0, i64 %18
  %a107 = getelementptr inbounds %struct.anon.41, ptr %arrayidx106, i32 0, i32 0
  %arraydecay108 = getelementptr inbounds [4 x float], ptr %a107, i64 0, i64 0
  %call109 = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay108)
  store <4 x float> %call109, ptr %a105, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %b110) #10
  %19 = load i64, ptr %i100, align 8, !tbaa !11
  %arrayidx111 = getelementptr inbounds [8 x %struct.anon.41], ptr %test_vec_4, i64 0, i64 %19
  %b112 = getelementptr inbounds %struct.anon.41, ptr %arrayidx111, i32 0, i32 1
  %arraydecay113 = getelementptr inbounds [4 x float], ptr %b112, i64 0, i64 0
  %call114 = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay113)
  store <4 x float> %call114, ptr %b110, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r115) #10
  %20 = load <4 x float>, ptr %a105, align 16, !tbaa !16
  %21 = load <4 x float>, ptr %b110, align 16, !tbaa !16
  %call116 = call <4 x float> @simde_mm_insert_ps(<4 x float> noundef %20, <4 x float> noundef %21, i32 noundef 4)
  store <4 x float> %call116, ptr %r115, align 16, !tbaa !16
  br label %do.body117

do.body117:                                       ; preds = %for.body104
  %22 = load <4 x float>, ptr %r115, align 16, !tbaa !16
  %23 = load i64, ptr %i100, align 8, !tbaa !11
  %arrayidx118 = getelementptr inbounds [8 x %struct.anon.41], ptr %test_vec_4, i64 0, i64 %23
  %r119 = getelementptr inbounds %struct.anon.41, ptr %arrayidx118, i32 0, i32 2
  %arraydecay120 = getelementptr inbounds [4 x float], ptr %r119, i64 0, i64 0
  %call121 = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay120)
  %call122 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call123 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %22, <4 x float> noundef %call121, float noundef %call122, ptr noundef @.str.72, i32 noundef 2066, ptr noundef @.str.73, ptr noundef @.str.91)
  %tobool124 = icmp ne i32 %call123, 0
  br i1 %tobool124, label %if.then125, label %if.end126

if.then125:                                       ; preds = %do.body117
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup129

if.end126:                                        ; preds = %do.body117
  br label %do.cond127

do.cond127:                                       ; preds = %if.end126
  br label %do.end128

do.end128:                                        ; preds = %do.cond127
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup129

cleanup129:                                       ; preds = %do.end128, %if.then125
  call void @llvm.lifetime.end.p0(i64 16, ptr %r115) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %b110) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a105) #10
  %cleanup.dest132 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest132, label %cleanup136 [
    i32 0, label %cleanup.cont133
  ]

cleanup.cont133:                                  ; preds = %cleanup129
  br label %for.inc134

for.inc134:                                       ; preds = %cleanup.cont133
  %24 = load i64, ptr %i100, align 8, !tbaa !11
  %inc135 = add i64 %24, 1
  store i64 %inc135, ptr %i100, align 8, !tbaa !11
  br label %for.cond101

cleanup136:                                       ; preds = %cleanup129, %for.cond.cleanup103
  call void @llvm.lifetime.end.p0(i64 8, ptr %i100) #10
  %cleanup.dest137 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest137, label %cleanup139 [
    i32 12, label %for.end138
  ]

for.end138:                                       ; preds = %cleanup136
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup139

cleanup139:                                       ; preds = %for.end138, %cleanup136, %cleanup97, %cleanup69
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec_4) #10
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec_3) #10
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec_0) #10
  %25 = load i32, ptr %retval, align 4
  ret i32 %25
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_max_epi8() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.42], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.42], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.42, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -83, i8 noundef signext 29, i8 noundef signext 3, i8 noundef signext 84, i8 noundef signext 22, i8 noundef signext -7, i8 noundef signext 112, i8 noundef signext -107, i8 noundef signext -53, i8 noundef signext -125, i8 noundef signext -41, i8 noundef signext -27, i8 noundef signext -118, i8 noundef signext 43, i8 noundef signext 44, i8 noundef signext 16)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.42, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -80, i8 noundef signext -52, i8 noundef signext 93, i8 noundef signext 71, i8 noundef signext 45, i8 noundef signext -99, i8 noundef signext -14, i8 noundef signext -97, i8 noundef signext 11, i8 noundef signext 62, i8 noundef signext 111, i8 noundef signext 17, i8 noundef signext -108, i8 noundef signext -6, i8 noundef signext 95, i8 noundef signext 1)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.42, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -80, i8 noundef signext 29, i8 noundef signext 93, i8 noundef signext 84, i8 noundef signext 45, i8 noundef signext -7, i8 noundef signext 112, i8 noundef signext -97, i8 noundef signext 11, i8 noundef signext 62, i8 noundef signext 111, i8 noundef signext 17, i8 noundef signext -108, i8 noundef signext 43, i8 noundef signext 95, i8 noundef signext 16)
  store <2 x i64> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.42, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 61, i8 noundef signext -100, i8 noundef signext 79, i8 noundef signext 19, i8 noundef signext -86, i8 noundef signext 116, i8 noundef signext -34, i8 noundef signext 96, i8 noundef signext 70, i8 noundef signext -48, i8 noundef signext -13, i8 noundef signext 103, i8 noundef signext -107, i8 noundef signext 79, i8 noundef signext 24, i8 noundef signext -71)
  store <2 x i64> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 39, i8 noundef signext -53, i8 noundef signext -117, i8 noundef signext 65, i8 noundef signext -55, i8 noundef signext 21, i8 noundef signext 49, i8 noundef signext -22, i8 noundef signext 118, i8 noundef signext -71, i8 noundef signext -113, i8 noundef signext 2, i8 noundef signext -83, i8 noundef signext -74, i8 noundef signext -11, i8 noundef signext 85)
  store <2 x i64> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 61, i8 noundef signext -53, i8 noundef signext 79, i8 noundef signext 65, i8 noundef signext -55, i8 noundef signext 116, i8 noundef signext 49, i8 noundef signext 96, i8 noundef signext 118, i8 noundef signext -48, i8 noundef signext -13, i8 noundef signext 103, i8 noundef signext -83, i8 noundef signext 79, i8 noundef signext 24, i8 noundef signext 85)
  store <2 x i64> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -13, i8 noundef signext -124, i8 noundef signext -110, i8 noundef signext 22, i8 noundef signext -109, i8 noundef signext 127, i8 noundef signext -45, i8 noundef signext -62, i8 noundef signext 0, i8 noundef signext 51, i8 noundef signext -98, i8 noundef signext -11, i8 noundef signext -54, i8 noundef signext -75, i8 noundef signext -101, i8 noundef signext -109)
  store <2 x i64> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -28, i8 noundef signext -120, i8 noundef signext 90, i8 noundef signext -89, i8 noundef signext -72, i8 noundef signext 93, i8 noundef signext -68, i8 noundef signext -105, i8 noundef signext 39, i8 noundef signext 46, i8 noundef signext 2, i8 noundef signext 5, i8 noundef signext 16, i8 noundef signext 34, i8 noundef signext -99, i8 noundef signext 64)
  store <2 x i64> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -13, i8 noundef signext -120, i8 noundef signext 90, i8 noundef signext 22, i8 noundef signext -72, i8 noundef signext 127, i8 noundef signext -45, i8 noundef signext -62, i8 noundef signext 39, i8 noundef signext 51, i8 noundef signext 2, i8 noundef signext 5, i8 noundef signext 16, i8 noundef signext 34, i8 noundef signext -99, i8 noundef signext 64)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -43, i8 noundef signext -102, i8 noundef signext 111, i8 noundef signext 97, i8 noundef signext -69, i8 noundef signext 104, i8 noundef signext -24, i8 noundef signext -6, i8 noundef signext 29, i8 noundef signext 43, i8 noundef signext 65, i8 noundef signext 47, i8 noundef signext -60, i8 noundef signext 52, i8 noundef signext 2, i8 noundef signext -40)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -7, i8 noundef signext 85, i8 noundef signext -63, i8 noundef signext 48, i8 noundef signext -117, i8 noundef signext 19, i8 noundef signext 99, i8 noundef signext 67, i8 noundef signext -50, i8 noundef signext -116, i8 noundef signext 5, i8 noundef signext 2, i8 noundef signext -96, i8 noundef signext 125, i8 noundef signext -95, i8 noundef signext 0)
  store <2 x i64> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -7, i8 noundef signext 85, i8 noundef signext 111, i8 noundef signext 97, i8 noundef signext -69, i8 noundef signext 104, i8 noundef signext 99, i8 noundef signext 67, i8 noundef signext 29, i8 noundef signext 43, i8 noundef signext 65, i8 noundef signext 47, i8 noundef signext -60, i8 noundef signext 125, i8 noundef signext 2, i8 noundef signext 0)
  store <2 x i64> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 98, i8 noundef signext -7, i8 noundef signext -56, i8 noundef signext 9, i8 noundef signext 74, i8 noundef signext 50, i8 noundef signext -95, i8 noundef signext 127, i8 noundef signext 114, i8 noundef signext 118, i8 noundef signext -76, i8 noundef signext 110, i8 noundef signext -48, i8 noundef signext -50, i8 noundef signext 57, i8 noundef signext -47)
  store <2 x i64> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 47, i8 noundef signext -82, i8 noundef signext 66, i8 noundef signext -76, i8 noundef signext 6, i8 noundef signext 117, i8 noundef signext 80, i8 noundef signext -13, i8 noundef signext 80, i8 noundef signext -109, i8 noundef signext 126, i8 noundef signext 70, i8 noundef signext 60, i8 noundef signext 40, i8 noundef signext -54, i8 noundef signext 3)
  store <2 x i64> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 98, i8 noundef signext -7, i8 noundef signext 66, i8 noundef signext 9, i8 noundef signext 74, i8 noundef signext 117, i8 noundef signext 80, i8 noundef signext 127, i8 noundef signext 114, i8 noundef signext 118, i8 noundef signext 126, i8 noundef signext 110, i8 noundef signext 60, i8 noundef signext 40, i8 noundef signext 57, i8 noundef signext 3)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -80, i8 noundef signext -39, i8 noundef signext 113, i8 noundef signext -58, i8 noundef signext 58, i8 noundef signext -88, i8 noundef signext 22, i8 noundef signext -99, i8 noundef signext 112, i8 noundef signext -21, i8 noundef signext 44, i8 noundef signext -31, i8 noundef signext -2, i8 noundef signext 109, i8 noundef signext 19, i8 noundef signext -74)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 71, i8 noundef signext -38, i8 noundef signext 47, i8 noundef signext -92, i8 noundef signext 8, i8 noundef signext 48, i8 noundef signext 105, i8 noundef signext -82, i8 noundef signext 35, i8 noundef signext 54, i8 noundef signext 25, i8 noundef signext 36, i8 noundef signext 111, i8 noundef signext -7, i8 noundef signext -12, i8 noundef signext -75)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 71, i8 noundef signext -38, i8 noundef signext 113, i8 noundef signext -58, i8 noundef signext 58, i8 noundef signext 48, i8 noundef signext 105, i8 noundef signext -82, i8 noundef signext 112, i8 noundef signext 54, i8 noundef signext 44, i8 noundef signext 36, i8 noundef signext 111, i8 noundef signext 109, i8 noundef signext 19, i8 noundef signext -74)
  store <2 x i64> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 18, i8 noundef signext -41, i8 noundef signext -74, i8 noundef signext 60, i8 noundef signext -63, i8 noundef signext -55, i8 noundef signext -71, i8 noundef signext 118, i8 noundef signext 46, i8 noundef signext -19, i8 noundef signext 19, i8 noundef signext -7, i8 noundef signext -55, i8 noundef signext -75, i8 noundef signext 125, i8 noundef signext -82)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -125, i8 noundef signext -106, i8 noundef signext -127, i8 noundef signext -23, i8 noundef signext -63, i8 noundef signext 0, i8 noundef signext 56, i8 noundef signext -23, i8 noundef signext -34, i8 noundef signext -32, i8 noundef signext 33, i8 noundef signext 127, i8 noundef signext 39, i8 noundef signext -68, i8 noundef signext -103, i8 noundef signext 126)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 18, i8 noundef signext -41, i8 noundef signext -74, i8 noundef signext 60, i8 noundef signext -63, i8 noundef signext 0, i8 noundef signext 56, i8 noundef signext 118, i8 noundef signext 46, i8 noundef signext -19, i8 noundef signext 33, i8 noundef signext 127, i8 noundef signext 39, i8 noundef signext -68, i8 noundef signext 125, i8 noundef signext 126)
  store <2 x i64> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -90, i8 noundef signext -81, i8 noundef signext 72, i8 noundef signext -34, i8 noundef signext -85, i8 noundef signext 108, i8 noundef signext 42, i8 noundef signext 34, i8 noundef signext -79, i8 noundef signext -48, i8 noundef signext 3, i8 noundef signext 113, i8 noundef signext -62, i8 noundef signext 25, i8 noundef signext -74, i8 noundef signext 13)
  store <2 x i64> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -44, i8 noundef signext -22, i8 noundef signext 26, i8 noundef signext -52, i8 noundef signext 29, i8 noundef signext 96, i8 noundef signext -97, i8 noundef signext 88, i8 noundef signext -11, i8 noundef signext -125, i8 noundef signext -60, i8 noundef signext 88, i8 noundef signext -55, i8 noundef signext 40, i8 noundef signext 76, i8 noundef signext -80)
  store <2 x i64> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.42, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -44, i8 noundef signext -22, i8 noundef signext 72, i8 noundef signext -34, i8 noundef signext 29, i8 noundef signext 108, i8 noundef signext 42, i8 noundef signext 88, i8 noundef signext -11, i8 noundef signext -48, i8 noundef signext 3, i8 noundef signext 113, i8 noundef signext -55, i8 noundef signext 40, i8 noundef signext 76, i8 noundef signext 13)
  store <2 x i64> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup59

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.42], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.42, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a52, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx53 = getelementptr inbounds [8 x %struct.anon.42], ptr %test_vec, i64 0, i64 %3
  %b54 = getelementptr inbounds %struct.anon.42, ptr %arrayidx53, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b54, align 16, !tbaa !16
  %call55 = call <2 x i64> @simde_mm_max_epi8(<2 x i64> noundef %2, <2 x i64> noundef %4)
  store <2 x i64> %call55, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r51, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx56 = getelementptr inbounds [8 x %struct.anon.42], ptr %test_vec, i64 0, i64 %6
  %r57 = getelementptr inbounds %struct.anon.42, ptr %arrayidx56, i32 0, i32 2
  %7 = load <2 x i64>, ptr %r57, align 16, !tbaa !16
  %call58 = call i32 @simde_test_x86_assert_equal_i8x16_(<2 x i64> noundef %5, <2 x i64> noundef %7, ptr noundef @.str.72, i32 noundef 2132, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call58, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup59 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup59:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest60 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest60, label %cleanup61 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup59
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup61

cleanup61:                                        ; preds = %for.end, %cleanup59
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_max_epi32() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.43], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.43], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.43, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi32(i32 noundef 477039853, i32 noundef 1555162887, i32 noundef 960008067, i32 noundef -2078514865)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.43, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -346254872, i32 noundef 70690131, i32 noundef -249580279, i32 noundef -297974983)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.43, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 477039853, i32 noundef 1555162887, i32 noundef 960008067, i32 noundef -297974983)
  store <2 x i64> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.43, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1946076095, i32 noundef 1626099315, i32 noundef 367020053, i32 noundef -768900730)
  store <2 x i64> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -534331032, i32 noundef -1542646073, i32 noundef 900332023, i32 noundef 1625404528)
  store <2 x i64> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1946076095, i32 noundef 1626099315, i32 noundef 900332023, i32 noundef 1625404528)
  store <2 x i64> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1785938855, i32 noundef 217054136, i32 noundef 6277613, i32 noundef 1323071612)
  store <2 x i64> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1842447194, i32 noundef 1202045241, i32 noundef 391997517, i32 noundef 904511960)
  store <2 x i64> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1785938855, i32 noundef 1202045241, i32 noundef 391997517, i32 noundef 1323071612)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -303416903, i32 noundef 131247622, i32 noundef -2038528381, i32 noundef -1774779832)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 307942484, i32 noundef -1408988466, i32 noundef -1799017519, i32 noundef 1885804693)
  store <2 x i64> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 307942484, i32 noundef 131247622, i32 noundef -1799017519, i32 noundef 1885804693)
  store <2 x i64> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -424176665, i32 noundef 531131808, i32 noundef -752351935, i32 noundef 650848232)
  store <2 x i64> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1513144536, i32 noundef -875213417, i32 noundef -1592044131, i32 noundef -1714853090)
  store <2 x i64> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -424176665, i32 noundef 531131808, i32 noundef -752351935, i32 noundef 650848232)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1901471013, i32 noundef -1928782687, i32 noundef -1204237637, i32 noundef -1735607658)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1526238167, i32 noundef 1155872155, i32 noundef -981128645, i32 noundef -1655952235)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1901471013, i32 noundef 1155872155, i32 noundef -981128645, i32 noundef -1655952235)
  store <2 x i64> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 2067002242, i32 noundef -967820279, i32 noundef -1842332164, i32 noundef 1466140749)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -25857443, i32 noundef -1417095277, i32 noundef -31302876, i32 noundef -1114441571)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 2067002242, i32 noundef -967820279, i32 noundef -31302876, i32 noundef 1466140749)
  store <2 x i64> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -515864750, i32 noundef 1885657427, i32 noundef -1627411585, i32 noundef -455970760)
  store <2 x i64> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -505553594, i32 noundef -1363391302, i32 noundef 1929235496, i32 noundef -1212934452)
  store <2 x i64> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.43, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -505553594, i32 noundef 1885657427, i32 noundef 1929235496, i32 noundef -455970760)
  store <2 x i64> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup59

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.43], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.43, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a52, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx53 = getelementptr inbounds [8 x %struct.anon.43], ptr %test_vec, i64 0, i64 %3
  %b54 = getelementptr inbounds %struct.anon.43, ptr %arrayidx53, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b54, align 16, !tbaa !16
  %call55 = call <2 x i64> @simde_mm_max_epi32(<2 x i64> noundef %2, <2 x i64> noundef %4)
  store <2 x i64> %call55, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r51, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx56 = getelementptr inbounds [8 x %struct.anon.43], ptr %test_vec, i64 0, i64 %6
  %r57 = getelementptr inbounds %struct.anon.43, ptr %arrayidx56, i32 0, i32 2
  %7 = load <2 x i64>, ptr %r57, align 16, !tbaa !16
  %call58 = call i32 @simde_test_x86_assert_equal_i32x4_(<2 x i64> noundef %5, <2 x i64> noundef %7, ptr noundef @.str.72, i32 noundef 2173, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call58, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup59 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup59:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest60 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest60, label %cleanup61 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup59
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup61

cleanup61:                                        ; preds = %for.end, %cleanup59
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_max_epu16() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.44], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.44], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.44, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 31378, i16 noundef zeroext 24380, i16 noundef zeroext -25281, i16 noundef zeroext 13201, i16 noundef zeroext -6666, i16 noundef zeroext -16076, i16 noundef zeroext -804, i16 noundef zeroext -29425)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.44, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -1481, i16 noundef zeroext -20025, i16 noundef zeroext -4532, i16 noundef zeroext -16478, i16 noundef zeroext 25195, i16 noundef zeroext -454, i16 noundef zeroext 861, i16 noundef zeroext 2148)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.44, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -1481, i16 noundef zeroext -20025, i16 noundef zeroext -4532, i16 noundef zeroext -16478, i16 noundef zeroext -6666, i16 noundef zeroext -454, i16 noundef zeroext -804, i16 noundef zeroext -29425)
  store <2 x i64> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.44, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 17034, i16 noundef zeroext -3876, i16 noundef zeroext -27845, i16 noundef zeroext -17280, i16 noundef zeroext -13070, i16 noundef zeroext -6386, i16 noundef zeroext -17012, i16 noundef zeroext -16604)
  store <2 x i64> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 9311, i16 noundef zeroext -12582, i16 noundef zeroext -5614, i16 noundef zeroext -28097, i16 noundef zeroext -17015, i16 noundef zeroext -20960, i16 noundef zeroext -6979, i16 noundef zeroext 4347)
  store <2 x i64> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 17034, i16 noundef zeroext -3876, i16 noundef zeroext -5614, i16 noundef zeroext -17280, i16 noundef zeroext -13070, i16 noundef zeroext -6386, i16 noundef zeroext -6979, i16 noundef zeroext -16604)
  store <2 x i64> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 3717, i16 noundef zeroext -57, i16 noundef zeroext -17945, i16 noundef zeroext -27945, i16 noundef zeroext -9038, i16 noundef zeroext -1159, i16 noundef zeroext 4742, i16 noundef zeroext 26061)
  store <2 x i64> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -12401, i16 noundef zeroext 25263, i16 noundef zeroext -29643, i16 noundef zeroext -21813, i16 noundef zeroext -9986, i16 noundef zeroext 13729, i16 noundef zeroext -21368, i16 noundef zeroext 18708)
  store <2 x i64> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -12401, i16 noundef zeroext -57, i16 noundef zeroext -17945, i16 noundef zeroext -21813, i16 noundef zeroext -9038, i16 noundef zeroext -1159, i16 noundef zeroext -21368, i16 noundef zeroext 26061)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 32738, i16 noundef zeroext 32324, i16 noundef zeroext 12257, i16 noundef zeroext 4392, i16 noundef zeroext -16595, i16 noundef zeroext 15991, i16 noundef zeroext -9355, i16 noundef zeroext -697)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -11354, i16 noundef zeroext 32645, i16 noundef zeroext 19389, i16 noundef zeroext -800, i16 noundef zeroext -9968, i16 noundef zeroext -10795, i16 noundef zeroext -17673, i16 noundef zeroext 26870)
  store <2 x i64> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -11354, i16 noundef zeroext 32645, i16 noundef zeroext 19389, i16 noundef zeroext -800, i16 noundef zeroext -9968, i16 noundef zeroext -10795, i16 noundef zeroext -9355, i16 noundef zeroext -697)
  store <2 x i64> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 25092, i16 noundef zeroext 2337, i16 noundef zeroext -24400, i16 noundef zeroext -3482, i16 noundef zeroext 31692, i16 noundef zeroext -17640, i16 noundef zeroext 26455, i16 noundef zeroext -23660)
  store <2 x i64> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -8003, i16 noundef zeroext 4966, i16 noundef zeroext 21312, i16 noundef zeroext 22488, i16 noundef zeroext -5915, i16 noundef zeroext 4501, i16 noundef zeroext 18372, i16 noundef zeroext -3243)
  store <2 x i64> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -8003, i16 noundef zeroext 4966, i16 noundef zeroext -24400, i16 noundef zeroext -3482, i16 noundef zeroext -5915, i16 noundef zeroext -17640, i16 noundef zeroext 26455, i16 noundef zeroext -3243)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -16542, i16 noundef zeroext -11357, i16 noundef zeroext 26228, i16 noundef zeroext -4349, i16 noundef zeroext -20682, i16 noundef zeroext -8452, i16 noundef zeroext 16902, i16 noundef zeroext 1404)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 4826, i16 noundef zeroext 23694, i16 noundef zeroext 32546, i16 noundef zeroext -24352, i16 noundef zeroext 725, i16 noundef zeroext 27358, i16 noundef zeroext 30444, i16 noundef zeroext 27027)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -16542, i16 noundef zeroext -11357, i16 noundef zeroext 32546, i16 noundef zeroext -4349, i16 noundef zeroext -20682, i16 noundef zeroext -8452, i16 noundef zeroext 30444, i16 noundef zeroext 27027)
  store <2 x i64> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -4614, i16 noundef zeroext -13711, i16 noundef zeroext 9165, i16 noundef zeroext 16534, i16 noundef zeroext 2526, i16 noundef zeroext 29939, i16 noundef zeroext -3710, i16 noundef zeroext -20511)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 10446, i16 noundef zeroext 28319, i16 noundef zeroext -3906, i16 noundef zeroext 32182, i16 noundef zeroext 17860, i16 noundef zeroext 15017, i16 noundef zeroext -6469, i16 noundef zeroext 19548)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -4614, i16 noundef zeroext -13711, i16 noundef zeroext -3906, i16 noundef zeroext 32182, i16 noundef zeroext 17860, i16 noundef zeroext 29939, i16 noundef zeroext -3710, i16 noundef zeroext -20511)
  store <2 x i64> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -31525, i16 noundef zeroext -28702, i16 noundef zeroext 12993, i16 noundef zeroext 21384, i16 noundef zeroext -2893, i16 noundef zeroext -9593, i16 noundef zeroext 12296, i16 noundef zeroext -3474)
  store <2 x i64> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 22645, i16 noundef zeroext 31782, i16 noundef zeroext -23159, i16 noundef zeroext 17805, i16 noundef zeroext -10274, i16 noundef zeroext -14986, i16 noundef zeroext -11708, i16 noundef zeroext 32401)
  store <2 x i64> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.44, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -31525, i16 noundef zeroext -28702, i16 noundef zeroext -23159, i16 noundef zeroext 21384, i16 noundef zeroext -2893, i16 noundef zeroext -9593, i16 noundef zeroext -11708, i16 noundef zeroext -3474)
  store <2 x i64> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup59

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.44], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.44, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a52, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx53 = getelementptr inbounds [8 x %struct.anon.44], ptr %test_vec, i64 0, i64 %3
  %b54 = getelementptr inbounds %struct.anon.44, ptr %arrayidx53, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b54, align 16, !tbaa !16
  %call55 = call <2 x i64> @simde_mm_max_epu16(<2 x i64> noundef %2, <2 x i64> noundef %4)
  store <2 x i64> %call55, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r51, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx56 = getelementptr inbounds [8 x %struct.anon.44], ptr %test_vec, i64 0, i64 %6
  %r57 = getelementptr inbounds %struct.anon.44, ptr %arrayidx56, i32 0, i32 2
  %7 = load <2 x i64>, ptr %r57, align 16, !tbaa !16
  %call58 = call i32 @simde_test_x86_assert_equal_u16x8_(<2 x i64> noundef %5, <2 x i64> noundef %7, ptr noundef @.str.72, i32 noundef 2238, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call58, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup59 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup59:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest60 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest60, label %cleanup61 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup59
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup61

cleanup61:                                        ; preds = %for.end, %cleanup59
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_max_epu32() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.45], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.45], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.45, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1762078853, i32 noundef 529927089, i32 noundef -87215292, i32 noundef -784759613)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.45, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 574626150, i32 noundef 1395025810, i32 noundef 1034901368, i32 noundef -1273566306)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.45, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1762078853, i32 noundef 1395025810, i32 noundef -87215292, i32 noundef -784759613)
  store <2 x i64> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.45, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1931260603, i32 noundef -366264493, i32 noundef 881772043, i32 noundef 57971440)
  store <2 x i64> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -78053640, i32 noundef -991432057, i32 noundef 568980555, i32 noundef 308523788)
  store <2 x i64> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -78053640, i32 noundef -366264493, i32 noundef 881772043, i32 noundef 308523788)
  store <2 x i64> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 548389896, i32 noundef -1318242468, i32 noundef -571933971, i32 noundef 1050716143)
  store <2 x i64> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -703832012, i32 noundef 856620101, i32 noundef 833768684, i32 noundef 203883279)
  store <2 x i64> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -703832012, i32 noundef -1318242468, i32 noundef -571933971, i32 noundef 1050716143)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -577364343, i32 noundef -1558921640, i32 noundef -1755627431, i32 noundef -2095141439)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -963723989, i32 noundef 1452685186, i32 noundef -1957407012, i32 noundef -702354276)
  store <2 x i64> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -577364343, i32 noundef -1558921640, i32 noundef -1755627431, i32 noundef -702354276)
  store <2 x i64> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1832325668, i32 noundef -193860828, i32 noundef -1355673913, i32 noundef 448332726)
  store <2 x i64> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -203176715, i32 noundef 227177150, i32 noundef -865375, i32 noundef 1459100736)
  store <2 x i64> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -203176715, i32 noundef -193860828, i32 noundef -865375, i32 noundef 1459100736)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1973671448, i32 noundef 1498045863, i32 noundef 1898038098, i32 noundef 1965060938)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 29809850, i32 noundef 861011023, i32 noundef 63413124, i32 noundef -2118044804)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1973671448, i32 noundef 1498045863, i32 noundef 1898038098, i32 noundef -2118044804)
  store <2 x i64> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 526896309, i32 noundef 817143907, i32 noundef 1563490657, i32 noundef -613929547)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1292343582, i32 noundef -996382634, i32 noundef 1905485247, i32 noundef 108377847)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1292343582, i32 noundef -996382634, i32 noundef 1905485247, i32 noundef -613929547)
  store <2 x i64> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 749402761, i32 noundef -975730303, i32 noundef -1054954963, i32 noundef 1509228324)
  store <2 x i64> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1009612172, i32 noundef -1088816168, i32 noundef -1307704149, i32 noundef -588848370)
  store <2 x i64> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.45, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1009612172, i32 noundef -975730303, i32 noundef -1054954963, i32 noundef -588848370)
  store <2 x i64> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup59

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.45], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.45, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a52, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx53 = getelementptr inbounds [8 x %struct.anon.45], ptr %test_vec, i64 0, i64 %3
  %b54 = getelementptr inbounds %struct.anon.45, ptr %arrayidx53, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b54, align 16, !tbaa !16
  %call55 = call <2 x i64> @simde_mm_max_epu32(<2 x i64> noundef %2, <2 x i64> noundef %4)
  store <2 x i64> %call55, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r51, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx56 = getelementptr inbounds [8 x %struct.anon.45], ptr %test_vec, i64 0, i64 %6
  %r57 = getelementptr inbounds %struct.anon.45, ptr %arrayidx56, i32 0, i32 2
  %7 = load <2 x i64>, ptr %r57, align 16, !tbaa !16
  %call58 = call i32 @simde_test_x86_assert_equal_u32x4_(<2 x i64> noundef %5, <2 x i64> noundef %7, ptr noundef @.str.72, i32 noundef 2279, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call58, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup59 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup59:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest60 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest60, label %cleanup61 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup59
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup61

cleanup61:                                        ; preds = %for.end, %cleanup59
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_min_epi8() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.46], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.46], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.46, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -85, i8 noundef signext 106, i8 noundef signext -97, i8 noundef signext -26, i8 noundef signext -5, i8 noundef signext 83, i8 noundef signext -106, i8 noundef signext -116, i8 noundef signext -113, i8 noundef signext -34, i8 noundef signext -81, i8 noundef signext 109, i8 noundef signext -25, i8 noundef signext -16, i8 noundef signext 28, i8 noundef signext -76)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.46, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -69, i8 noundef signext -4, i8 noundef signext 73, i8 noundef signext -90, i8 noundef signext 93, i8 noundef signext -116, i8 noundef signext 19, i8 noundef signext 124, i8 noundef signext -67, i8 noundef signext 48, i8 noundef signext 38, i8 noundef signext 11, i8 noundef signext 21, i8 noundef signext 91, i8 noundef signext 118, i8 noundef signext 103)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.46, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -85, i8 noundef signext -4, i8 noundef signext -97, i8 noundef signext -90, i8 noundef signext -5, i8 noundef signext -116, i8 noundef signext -106, i8 noundef signext -116, i8 noundef signext -113, i8 noundef signext -34, i8 noundef signext -81, i8 noundef signext 11, i8 noundef signext -25, i8 noundef signext -16, i8 noundef signext 28, i8 noundef signext -76)
  store <2 x i64> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.46, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -69, i8 noundef signext -84, i8 noundef signext 37, i8 noundef signext -17, i8 noundef signext 36, i8 noundef signext -34, i8 noundef signext -104, i8 noundef signext 112, i8 noundef signext 13, i8 noundef signext 47, i8 noundef signext -94, i8 noundef signext -38, i8 noundef signext 111, i8 noundef signext -44, i8 noundef signext -90, i8 noundef signext -86)
  store <2 x i64> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -125, i8 noundef signext 55, i8 noundef signext 5, i8 noundef signext 113, i8 noundef signext 100, i8 noundef signext -35, i8 noundef signext -4, i8 noundef signext 29, i8 noundef signext 60, i8 noundef signext 120, i8 noundef signext -36, i8 noundef signext 72, i8 noundef signext 92, i8 noundef signext 31, i8 noundef signext 11, i8 noundef signext -106)
  store <2 x i64> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -125, i8 noundef signext -84, i8 noundef signext 5, i8 noundef signext -17, i8 noundef signext 36, i8 noundef signext -35, i8 noundef signext -104, i8 noundef signext 29, i8 noundef signext 13, i8 noundef signext 47, i8 noundef signext -94, i8 noundef signext -38, i8 noundef signext 92, i8 noundef signext -44, i8 noundef signext -90, i8 noundef signext -106)
  store <2 x i64> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 49, i8 noundef signext -113, i8 noundef signext -25, i8 noundef signext -86, i8 noundef signext 106, i8 noundef signext 71, i8 noundef signext 43, i8 noundef signext 81, i8 noundef signext -66, i8 noundef signext 111, i8 noundef signext 40, i8 noundef signext 35, i8 noundef signext 15, i8 noundef signext 51, i8 noundef signext 21, i8 noundef signext 60)
  store <2 x i64> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 37, i8 noundef signext -84, i8 noundef signext 110, i8 noundef signext -46, i8 noundef signext -27, i8 noundef signext -56, i8 noundef signext 104, i8 noundef signext 2, i8 noundef signext -105, i8 noundef signext 65, i8 noundef signext 54, i8 noundef signext 75, i8 noundef signext 113, i8 noundef signext 29, i8 noundef signext -47, i8 noundef signext 84)
  store <2 x i64> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 37, i8 noundef signext -113, i8 noundef signext -25, i8 noundef signext -86, i8 noundef signext -27, i8 noundef signext -56, i8 noundef signext 43, i8 noundef signext 2, i8 noundef signext -105, i8 noundef signext 65, i8 noundef signext 40, i8 noundef signext 35, i8 noundef signext 15, i8 noundef signext 29, i8 noundef signext -47, i8 noundef signext 60)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -9, i8 noundef signext -51, i8 noundef signext -8, i8 noundef signext -23, i8 noundef signext 42, i8 noundef signext 26, i8 noundef signext -68, i8 noundef signext -93, i8 noundef signext -78, i8 noundef signext -45, i8 noundef signext -36, i8 noundef signext -34, i8 noundef signext -79, i8 noundef signext -94, i8 noundef signext 80, i8 noundef signext 99)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 27, i8 noundef signext 45, i8 noundef signext 48, i8 noundef signext -73, i8 noundef signext -21, i8 noundef signext 86, i8 noundef signext 54, i8 noundef signext -39, i8 noundef signext -2, i8 noundef signext 108, i8 noundef signext -19, i8 noundef signext -81, i8 noundef signext -52, i8 noundef signext 118, i8 noundef signext 61, i8 noundef signext -36)
  store <2 x i64> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -9, i8 noundef signext -51, i8 noundef signext -8, i8 noundef signext -73, i8 noundef signext -21, i8 noundef signext 26, i8 noundef signext -68, i8 noundef signext -93, i8 noundef signext -78, i8 noundef signext -45, i8 noundef signext -36, i8 noundef signext -81, i8 noundef signext -79, i8 noundef signext -94, i8 noundef signext 61, i8 noundef signext -36)
  store <2 x i64> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 75, i8 noundef signext 2, i8 noundef signext -37, i8 noundef signext -22, i8 noundef signext 110, i8 noundef signext -125, i8 noundef signext 33, i8 noundef signext -94, i8 noundef signext -5, i8 noundef signext -67, i8 noundef signext -78, i8 noundef signext -46, i8 noundef signext 43, i8 noundef signext -89, i8 noundef signext 74, i8 noundef signext 18)
  store <2 x i64> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 84, i8 noundef signext -44, i8 noundef signext -115, i8 noundef signext 29, i8 noundef signext -121, i8 noundef signext 22, i8 noundef signext 43, i8 noundef signext -123, i8 noundef signext -63, i8 noundef signext -73, i8 noundef signext 36, i8 noundef signext -60, i8 noundef signext -96, i8 noundef signext -58, i8 noundef signext -42, i8 noundef signext 78)
  store <2 x i64> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 75, i8 noundef signext -44, i8 noundef signext -115, i8 noundef signext -22, i8 noundef signext -121, i8 noundef signext -125, i8 noundef signext 33, i8 noundef signext -123, i8 noundef signext -63, i8 noundef signext -73, i8 noundef signext -78, i8 noundef signext -60, i8 noundef signext -96, i8 noundef signext -89, i8 noundef signext -42, i8 noundef signext 18)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -82, i8 noundef signext -34, i8 noundef signext 74, i8 noundef signext 86, i8 noundef signext -7, i8 noundef signext 93, i8 noundef signext -99, i8 noundef signext -7, i8 noundef signext 127, i8 noundef signext 26, i8 noundef signext -51, i8 noundef signext 41, i8 noundef signext 71, i8 noundef signext 67, i8 noundef signext -102, i8 noundef signext -119)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -8, i8 noundef signext 88, i8 noundef signext 46, i8 noundef signext 105, i8 noundef signext -43, i8 noundef signext -109, i8 noundef signext 38, i8 noundef signext -35, i8 noundef signext -17, i8 noundef signext -4, i8 noundef signext -122, i8 noundef signext -112, i8 noundef signext -62, i8 noundef signext 100, i8 noundef signext 89, i8 noundef signext -83)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -82, i8 noundef signext -34, i8 noundef signext 46, i8 noundef signext 86, i8 noundef signext -43, i8 noundef signext -109, i8 noundef signext -99, i8 noundef signext -35, i8 noundef signext -17, i8 noundef signext -4, i8 noundef signext -122, i8 noundef signext -112, i8 noundef signext -62, i8 noundef signext 67, i8 noundef signext -102, i8 noundef signext -119)
  store <2 x i64> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 21, i8 noundef signext -83, i8 noundef signext -9, i8 noundef signext -66, i8 noundef signext -50, i8 noundef signext -47, i8 noundef signext -30, i8 noundef signext 4, i8 noundef signext -60, i8 noundef signext 23, i8 noundef signext 126, i8 noundef signext 69, i8 noundef signext 56, i8 noundef signext 4, i8 noundef signext 32, i8 noundef signext 31)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 76, i8 noundef signext -95, i8 noundef signext 81, i8 noundef signext 9, i8 noundef signext -106, i8 noundef signext -75, i8 noundef signext 46, i8 noundef signext 117, i8 noundef signext -119, i8 noundef signext -56, i8 noundef signext -115, i8 noundef signext -97, i8 noundef signext -52, i8 noundef signext -81, i8 noundef signext -123, i8 noundef signext 54)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 21, i8 noundef signext -95, i8 noundef signext -9, i8 noundef signext -66, i8 noundef signext -106, i8 noundef signext -75, i8 noundef signext -30, i8 noundef signext 4, i8 noundef signext -119, i8 noundef signext -56, i8 noundef signext -115, i8 noundef signext -97, i8 noundef signext -52, i8 noundef signext -81, i8 noundef signext -123, i8 noundef signext 31)
  store <2 x i64> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -56, i8 noundef signext -107, i8 noundef signext 36, i8 noundef signext -66, i8 noundef signext -22, i8 noundef signext -112, i8 noundef signext 57, i8 noundef signext 12, i8 noundef signext -40, i8 noundef signext -109, i8 noundef signext -85, i8 noundef signext 86, i8 noundef signext -31, i8 noundef signext -66, i8 noundef signext 99, i8 noundef signext -10)
  store <2 x i64> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext 57, i8 noundef signext -109, i8 noundef signext 45, i8 noundef signext 32, i8 noundef signext 94, i8 noundef signext -27, i8 noundef signext 11, i8 noundef signext 67, i8 noundef signext -114, i8 noundef signext -40, i8 noundef signext -125, i8 noundef signext -106, i8 noundef signext 72, i8 noundef signext -34, i8 noundef signext -102, i8 noundef signext 18)
  store <2 x i64> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.46, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <2 x i64> @simde_mm_set_epi8(i8 noundef signext -56, i8 noundef signext -109, i8 noundef signext 36, i8 noundef signext -66, i8 noundef signext -22, i8 noundef signext -112, i8 noundef signext 11, i8 noundef signext 12, i8 noundef signext -114, i8 noundef signext -109, i8 noundef signext -125, i8 noundef signext -106, i8 noundef signext -31, i8 noundef signext -66, i8 noundef signext -102, i8 noundef signext -10)
  store <2 x i64> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup59

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.46], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.46, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a52, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx53 = getelementptr inbounds [8 x %struct.anon.46], ptr %test_vec, i64 0, i64 %3
  %b54 = getelementptr inbounds %struct.anon.46, ptr %arrayidx53, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b54, align 16, !tbaa !16
  %call55 = call <2 x i64> @simde_mm_min_epi8(<2 x i64> noundef %2, <2 x i64> noundef %4)
  store <2 x i64> %call55, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r51, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx56 = getelementptr inbounds [8 x %struct.anon.46], ptr %test_vec, i64 0, i64 %6
  %r57 = getelementptr inbounds %struct.anon.46, ptr %arrayidx56, i32 0, i32 2
  %7 = load <2 x i64>, ptr %r57, align 16, !tbaa !16
  %call58 = call i32 @simde_test_x86_assert_equal_i8x16_(<2 x i64> noundef %5, <2 x i64> noundef %7, ptr noundef @.str.72, i32 noundef 2392, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call58, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup59 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup59:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest60 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest60, label %cleanup61 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup59
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup61

cleanup61:                                        ; preds = %for.end, %cleanup59
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_min_epi32() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.47], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.47], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.47, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1390607532, i32 noundef 385446037, i32 noundef -880551963, i32 noundef -1976882160)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.47, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1328784057, i32 noundef 765325983, i32 noundef 188641041, i32 noundef -1795531007)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.47, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1390607532, i32 noundef 385446037, i32 noundef -880551963, i32 noundef -1976882160)
  store <2 x i64> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.47, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1033654035, i32 noundef -1435181472, i32 noundef 1188098919, i32 noundef -1789978439)
  store <2 x i64> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 667650881, i32 noundef -921357846, i32 noundef 1991872258, i32 noundef -1380518571)
  store <2 x i64> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 667650881, i32 noundef -1435181472, i32 noundef 1188098919, i32 noundef -1789978439)
  store <2 x i64> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -209415658, i32 noundef -1820339262, i32 noundef 3383029, i32 noundef -894067821)
  store <2 x i64> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -460825945, i32 noundef -1201816425, i32 noundef 657326597, i32 noundef 270703936)
  store <2 x i64> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -460825945, i32 noundef -1820339262, i32 noundef 3383029, i32 noundef -894067821)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -711299231, i32 noundef -1150752518, i32 noundef 489373999, i32 noundef -1003224360)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -111820496, i32 noundef -1961663677, i32 noundef -829684478, i32 noundef -1602379520)
  store <2 x i64> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -711299231, i32 noundef -1961663677, i32 noundef -829684478, i32 noundef -1602379520)
  store <2 x i64> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1660536841, i32 noundef 1244832127, i32 noundef 1920382062, i32 noundef -791791151)
  store <2 x i64> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 799949492, i32 noundef 108351731, i32 noundef 1351843398, i32 noundef 1009306115)
  store <2 x i64> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 799949492, i32 noundef 108351731, i32 noundef 1351843398, i32 noundef -791791151)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1327926842, i32 noundef 984094365, i32 noundef 1894460641, i32 noundef -26405962)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1205481380, i32 noundef 137390510, i32 noundef 590747940, i32 noundef 1878652085)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1327926842, i32 noundef 137390510, i32 noundef 590747940, i32 noundef -26405962)
  store <2 x i64> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 316126780, i32 noundef -1043744394, i32 noundef 787289081, i32 noundef -910852690)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -2087288343, i32 noundef -1056950039, i32 noundef -555736705, i32 noundef 666671486)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -2087288343, i32 noundef -1056950039, i32 noundef -555736705, i32 noundef -910852690)
  store <2 x i64> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1498461986, i32 noundef -1418974686, i32 noundef -1311767695, i32 noundef -1038502387)
  store <2 x i64> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -722855220, i32 noundef 492871512, i32 noundef -175913896, i32 noundef -920105808)
  store <2 x i64> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.47, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1498461986, i32 noundef -1418974686, i32 noundef -1311767695, i32 noundef -1038502387)
  store <2 x i64> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup59

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.47], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.47, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a52, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx53 = getelementptr inbounds [8 x %struct.anon.47], ptr %test_vec, i64 0, i64 %3
  %b54 = getelementptr inbounds %struct.anon.47, ptr %arrayidx53, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b54, align 16, !tbaa !16
  %call55 = call <2 x i64> @simde_mm_min_epi32(<2 x i64> noundef %2, <2 x i64> noundef %4)
  store <2 x i64> %call55, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r51, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx56 = getelementptr inbounds [8 x %struct.anon.47], ptr %test_vec, i64 0, i64 %6
  %r57 = getelementptr inbounds %struct.anon.47, ptr %arrayidx56, i32 0, i32 2
  %7 = load <2 x i64>, ptr %r57, align 16, !tbaa !16
  %call58 = call i32 @simde_test_x86_assert_equal_i32x4_(<2 x i64> noundef %5, <2 x i64> noundef %7, ptr noundef @.str.72, i32 noundef 2433, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call58, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup59 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup59:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest60 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest60, label %cleanup61 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup59
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup61

cleanup61:                                        ; preds = %for.end, %cleanup59
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_min_epu16() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.48], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.48], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.48, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -14168, i16 noundef zeroext -18288, i16 noundef zeroext 2518, i16 noundef zeroext -5949, i16 noundef zeroext -1103, i16 noundef zeroext -19992, i16 noundef zeroext 8944, i16 noundef zeroext -9156)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.48, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -30249, i16 noundef zeroext 4953, i16 noundef zeroext -10376, i16 noundef zeroext 11599, i16 noundef zeroext 1282, i16 noundef zeroext 22629, i16 noundef zeroext 1908, i16 noundef zeroext -8304)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.48, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -30249, i16 noundef zeroext 4953, i16 noundef zeroext 2518, i16 noundef zeroext 11599, i16 noundef zeroext 1282, i16 noundef zeroext 22629, i16 noundef zeroext 1908, i16 noundef zeroext -9156)
  store <2 x i64> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.48, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -14454, i16 noundef zeroext -24212, i16 noundef zeroext -1680, i16 noundef zeroext -15911, i16 noundef zeroext -17890, i16 noundef zeroext -25465, i16 noundef zeroext -21642, i16 noundef zeroext 6845)
  store <2 x i64> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 29622, i16 noundef zeroext -8139, i16 noundef zeroext -6628, i16 noundef zeroext 15516, i16 noundef zeroext -8236, i16 noundef zeroext 16770, i16 noundef zeroext 6179, i16 noundef zeroext 31976)
  store <2 x i64> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 29622, i16 noundef zeroext -24212, i16 noundef zeroext -6628, i16 noundef zeroext 15516, i16 noundef zeroext -17890, i16 noundef zeroext 16770, i16 noundef zeroext 6179, i16 noundef zeroext 6845)
  store <2 x i64> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 7791, i16 noundef zeroext 9357, i16 noundef zeroext -14122, i16 noundef zeroext 32085, i16 noundef zeroext 5803, i16 noundef zeroext 15112, i16 noundef zeroext 4983, i16 noundef zeroext -3252)
  store <2 x i64> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 19191, i16 noundef zeroext -11872, i16 noundef zeroext 31350, i16 noundef zeroext -5718, i16 noundef zeroext -28690, i16 noundef zeroext -20624, i16 noundef zeroext -20939, i16 noundef zeroext 18257)
  store <2 x i64> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 7791, i16 noundef zeroext 9357, i16 noundef zeroext 31350, i16 noundef zeroext 32085, i16 noundef zeroext 5803, i16 noundef zeroext 15112, i16 noundef zeroext 4983, i16 noundef zeroext 18257)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 23178, i16 noundef zeroext -12920, i16 noundef zeroext -10750, i16 noundef zeroext 18857, i16 noundef zeroext -1213, i16 noundef zeroext -21528, i16 noundef zeroext 12675, i16 noundef zeroext 13653)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 16010, i16 noundef zeroext -16104, i16 noundef zeroext -18857, i16 noundef zeroext -32011, i16 noundef zeroext -18375, i16 noundef zeroext -658, i16 noundef zeroext -24851, i16 noundef zeroext -19400)
  store <2 x i64> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 16010, i16 noundef zeroext -16104, i16 noundef zeroext -18857, i16 noundef zeroext 18857, i16 noundef zeroext -18375, i16 noundef zeroext -21528, i16 noundef zeroext 12675, i16 noundef zeroext 13653)
  store <2 x i64> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -31965, i16 noundef zeroext 12594, i16 noundef zeroext 3662, i16 noundef zeroext -9156, i16 noundef zeroext -10610, i16 noundef zeroext 32164, i16 noundef zeroext 3421, i16 noundef zeroext -26822)
  store <2 x i64> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -361, i16 noundef zeroext -18000, i16 noundef zeroext 21879, i16 noundef zeroext 12881, i16 noundef zeroext -14621, i16 noundef zeroext 31304, i16 noundef zeroext 10941, i16 noundef zeroext -7552)
  store <2 x i64> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -31965, i16 noundef zeroext 12594, i16 noundef zeroext 3662, i16 noundef zeroext 12881, i16 noundef zeroext -14621, i16 noundef zeroext 31304, i16 noundef zeroext 3421, i16 noundef zeroext -26822)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 17540, i16 noundef zeroext -2692, i16 noundef zeroext -18978, i16 noundef zeroext -20438, i16 noundef zeroext 32389, i16 noundef zeroext 20250, i16 noundef zeroext 19285, i16 noundef zeroext -24674)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 17361, i16 noundef zeroext 8131, i16 noundef zeroext -15290, i16 noundef zeroext 30481, i16 noundef zeroext 30265, i16 noundef zeroext -8097, i16 noundef zeroext -23178, i16 noundef zeroext 24996)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 17361, i16 noundef zeroext 8131, i16 noundef zeroext -18978, i16 noundef zeroext 30481, i16 noundef zeroext 30265, i16 noundef zeroext 20250, i16 noundef zeroext 19285, i16 noundef zeroext 24996)
  store <2 x i64> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 11573, i16 noundef zeroext -8782, i16 noundef zeroext -26676, i16 noundef zeroext 26669, i16 noundef zeroext 21209, i16 noundef zeroext 2072, i16 noundef zeroext 19855, i16 noundef zeroext 11067)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 4235, i16 noundef zeroext 30280, i16 noundef zeroext 23335, i16 noundef zeroext 17584, i16 noundef zeroext 3445, i16 noundef zeroext 1117, i16 noundef zeroext -18568, i16 noundef zeroext -6832)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 4235, i16 noundef zeroext 30280, i16 noundef zeroext 23335, i16 noundef zeroext 17584, i16 noundef zeroext 3445, i16 noundef zeroext 1117, i16 noundef zeroext 19855, i16 noundef zeroext 11067)
  store <2 x i64> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 1826, i16 noundef zeroext -30762, i16 noundef zeroext 17130, i16 noundef zeroext -21361, i16 noundef zeroext -4671, i16 noundef zeroext -10878, i16 noundef zeroext -2984, i16 noundef zeroext -3303)
  store <2 x i64> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 15183, i16 noundef zeroext -9938, i16 noundef zeroext 5779, i16 noundef zeroext 28145, i16 noundef zeroext 24471, i16 noundef zeroext -15362, i16 noundef zeroext -12507, i16 noundef zeroext -22532)
  store <2 x i64> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.48, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 1826, i16 noundef zeroext -30762, i16 noundef zeroext 5779, i16 noundef zeroext 28145, i16 noundef zeroext 24471, i16 noundef zeroext -15362, i16 noundef zeroext -12507, i16 noundef zeroext -22532)
  store <2 x i64> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup59

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.48], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.48, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a52, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx53 = getelementptr inbounds [8 x %struct.anon.48], ptr %test_vec, i64 0, i64 %3
  %b54 = getelementptr inbounds %struct.anon.48, ptr %arrayidx53, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b54, align 16, !tbaa !16
  %call55 = call <2 x i64> @simde_mm_min_epu16(<2 x i64> noundef %2, <2 x i64> noundef %4)
  store <2 x i64> %call55, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r51, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx56 = getelementptr inbounds [8 x %struct.anon.48], ptr %test_vec, i64 0, i64 %6
  %r57 = getelementptr inbounds %struct.anon.48, ptr %arrayidx56, i32 0, i32 2
  %7 = load <2 x i64>, ptr %r57, align 16, !tbaa !16
  %call58 = call i32 @simde_test_x86_assert_equal_u16x8_(<2 x i64> noundef %5, <2 x i64> noundef %7, ptr noundef @.str.72, i32 noundef 2498, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call58, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup59 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup59:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest60 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest60, label %cleanup61 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup59
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup61

cleanup61:                                        ; preds = %for.end, %cleanup59
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_min_epu32() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.49], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.49], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.49, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 788201309, i32 noundef 2071601612, i32 noundef -1171357788, i32 noundef 1344608341)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.49, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -312269380, i32 noundef 968486606, i32 noundef 1116860132, i32 noundef -1469828995)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.49, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 788201309, i32 noundef 968486606, i32 noundef 1116860132, i32 noundef 1344608341)
  store <2 x i64> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.49, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 384132137, i32 noundef 1977877021, i32 noundef -5219548, i32 noundef -1779004770)
  store <2 x i64> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -425954486, i32 noundef 645527240, i32 noundef -64617766, i32 noundef 1145244296)
  store <2 x i64> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 384132137, i32 noundef 645527240, i32 noundef -64617766, i32 noundef 1145244296)
  store <2 x i64> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -320236568, i32 noundef -1052748964, i32 noundef 1720053534, i32 noundef -1135961868)
  store <2 x i64> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -438025116, i32 noundef -89570425, i32 noundef -2021994560, i32 noundef -181413753)
  store <2 x i64> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -438025116, i32 noundef -1052748964, i32 noundef 1720053534, i32 noundef -1135961868)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1040090220, i32 noundef -1895819155, i32 noundef -1356124639, i32 noundef 1961058722)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1528033433, i32 noundef 461232656, i32 noundef 1948639979, i32 noundef 1593317844)
  store <2 x i64> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1528033433, i32 noundef 461232656, i32 noundef 1948639979, i32 noundef 1593317844)
  store <2 x i64> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1721814381, i32 noundef -1015195967, i32 noundef 1032528892, i32 noundef 1770589845)
  store <2 x i64> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 338961476, i32 noundef 1015681646, i32 noundef -1765795945, i32 noundef 1474803551)
  store <2 x i64> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 338961476, i32 noundef 1015681646, i32 noundef 1032528892, i32 noundef 1474803551)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1428972427, i32 noundef -935684292, i32 noundef -1918016393, i32 noundef 2025629636)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1089016862, i32 noundef -1043229232, i32 noundef -1901803839, i32 noundef 147184464)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1089016862, i32 noundef -1043229232, i32 noundef -1918016393, i32 noundef 147184464)
  store <2 x i64> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1041113949, i32 noundef -1884436395, i32 noundef 131686205, i32 noundef -1146568733)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1539533337, i32 noundef -395165588, i32 noundef -937628567, i32 noundef 465532279)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1041113949, i32 noundef -1884436395, i32 noundef 131686205, i32 noundef 465532279)
  store <2 x i64> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1723887821, i32 noundef -173795701, i32 noundef -445107806, i32 noundef -1784686142)
  store <2 x i64> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1698631482, i32 noundef -2054143786, i32 noundef -1685342245, i32 noundef 1259317116)
  store <2 x i64> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.49, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1723887821, i32 noundef -2054143786, i32 noundef -1685342245, i32 noundef 1259317116)
  store <2 x i64> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup59

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.49], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.49, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a52, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx53 = getelementptr inbounds [8 x %struct.anon.49], ptr %test_vec, i64 0, i64 %3
  %b54 = getelementptr inbounds %struct.anon.49, ptr %arrayidx53, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b54, align 16, !tbaa !16
  %call55 = call <2 x i64> @simde_mm_min_epu32(<2 x i64> noundef %2, <2 x i64> noundef %4)
  store <2 x i64> %call55, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r51, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx56 = getelementptr inbounds [8 x %struct.anon.49], ptr %test_vec, i64 0, i64 %6
  %r57 = getelementptr inbounds %struct.anon.49, ptr %arrayidx56, i32 0, i32 2
  %7 = load <2 x i64>, ptr %r57, align 16, !tbaa !16
  %call58 = call i32 @simde_test_x86_assert_equal_u32x4_(<2 x i64> noundef %5, <2 x i64> noundef %7, ptr noundef @.str.72, i32 noundef 2539, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call58, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup59 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup59:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest60 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest60, label %cleanup61 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup59
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup61

cleanup61:                                        ; preds = %for.end, %cleanup59
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_minpos_epu16() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.50], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r36 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.50], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.50, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -24718, i16 noundef zeroext 13812, i16 noundef zeroext 10872, i16 noundef zeroext -11412, i16 noundef zeroext 15100, i16 noundef zeroext 22810, i16 noundef zeroext 31798, i16 noundef zeroext -7519)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.50, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 5, i16 noundef zeroext 10872)
  store <2 x i64> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.50, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -27880, i16 noundef zeroext -26732, i16 noundef zeroext -29963, i16 noundef zeroext -32000, i16 noundef zeroext 16030, i16 noundef zeroext -15105, i16 noundef zeroext -29700, i16 noundef zeroext -28045)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %r4 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 3, i16 noundef zeroext 16030)
  store <2 x i64> %call5, ptr %r4, align 16, !tbaa !16
  %arrayinit.element6 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element, i64 1
  %a7 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element6, i32 0, i32 0
  %call8 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -9322, i16 noundef zeroext -8860, i16 noundef zeroext -9492, i16 noundef zeroext -5917, i16 noundef zeroext 21150, i16 noundef zeroext -17554, i16 noundef zeroext 92, i16 noundef zeroext -18868)
  store <2 x i64> %call8, ptr %a7, align 16, !tbaa !16
  %r9 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element6, i32 0, i32 1
  %call10 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 1, i16 noundef zeroext 92)
  store <2 x i64> %call10, ptr %r9, align 16, !tbaa !16
  %arrayinit.element11 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element6, i64 1
  %a12 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element11, i32 0, i32 0
  %call13 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 30841, i16 noundef zeroext -24055, i16 noundef zeroext 22332, i16 noundef zeroext 20377, i16 noundef zeroext 8461, i16 noundef zeroext 16174, i16 noundef zeroext -19368, i16 noundef zeroext -26790)
  store <2 x i64> %call13, ptr %a12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element11, i32 0, i32 1
  %call15 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 3, i16 noundef zeroext 8461)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element11, i64 1
  %a17 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -26986, i16 noundef zeroext -2505, i16 noundef zeroext 12859, i16 noundef zeroext -28837, i16 noundef zeroext 19386, i16 noundef zeroext -15948, i16 noundef zeroext 27067, i16 noundef zeroext 12812)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 12812)
  store <2 x i64> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element16, i64 1
  %a22 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 20747, i16 noundef zeroext 29576, i16 noundef zeroext 5460, i16 noundef zeroext -26676, i16 noundef zeroext -13428, i16 noundef zeroext 149, i16 noundef zeroext -1555, i16 noundef zeroext 19000)
  store <2 x i64> %call23, ptr %a22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 2, i16 noundef zeroext 149)
  store <2 x i64> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element21, i64 1
  %a27 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 31686, i16 noundef zeroext 5758, i16 noundef zeroext -1212, i16 noundef zeroext -9612, i16 noundef zeroext -21969, i16 noundef zeroext 17467, i16 noundef zeroext 18633, i16 noundef zeroext 20456)
  store <2 x i64> %call28, ptr %a27, align 16, !tbaa !16
  %r29 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 6, i16 noundef zeroext 5758)
  store <2 x i64> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element26, i64 1
  %a32 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 13431, i16 noundef zeroext -16909, i16 noundef zeroext 23340, i16 noundef zeroext 23935, i16 noundef zeroext 12927, i16 noundef zeroext -17124, i16 noundef zeroext -31701, i16 noundef zeroext 15901)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %r34 = getelementptr inbounds %struct.anon.50, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 3, i16 noundef zeroext 12927)
  store <2 x i64> %call35, ptr %r34, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup42

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r36) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.50], ptr %test_vec, i64 0, i64 %1
  %a37 = getelementptr inbounds %struct.anon.50, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a37, align 16, !tbaa !16
  %call38 = call <2 x i64> @simde_mm_minpos_epu16(<2 x i64> noundef %2)
  store <2 x i64> %call38, ptr %r36, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <2 x i64>, ptr %r36, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx39 = getelementptr inbounds [8 x %struct.anon.50], ptr %test_vec, i64 0, i64 %4
  %r40 = getelementptr inbounds %struct.anon.50, ptr %arrayidx39, i32 0, i32 1
  %5 = load <2 x i64>, ptr %r40, align 16, !tbaa !16
  %call41 = call i32 @simde_test_x86_assert_equal_u16x8_(<2 x i64> noundef %3, <2 x i64> noundef %5, ptr noundef @.str.72, i32 noundef 2587, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call41, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r36) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup42 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup42:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest43 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest43, label %cleanup44 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup42
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup44

cleanup44:                                        ; preds = %for.end, %cleanup42
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_mpsadbw_epu8() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.51], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.51], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.51, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -30, i8 noundef zeroext -52, i8 noundef zeroext -124, i8 noundef zeroext -65, i8 noundef zeroext 109, i8 noundef zeroext 5, i8 noundef zeroext 22, i8 noundef zeroext -47, i8 noundef zeroext -13, i8 noundef zeroext 105, i8 noundef zeroext -70, i8 noundef zeroext -105, i8 noundef zeroext 27, i8 noundef zeroext 30, i8 noundef zeroext -33, i8 noundef zeroext 88)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.51, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -117, i8 noundef zeroext 113, i8 noundef zeroext 31, i8 noundef zeroext 64, i8 noundef zeroext -101, i8 noundef zeroext 28, i8 noundef zeroext -33, i8 noundef zeroext -61, i8 noundef zeroext -105, i8 noundef zeroext 30, i8 noundef zeroext 86, i8 noundef zeroext 95, i8 noundef zeroext -98, i8 noundef zeroext 54, i8 noundef zeroext 10, i8 noundef zeroext 66)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.51, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 289, i16 noundef zeroext 222, i16 noundef zeroext 124, i16 noundef zeroext 292, i16 noundef zeroext 582, i16 noundef zeroext 466, i16 noundef zeroext 396, i16 noundef zeroext 354)
  store <2 x i64> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.51, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -85, i8 noundef zeroext 80, i8 noundef zeroext 108, i8 noundef zeroext -20, i8 noundef zeroext -17, i8 noundef zeroext -65, i8 noundef zeroext -37, i8 noundef zeroext -48, i8 noundef zeroext -91, i8 noundef zeroext 30, i8 noundef zeroext -5, i8 noundef zeroext -60, i8 noundef zeroext 25, i8 noundef zeroext -1, i8 noundef zeroext 78, i8 noundef zeroext 81)
  store <2 x i64> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 98, i8 noundef zeroext 67, i8 noundef zeroext -115, i8 noundef zeroext -17, i8 noundef zeroext 33, i8 noundef zeroext -118, i8 noundef zeroext -95, i8 noundef zeroext -124, i8 noundef zeroext 23, i8 noundef zeroext 84, i8 noundef zeroext -86, i8 noundef zeroext -26, i8 noundef zeroext -42, i8 noundef zeroext 115, i8 noundef zeroext 58, i8 noundef zeroext -126)
  store <2 x i64> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 154, i16 noundef zeroext 325, i16 noundef zeroext 380, i16 noundef zeroext 374, i16 noundef zeroext 386, i16 noundef zeroext 495, i16 noundef zeroext 331, i16 noundef zeroext 257)
  store <2 x i64> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 36, i8 noundef zeroext 1, i8 noundef zeroext 5, i8 noundef zeroext 22, i8 noundef zeroext 73, i8 noundef zeroext -14, i8 noundef zeroext 47, i8 noundef zeroext 2, i8 noundef zeroext -52, i8 noundef zeroext -11, i8 noundef zeroext 42, i8 noundef zeroext 38, i8 noundef zeroext 36, i8 noundef zeroext -120, i8 noundef zeroext 36, i8 noundef zeroext -93)
  store <2 x i64> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -88, i8 noundef zeroext -43, i8 noundef zeroext 2, i8 noundef zeroext 30, i8 noundef zeroext 25, i8 noundef zeroext 127, i8 noundef zeroext 31, i8 noundef zeroext -123, i8 noundef zeroext 118, i8 noundef zeroext 121, i8 noundef zeroext 113, i8 noundef zeroext -25, i8 noundef zeroext 34, i8 noundef zeroext 80, i8 noundef zeroext 116, i8 noundef zeroext 25)
  store <2 x i64> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 438, i16 noundef zeroext 637, i16 noundef zeroext 543, i16 noundef zeroext 197, i16 noundef zeroext 414, i16 noundef zeroext 749, i16 noundef zeroext 430, i16 noundef zeroext 116)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 29, i8 noundef zeroext 29, i8 noundef zeroext -57, i8 noundef zeroext -115, i8 noundef zeroext -103, i8 noundef zeroext -95, i8 noundef zeroext -54, i8 noundef zeroext 57, i8 noundef zeroext 56, i8 noundef zeroext 10, i8 noundef zeroext 125, i8 noundef zeroext 91, i8 noundef zeroext -44, i8 noundef zeroext -88, i8 noundef zeroext 43, i8 noundef zeroext 108)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 54, i8 noundef zeroext 56, i8 noundef zeroext -63, i8 noundef zeroext -72, i8 noundef zeroext 44, i8 noundef zeroext 35, i8 noundef zeroext -123, i8 noundef zeroext 78, i8 noundef zeroext 34, i8 noundef zeroext -57, i8 noundef zeroext -64, i8 noundef zeroext 116, i8 noundef zeroext 79, i8 noundef zeroext -119, i8 noundef zeroext -106, i8 noundef zeroext 19)
  store <2 x i64> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 251, i16 noundef zeroext 293, i16 noundef zeroext 234, i16 noundef zeroext 340, i16 noundef zeroext 517, i16 noundef zeroext 460, i16 noundef zeroext 245, i16 noundef zeroext 209)
  store <2 x i64> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -45, i8 noundef zeroext -29, i8 noundef zeroext -106, i8 noundef zeroext 37, i8 noundef zeroext -94, i8 noundef zeroext -7, i8 noundef zeroext -41, i8 noundef zeroext -61, i8 noundef zeroext 63, i8 noundef zeroext -73, i8 noundef zeroext -60, i8 noundef zeroext 97, i8 noundef zeroext 60, i8 noundef zeroext -64, i8 noundef zeroext -62, i8 noundef zeroext -92)
  store <2 x i64> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 120, i8 noundef zeroext 70, i8 noundef zeroext -18, i8 noundef zeroext 106, i8 noundef zeroext 29, i8 noundef zeroext 66, i8 noundef zeroext 80, i8 noundef zeroext -82, i8 noundef zeroext 76, i8 noundef zeroext -105, i8 noundef zeroext 56, i8 noundef zeroext 77, i8 noundef zeroext 36, i8 noundef zeroext -118, i8 noundef zeroext -86, i8 noundef zeroext 105)
  store <2 x i64> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 444, i16 noundef zeroext 282, i16 noundef zeroext 295, i16 noundef zeroext 333, i16 noundef zeroext 360, i16 noundef zeroext 472, i16 noundef zeroext 227, i16 noundef zeroext 221)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -89, i8 noundef zeroext -25, i8 noundef zeroext -127, i8 noundef zeroext -20, i8 noundef zeroext -98, i8 noundef zeroext 34, i8 noundef zeroext -37, i8 noundef zeroext 52, i8 noundef zeroext -55, i8 noundef zeroext 55, i8 noundef zeroext 88, i8 noundef zeroext 76, i8 noundef zeroext 91, i8 noundef zeroext -64, i8 noundef zeroext 80, i8 noundef zeroext -115)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -41, i8 noundef zeroext 0, i8 noundef zeroext 39, i8 noundef zeroext -90, i8 noundef zeroext 94, i8 noundef zeroext -25, i8 noundef zeroext -32, i8 noundef zeroext -116, i8 noundef zeroext -103, i8 noundef zeroext 38, i8 noundef zeroext -27, i8 noundef zeroext -17, i8 noundef zeroext -89, i8 noundef zeroext 85, i8 noundef zeroext -14, i8 noundef zeroext -25)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 350, i16 noundef zeroext 573, i16 noundef zeroext 237, i16 noundef zeroext 385, i16 noundef zeroext 448, i16 noundef zeroext 329, i16 noundef zeroext 458, i16 noundef zeroext 208)
  store <2 x i64> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 125, i8 noundef zeroext 70, i8 noundef zeroext -8, i8 noundef zeroext -63, i8 noundef zeroext -12, i8 noundef zeroext 76, i8 noundef zeroext -93, i8 noundef zeroext -106, i8 noundef zeroext -87, i8 noundef zeroext 24, i8 noundef zeroext 114, i8 noundef zeroext 21, i8 noundef zeroext -85, i8 noundef zeroext 13, i8 noundef zeroext -99, i8 noundef zeroext -78)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -58, i8 noundef zeroext -103, i8 noundef zeroext -51, i8 noundef zeroext -37, i8 noundef zeroext -58, i8 noundef zeroext 83, i8 noundef zeroext 62, i8 noundef zeroext 96, i8 noundef zeroext 119, i8 noundef zeroext -43, i8 noundef zeroext 90, i8 noundef zeroext -109, i8 noundef zeroext -24, i8 noundef zeroext 64, i8 noundef zeroext -92, i8 noundef zeroext -127)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 260, i16 noundef zeroext 272, i16 noundef zeroext 281, i16 noundef zeroext 234, i16 noundef zeroext 237, i16 noundef zeroext 269, i16 noundef zeroext 350, i16 noundef zeroext 447)
  store <2 x i64> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext 35, i8 noundef zeroext 118, i8 noundef zeroext -58, i8 noundef zeroext 85, i8 noundef zeroext 8, i8 noundef zeroext -106, i8 noundef zeroext 121, i8 noundef zeroext -13, i8 noundef zeroext 16, i8 noundef zeroext -35, i8 noundef zeroext -29, i8 noundef zeroext 37, i8 noundef zeroext 87, i8 noundef zeroext 66, i8 noundef zeroext -40, i8 noundef zeroext -79)
  store <2 x i64> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext -108, i8 noundef zeroext -6, i8 noundef zeroext 9, i8 noundef zeroext -52, i8 noundef zeroext -120, i8 noundef zeroext 106, i8 noundef zeroext 76, i8 noundef zeroext -94, i8 noundef zeroext 111, i8 noundef zeroext 61, i8 noundef zeroext 51, i8 noundef zeroext -82, i8 noundef zeroext -54, i8 noundef zeroext -8, i8 noundef zeroext 64, i8 noundef zeroext -82)
  store <2 x i64> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.51, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 354, i16 noundef zeroext 270, i16 noundef zeroext 529, i16 noundef zeroext 391, i16 noundef zeroext 553, i16 noundef zeroext 58, i16 noundef zeroext 564, i16 noundef zeroext 546)
  store <2 x i64> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup59

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.51], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.51, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a52, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx53 = getelementptr inbounds [8 x %struct.anon.51], ptr %test_vec, i64 0, i64 %3
  %b54 = getelementptr inbounds %struct.anon.51, ptr %arrayidx53, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b54, align 16, !tbaa !16
  %call55 = call <2 x i64> @simde_mm_mpsadbw_epu8(<2 x i64> noundef %2, <2 x i64> noundef %4, i32 noundef 7)
  store <2 x i64> %call55, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r51, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx56 = getelementptr inbounds [8 x %struct.anon.51], ptr %test_vec, i64 0, i64 %6
  %r57 = getelementptr inbounds %struct.anon.51, ptr %arrayidx56, i32 0, i32 2
  %7 = load <2 x i64>, ptr %r57, align 16, !tbaa !16
  %call58 = call i32 @simde_test_x86_assert_equal_u16x8_(<2 x i64> noundef %5, <2 x i64> noundef %7, ptr noundef @.str.72, i32 noundef 2684, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call58, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup59 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup59:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest60 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest60, label %cleanup61 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup59
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup61

cleanup61:                                        ; preds = %for.end, %cleanup59
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_mul_epi32() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.52], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.52], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.52, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1795240134, i32 noundef -225235276, i32 noundef 260214100, i32 noundef -1437997118)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.52, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1930516827, i32 noundef -2112091397, i32 noundef -2111031164, i32 noundef 1337416900)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.52, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 475717488740520572, i64 noundef -1923201647764494200)
  store <2 x i64> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.52, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -2008734650, i32 noundef 1987866784, i32 noundef 1460586541, i32 noundef -308079008)
  store <2 x i64> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1619497162, i32 noundef 1948444521, i32 noundef -1962326453, i32 noundef 355525826)
  store <2 x i64> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 3873248143762690464, i64 noundef -109530043792460608)
  store <2 x i64> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -967525151, i32 noundef 610102911, i32 noundef -82193087, i32 noundef 610685272)
  store <2 x i64> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -464555473, i32 noundef 1911406284, i32 noundef 1504403418, i32 noundef 1044708348)
  store <2 x i64> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 1166154537972092724, i64 noundef 637988001659050656)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 734959886, i32 noundef 727387476, i32 noundef -1178464916, i32 noundef 759159032)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 227151790, i32 noundef 2027589232, i32 noundef -510665157, i32 noundef 664410245)
  store <2 x i64> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 1474843013829258432, i64 noundef 504393038445082840)
  store <2 x i64> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -981875510, i32 noundef -1517853387, i32 noundef 645890048, i32 noundef 1483649404)
  store <2 x i64> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1176179108, i32 noundef -884770028, i32 noundef 1667209942, i32 noundef -150484050)
  store <2 x i64> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 1342951183715884836, i64 noundef -223265571094006200)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -229613172, i32 noundef -220620915, i32 noundef 1178015644, i32 noundef -1087297921)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1751226172, i32 noundef -1807182523, i32 noundef 804591673, i32 noundef -413406506)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 398702261796268545, i64 noundef 449496034501674026)
  store <2 x i64> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1537480837, i32 noundef -185479936, i32 noundef 386155243, i32 noundef 479622311)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -579116298, i32 noundef -674452315, i32 noundef -142346909, i32 noundef -1350064613)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 125097372221251840, i64 noundef -647521109686380643)
  store <2 x i64> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 2146108348, i32 noundef 341648975, i32 noundef 901701854, i32 noundef -45673158)
  store <2 x i64> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 723948067, i32 noundef 1076365190, i32 noundef -693273363, i32 noundef 420311114)
  store <2 x i64> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.52, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <2 x i64> @simde_mm_set_epi64x(i64 noundef 367739063889180250, i64 noundef -19196935918878012)
  store <2 x i64> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup59

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.52], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.52, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a52, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx53 = getelementptr inbounds [8 x %struct.anon.52], ptr %test_vec, i64 0, i64 %3
  %b54 = getelementptr inbounds %struct.anon.52, ptr %arrayidx53, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b54, align 16, !tbaa !16
  %call55 = call <2 x i64> @simde_mm_mul_epi32(<2 x i64> noundef %2, <2 x i64> noundef %4)
  store <2 x i64> %call55, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r51, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx56 = getelementptr inbounds [8 x %struct.anon.52], ptr %test_vec, i64 0, i64 %6
  %r57 = getelementptr inbounds %struct.anon.52, ptr %arrayidx56, i32 0, i32 2
  %7 = load <2 x i64>, ptr %r57, align 16, !tbaa !16
  %call58 = call i32 @simde_test_x86_assert_equal_i32x4_(<2 x i64> noundef %5, <2 x i64> noundef %7, ptr noundef @.str.72, i32 noundef 2725, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call58, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup59 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup59:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest60 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest60, label %cleanup61 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup59
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup61

cleanup61:                                        ; preds = %for.end, %cleanup59
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_mullo_epi32() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.53], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.53], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.53, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1431531471, i32 noundef -1934656662, i32 noundef -638668877, i32 noundef 1966621031)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.53, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -646581607, i32 noundef 1232530244, i32 noundef 841047033, i32 noundef -1472432488)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.53, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1865056439, i32 noundef -1849485784, i32 noundef 1840285211, i32 noundef 1940934440)
  store <2 x i64> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.53, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 2119691862, i32 noundef 1656188631, i32 noundef 949015012, i32 noundef -645064268)
  store <2 x i64> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1854664684, i32 noundef 1364588379, i32 noundef -185048322, i32 noundef 1546431794)
  store <2 x i64> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -314310328, i32 noundef -410462355, i32 noundef 887719992, i32 noundef -220354264)
  store <2 x i64> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 390191893, i32 noundef 1246080619, i32 noundef 2032818940, i32 noundef -1664549536)
  store <2 x i64> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1802476280, i32 noundef -1492538899, i32 noundef -866846002, i32 noundef -1929477089)
  store <2 x i64> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -357441960, i32 noundef -1318446065, i32 noundef -2019602744, i32 noundef -2076430688)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -629988407, i32 noundef -1719063308, i32 noundef -231912988, i32 noundef 1462330866)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1320599620, i32 noundef -769970788, i32 noundef -625134420, i32 noundef 293199422)
  store <2 x i64> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -273826148, i32 noundef -1841674064, i32 noundef -1631324880, i32 noundef 1137740956)
  store <2 x i64> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1221152076, i32 noundef -1223458578, i32 noundef -1263311025, i32 noundef 2089857790)
  store <2 x i64> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -2068401725, i32 noundef 1531524331, i32 noundef 1064638153, i32 noundef -843878287)
  store <2 x i64> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1009816348, i32 noundef 1660269178, i32 noundef -203954425, i32 noundef -674749922)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1283522478, i32 noundef 524522527, i32 noundef 1152886109, i32 noundef -438302719)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -2012975476, i32 noundef -67951228, i32 noundef 258710699, i32 noundef -25585755)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1289709784, i32 noundef -508699908, i32 noundef 1615798559, i32 noundef 345423781)
  store <2 x i64> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 199098300, i32 noundef -1941350427, i32 noundef -1170519288, i32 noundef 2117275260)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1736533752, i32 noundef 668304389, i32 noundef -1871663356, i32 noundef -231105582)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1957733920, i32 noundef -1823880327, i32 noundef -994597856, i32 noundef -515705416)
  store <2 x i64> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 796248112, i32 noundef -74441002, i32 noundef 756194998, i32 noundef 128690934)
  store <2 x i64> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -934813484, i32 noundef 1495167051, i32 noundef 549239917, i32 noundef 1315900336)
  store <2 x i64> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.53, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1644414912, i32 noundef -1010128718, i32 noundef 723729278, i32 noundef -1157096672)
  store <2 x i64> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup59

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.53], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.53, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a52, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx53 = getelementptr inbounds [8 x %struct.anon.53], ptr %test_vec, i64 0, i64 %3
  %b54 = getelementptr inbounds %struct.anon.53, ptr %arrayidx53, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b54, align 16, !tbaa !16
  %call55 = call <2 x i64> @simde_mm_mullo_epi32(<2 x i64> noundef %2, <2 x i64> noundef %4)
  store <2 x i64> %call55, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r51, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx56 = getelementptr inbounds [8 x %struct.anon.53], ptr %test_vec, i64 0, i64 %6
  %r57 = getelementptr inbounds %struct.anon.53, ptr %arrayidx56, i32 0, i32 2
  %7 = load <2 x i64>, ptr %r57, align 16, !tbaa !16
  %call58 = call i32 @simde_test_x86_assert_equal_i32x4_(<2 x i64> noundef %5, <2 x i64> noundef %7, ptr noundef @.str.72, i32 noundef 2766, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call58, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup59 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup59:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest60 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest60, label %cleanup61 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup59
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup61

cleanup61:                                        ; preds = %for.end, %cleanup59
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_x_mm_mullo_epu32() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.54], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.54], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.54, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1269782204, i32 noundef 1071139209, i32 noundef -182950718, i32 noundef 2016123065)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.54, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 290328727, i32 noundef -2068884960, i32 noundef 501526514, i32 noundef 1649328035)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.54, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 2095060764, i32 noundef 725488416, i32 noundef 347594084, i32 noundef 1695696075)
  store <2 x i64> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.54, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1188926582, i32 noundef -630287296, i32 noundef 790276509, i32 noundef -785996287)
  store <2 x i64> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1699381529, i32 noundef 875841923, i32 noundef -844085459, i32 noundef 1814797908)
  store <2 x i64> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -193918342, i32 noundef 1809587392, i32 noundef 27941785, i32 noundef -917629356)
  store <2 x i64> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1401216811, i32 noundef 1249313952, i32 noundef -989718296, i32 noundef -1414102119)
  store <2 x i64> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 24592541, i32 noundef 966747003, i32 noundef -659820663, i32 noundef -129567439)
  store <2 x i64> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1480891743, i32 noundef 1297684704, i32 noundef -967316440, i32 noundef -1112105655)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 189392542, i32 noundef -574210206, i32 noundef -697726732, i32 noundef 1088106434)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1034094926, i32 noundef 1980368114, i32 noundef -189809602, i32 noundef 87964330)
  store <2 x i64> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 2043031004, i32 noundef 1681486500, i32 noundef -1662100712, i32 noundef 358329044)
  store <2 x i64> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -543373937, i32 noundef 552022460, i32 noundef -1925844002, i32 noundef 1803067683)
  store <2 x i64> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -526205014, i32 noundef 1316515183, i32 noundef -653435013, i32 noundef -478731466)
  store <2 x i64> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1711349258, i32 noundef 1284217988, i32 noundef 1857129898, i32 noundef 431933026)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1492473270, i32 noundef 1074984006, i32 noundef -42059580, i32 noundef 1202847242)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -951459066, i32 noundef 2110123114, i32 noundef 454026106, i32 noundef 903743904)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1952029628, i32 noundef 686271740, i32 noundef -1174873752, i32 noundef 1876500544)
  store <2 x i64> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 998872003, i32 noundef 1287827774, i32 noundef 838516167, i32 noundef 572896344)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1333196355, i32 noundef -820227783, i32 noundef -1829538530, i32 noundef 183148961)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 299961865, i32 noundef 909513934, i32 noundef 369307730, i32 noundef 2022818648)
  store <2 x i64> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1913853291, i32 noundef 17395766, i32 noundef 1942367476, i32 noundef 903009655)
  store <2 x i64> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -2039504905, i32 noundef 872948613, i32 noundef 1238590873, i32 noundef 2084494234)
  store <2 x i64> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.54, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -907812669, i32 noundef 1307487758, i32 noundef 38347220, i32 noundef 339949206)
  store <2 x i64> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup59

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.54], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.54, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a52, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx53 = getelementptr inbounds [8 x %struct.anon.54], ptr %test_vec, i64 0, i64 %3
  %b54 = getelementptr inbounds %struct.anon.54, ptr %arrayidx53, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b54, align 16, !tbaa !16
  %call55 = call <2 x i64> @simde_x_mm_mullo_epu32(<2 x i64> noundef %2, <2 x i64> noundef %4)
  store <2 x i64> %call55, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r51, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx56 = getelementptr inbounds [8 x %struct.anon.54], ptr %test_vec, i64 0, i64 %6
  %r57 = getelementptr inbounds %struct.anon.54, ptr %arrayidx56, i32 0, i32 2
  %7 = load <2 x i64>, ptr %r57, align 16, !tbaa !16
  %call58 = call i32 @simde_test_x86_assert_equal_u32x4_(<2 x i64> noundef %5, <2 x i64> noundef %7, ptr noundef @.str.72, i32 noundef 2807, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call58, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup59 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup59:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest60 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest60, label %cleanup61 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup59
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup61

cleanup61:                                        ; preds = %for.end, %cleanup59
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_packus_epi32() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.55], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r51 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.55], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.55, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1174506975, i32 noundef -1622542395, i32 noundef -228565455, i32 noundef 1722092951)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.55, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -188735178, i32 noundef -859437923, i32 noundef 40707, i32 noundef -2078308106)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.55, ptr %arrayinit.begin, i32 0, i32 2
  %call2 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext -24829, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext -1)
  store <2 x i64> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.55, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 279157042, i32 noundef -664033471, i32 noundef 1210432777, i32 noundef -1162534366)
  store <2 x i64> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 330673804, i32 noundef -1666667776, i32 noundef -1924642427, i32 noundef -1118465206)
  store <2 x i64> %call6, ptr %b5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element, i32 0, i32 2
  %call8 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -1, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext -1, i16 noundef zeroext 0, i16 noundef zeroext -1, i16 noundef zeroext 0)
  store <2 x i64> %call8, ptr %r7, align 16, !tbaa !16
  %arrayinit.element9 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element, i64 1
  %a10 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element9, i32 0, i32 0
  %call11 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1675273454, i32 noundef 252374167, i32 noundef -1898193118, i32 noundef -2121147721)
  store <2 x i64> %call11, ptr %a10, align 16, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element9, i32 0, i32 1
  %call13 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1175340609, i32 noundef 1859609595, i32 noundef 305301369, i32 noundef 1936442403)
  store <2 x i64> %call13, ptr %b12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element9, i32 0, i32 2
  %call15 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 0, i16 noundef zeroext -1, i16 noundef zeroext -1, i16 noundef zeroext -1, i16 noundef zeroext 0, i16 noundef zeroext -1, i16 noundef zeroext 0, i16 noundef zeroext 0)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element9, i64 1
  %a17 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -372493069, i32 noundef -1071911212, i32 noundef 122218483, i32 noundef 1644546153)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -603471664, i32 noundef -435236634, i32 noundef -1237577227, i32 noundef 40156)
  store <2 x i64> %call20, ptr %b19, align 16, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element16, i32 0, i32 2
  %call22 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext -25380, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext -1, i16 noundef zeroext -1)
  store <2 x i64> %call22, ptr %r21, align 16, !tbaa !16
  %arrayinit.element23 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element16, i64 1
  %a24 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element23, i32 0, i32 0
  %call25 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -132052641, i32 noundef 1567528732, i32 noundef -1505776, i32 noundef 422872655)
  store <2 x i64> %call25, ptr %a24, align 16, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element23, i32 0, i32 1
  %call27 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1525337323, i32 noundef -1409556892, i32 noundef -388396270, i32 noundef -2086963765)
  store <2 x i64> %call27, ptr %b26, align 16, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element23, i32 0, i32 2
  %call29 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -1, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext -1, i16 noundef zeroext 0, i16 noundef zeroext -1)
  store <2 x i64> %call29, ptr %r28, align 16, !tbaa !16
  %arrayinit.element30 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element23, i64 1
  %a31 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element30, i32 0, i32 0
  %call32 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1206563380, i32 noundef 1557268555, i32 noundef -872999034, i32 noundef 234221095)
  store <2 x i64> %call32, ptr %a31, align 16, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element30, i32 0, i32 1
  %call34 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 723455818, i32 noundef 773436940, i32 noundef 326719262, i32 noundef -826281673)
  store <2 x i64> %call34, ptr %b33, align 16, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element30, i32 0, i32 2
  %call36 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -1, i16 noundef zeroext -1, i16 noundef zeroext -1, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext -1, i16 noundef zeroext 0, i16 noundef zeroext -1)
  store <2 x i64> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element30, i64 1
  %a38 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -738729427, i32 noundef 1061139854, i32 noundef -2031157453, i32 noundef 2064098327)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1034678142, i32 noundef 97345786, i32 noundef 1187222665, i32 noundef 61643)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element37, i32 0, i32 2
  %call43 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext 0, i16 noundef zeroext -1, i16 noundef zeroext -1, i16 noundef zeroext -3893, i16 noundef zeroext 0, i16 noundef zeroext -1, i16 noundef zeroext 0, i16 noundef zeroext -1)
  store <2 x i64> %call43, ptr %r42, align 16, !tbaa !16
  %arrayinit.element44 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element37, i64 1
  %a45 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element44, i32 0, i32 0
  %call46 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -2037944282, i32 noundef -355400074, i32 noundef -341422900, i32 noundef -1605623445)
  store <2 x i64> %call46, ptr %a45, align 16, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element44, i32 0, i32 1
  %call48 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 629990551, i32 noundef 397893118, i32 noundef -1310491239, i32 noundef -2050362652)
  store <2 x i64> %call48, ptr %b47, align 16, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.55, ptr %arrayinit.element44, i32 0, i32 2
  %call50 = call <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext -1, i16 noundef zeroext -1, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0, i16 noundef zeroext 0)
  store <2 x i64> %call50, ptr %r49, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup59

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r51) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.55], ptr %test_vec, i64 0, i64 %1
  %a52 = getelementptr inbounds %struct.anon.55, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a52, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx53 = getelementptr inbounds [8 x %struct.anon.55], ptr %test_vec, i64 0, i64 %3
  %b54 = getelementptr inbounds %struct.anon.55, ptr %arrayidx53, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b54, align 16, !tbaa !16
  %call55 = call <2 x i64> @simde_mm_packus_epi32(<2 x i64> noundef %2, <2 x i64> noundef %4)
  store <2 x i64> %call55, ptr %r51, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x i64>, ptr %r51, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx56 = getelementptr inbounds [8 x %struct.anon.55], ptr %test_vec, i64 0, i64 %6
  %r57 = getelementptr inbounds %struct.anon.55, ptr %arrayidx56, i32 0, i32 2
  %7 = load <2 x i64>, ptr %r57, align 16, !tbaa !16
  %call58 = call i32 @simde_test_x86_assert_equal_u16x8_(<2 x i64> noundef %5, <2 x i64> noundef %7, ptr noundef @.str.72, i32 noundef 2856, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call58, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r51) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup59 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup59:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest60 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest60, label %cleanup61 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup59
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup61

cleanup61:                                        ; preds = %for.end, %cleanup59
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_round_pd() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.56], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r43 = alloca <2 x double>, align 16
  %i52 = alloca i64, align 8
  %r57 = alloca <2 x double>, align 16
  %i79 = alloca i64, align 8
  %r84 = alloca <2 x double>, align 16
  %i106 = alloca i64, align 8
  %r111 = alloca <2 x double>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.56], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.56, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x double> @simde_mm_set_pd(double noundef 9.594600e+02, double noundef -6.465600e+02)
  store <2 x double> %call, ptr %a, align 16, !tbaa !16
  %rounding = getelementptr inbounds %struct.anon.56, ptr %arrayinit.begin, i32 0, i32 1
  store i32 0, ptr %rounding, align 16, !tbaa !23
  %r = getelementptr inbounds %struct.anon.56, ptr %arrayinit.begin, i32 0, i32 2
  %call1 = call <2 x double> @simde_mm_set_pd(double noundef 9.590000e+02, double noundef -6.470000e+02)
  store <2 x double> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.56, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x double> @simde_mm_set_pd(double noundef 0xC0896B70A3D70A3D, double noundef 5.157500e+02)
  store <2 x double> %call3, ptr %a2, align 16, !tbaa !16
  %rounding4 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element, i32 0, i32 1
  store i32 0, ptr %rounding4, align 16, !tbaa !23
  %r5 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element, i32 0, i32 2
  %call6 = call <2 x double> @simde_mm_set_pd(double noundef -8.130000e+02, double noundef 5.160000e+02)
  store <2 x double> %call6, ptr %r5, align 16, !tbaa !16
  %arrayinit.element7 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element, i64 1
  %a8 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element7, i32 0, i32 0
  %call9 = call <2 x double> @simde_mm_set_pd(double noundef -3.654300e+02, double noundef 0x408A423D70A3D70A)
  store <2 x double> %call9, ptr %a8, align 16, !tbaa !16
  %rounding10 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element7, i32 0, i32 1
  store i32 1, ptr %rounding10, align 16, !tbaa !23
  %r11 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element7, i32 0, i32 2
  %call12 = call <2 x double> @simde_mm_set_pd(double noundef -3.660000e+02, double noundef 8.400000e+02)
  store <2 x double> %call12, ptr %r11, align 16, !tbaa !16
  %arrayinit.element13 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element7, i64 1
  %a14 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element13, i32 0, i32 0
  %call15 = call <2 x double> @simde_mm_set_pd(double noundef -8.436900e+02, double noundef -6.413600e+02)
  store <2 x double> %call15, ptr %a14, align 16, !tbaa !16
  %rounding16 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element13, i32 0, i32 1
  store i32 1, ptr %rounding16, align 16, !tbaa !23
  %r17 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element13, i32 0, i32 2
  %call18 = call <2 x double> @simde_mm_set_pd(double noundef -8.440000e+02, double noundef -6.420000e+02)
  store <2 x double> %call18, ptr %r17, align 16, !tbaa !16
  %arrayinit.element19 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element13, i64 1
  %a20 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element19, i32 0, i32 0
  %call21 = call <2 x double> @simde_mm_set_pd(double noundef -5.426400e+02, double noundef -7.573400e+02)
  store <2 x double> %call21, ptr %a20, align 16, !tbaa !16
  %rounding22 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element19, i32 0, i32 1
  store i32 2, ptr %rounding22, align 16, !tbaa !23
  %r23 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element19, i32 0, i32 2
  %call24 = call <2 x double> @simde_mm_set_pd(double noundef -5.420000e+02, double noundef -7.570000e+02)
  store <2 x double> %call24, ptr %r23, align 16, !tbaa !16
  %arrayinit.element25 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element19, i64 1
  %a26 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element25, i32 0, i32 0
  %call27 = call <2 x double> @simde_mm_set_pd(double noundef 0xC0828947AE147AE1, double noundef 9.735900e+02)
  store <2 x double> %call27, ptr %a26, align 16, !tbaa !16
  %rounding28 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element25, i32 0, i32 1
  store i32 2, ptr %rounding28, align 16, !tbaa !23
  %r29 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element25, i32 0, i32 2
  %call30 = call <2 x double> @simde_mm_set_pd(double noundef -5.930000e+02, double noundef 9.740000e+02)
  store <2 x double> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element25, i64 1
  %a32 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x double> @simde_mm_set_pd(double noundef 5.467000e+01, double noundef -5.455000e+01)
  store <2 x double> %call33, ptr %a32, align 16, !tbaa !16
  %rounding34 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element31, i32 0, i32 1
  store i32 3, ptr %rounding34, align 16, !tbaa !23
  %r35 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element31, i32 0, i32 2
  %call36 = call <2 x double> @simde_mm_set_pd(double noundef 5.400000e+01, double noundef -5.400000e+01)
  store <2 x double> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element31, i64 1
  %a38 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x double> @simde_mm_set_pd(double noundef -3.189000e+01, double noundef 1.368600e+02)
  store <2 x double> %call39, ptr %a38, align 16, !tbaa !16
  %rounding40 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element37, i32 0, i32 1
  store i32 3, ptr %rounding40, align 16, !tbaa !23
  %r41 = getelementptr inbounds %struct.anon.56, ptr %arrayinit.element37, i32 0, i32 2
  %call42 = call <2 x double> @simde_mm_set_pd(double noundef -3.100000e+01, double noundef 1.360000e+02)
  store <2 x double> %call42, ptr %r41, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 2
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup50

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r43) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.56], ptr %test_vec, i64 0, i64 %1
  %a44 = getelementptr inbounds %struct.anon.56, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x double>, ptr %a44, align 16, !tbaa !16
  %call45 = call <2 x double> @simde_mm_round_pd(<2 x double> noundef %2, i32 noundef 0)
  store <2 x double> %call45, ptr %r43, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <2 x double>, ptr %r43, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx46 = getelementptr inbounds [8 x %struct.anon.56], ptr %test_vec, i64 0, i64 %4
  %r47 = getelementptr inbounds %struct.anon.56, ptr %arrayidx46, i32 0, i32 2
  %5 = load <2 x double>, ptr %r47, align 16, !tbaa !16
  %call48 = call double @simde_test_f64_precision_to_slop(i32 noundef 1)
  %call49 = call i32 @simde_test_x86_assert_equal_f64x2_(<2 x double> noundef %3, <2 x double> noundef %5, double noundef %call48, ptr noundef @.str.72, i32 noundef 2897, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call49, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r43) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup50 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup50:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest51 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest51, label %cleanup133 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup50
  call void @llvm.lifetime.start.p0(i64 8, ptr %i52) #10
  store i64 2, ptr %i52, align 8, !tbaa !11
  br label %for.cond53

for.cond53:                                       ; preds = %for.inc74, %for.end
  %7 = load i64, ptr %i52, align 8, !tbaa !11
  %cmp54 = icmp ult i64 %7, 4
  br i1 %cmp54, label %for.body56, label %for.cond.cleanup55

for.cond.cleanup55:                               ; preds = %for.cond53
  store i32 7, ptr %cleanup.dest.slot, align 4
  br label %cleanup76

for.body56:                                       ; preds = %for.cond53
  call void @llvm.lifetime.start.p0(i64 16, ptr %r57) #10
  %8 = load i64, ptr %i52, align 8, !tbaa !11
  %arrayidx58 = getelementptr inbounds [8 x %struct.anon.56], ptr %test_vec, i64 0, i64 %8
  %a59 = getelementptr inbounds %struct.anon.56, ptr %arrayidx58, i32 0, i32 0
  %9 = load <2 x double>, ptr %a59, align 16, !tbaa !16
  %call60 = call <2 x double> @simde_mm_round_pd(<2 x double> noundef %9, i32 noundef 1)
  store <2 x double> %call60, ptr %r57, align 16, !tbaa !16
  br label %do.body61

do.body61:                                        ; preds = %for.body56
  %10 = load <2 x double>, ptr %r57, align 16, !tbaa !16
  %11 = load i64, ptr %i52, align 8, !tbaa !11
  %arrayidx62 = getelementptr inbounds [8 x %struct.anon.56], ptr %test_vec, i64 0, i64 %11
  %r63 = getelementptr inbounds %struct.anon.56, ptr %arrayidx62, i32 0, i32 2
  %12 = load <2 x double>, ptr %r63, align 16, !tbaa !16
  %call64 = call double @simde_test_f64_precision_to_slop(i32 noundef 1)
  %call65 = call i32 @simde_test_x86_assert_equal_f64x2_(<2 x double> noundef %10, <2 x double> noundef %12, double noundef %call64, ptr noundef @.str.72, i32 noundef 2901, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool66 = icmp ne i32 %call65, 0
  br i1 %tobool66, label %if.then67, label %if.end68

if.then67:                                        ; preds = %do.body61
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup71

if.end68:                                         ; preds = %do.body61
  br label %do.cond69

do.cond69:                                        ; preds = %if.end68
  br label %do.end70

do.end70:                                         ; preds = %do.cond69
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup71

cleanup71:                                        ; preds = %do.end70, %if.then67
  call void @llvm.lifetime.end.p0(i64 16, ptr %r57) #10
  %cleanup.dest72 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest72, label %cleanup76 [
    i32 0, label %cleanup.cont73
  ]

cleanup.cont73:                                   ; preds = %cleanup71
  br label %for.inc74

for.inc74:                                        ; preds = %cleanup.cont73
  %13 = load i64, ptr %i52, align 8, !tbaa !11
  %inc75 = add i64 %13, 1
  store i64 %inc75, ptr %i52, align 8, !tbaa !11
  br label %for.cond53

cleanup76:                                        ; preds = %cleanup71, %for.cond.cleanup55
  call void @llvm.lifetime.end.p0(i64 8, ptr %i52) #10
  %cleanup.dest77 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest77, label %cleanup133 [
    i32 7, label %for.end78
  ]

for.end78:                                        ; preds = %cleanup76
  call void @llvm.lifetime.start.p0(i64 8, ptr %i79) #10
  store i64 4, ptr %i79, align 8, !tbaa !11
  br label %for.cond80

for.cond80:                                       ; preds = %for.inc101, %for.end78
  %14 = load i64, ptr %i79, align 8, !tbaa !11
  %cmp81 = icmp ult i64 %14, 6
  br i1 %cmp81, label %for.body83, label %for.cond.cleanup82

for.cond.cleanup82:                               ; preds = %for.cond80
  store i32 12, ptr %cleanup.dest.slot, align 4
  br label %cleanup103

for.body83:                                       ; preds = %for.cond80
  call void @llvm.lifetime.start.p0(i64 16, ptr %r84) #10
  %15 = load i64, ptr %i79, align 8, !tbaa !11
  %arrayidx85 = getelementptr inbounds [8 x %struct.anon.56], ptr %test_vec, i64 0, i64 %15
  %a86 = getelementptr inbounds %struct.anon.56, ptr %arrayidx85, i32 0, i32 0
  %16 = load <2 x double>, ptr %a86, align 16, !tbaa !16
  %call87 = call <2 x double> @simde_mm_round_pd(<2 x double> noundef %16, i32 noundef 2)
  store <2 x double> %call87, ptr %r84, align 16, !tbaa !16
  br label %do.body88

do.body88:                                        ; preds = %for.body83
  %17 = load <2 x double>, ptr %r84, align 16, !tbaa !16
  %18 = load i64, ptr %i79, align 8, !tbaa !11
  %arrayidx89 = getelementptr inbounds [8 x %struct.anon.56], ptr %test_vec, i64 0, i64 %18
  %r90 = getelementptr inbounds %struct.anon.56, ptr %arrayidx89, i32 0, i32 2
  %19 = load <2 x double>, ptr %r90, align 16, !tbaa !16
  %call91 = call double @simde_test_f64_precision_to_slop(i32 noundef 1)
  %call92 = call i32 @simde_test_x86_assert_equal_f64x2_(<2 x double> noundef %17, <2 x double> noundef %19, double noundef %call91, ptr noundef @.str.72, i32 noundef 2905, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool93 = icmp ne i32 %call92, 0
  br i1 %tobool93, label %if.then94, label %if.end95

if.then94:                                        ; preds = %do.body88
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup98

if.end95:                                         ; preds = %do.body88
  br label %do.cond96

do.cond96:                                        ; preds = %if.end95
  br label %do.end97

do.end97:                                         ; preds = %do.cond96
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup98

cleanup98:                                        ; preds = %do.end97, %if.then94
  call void @llvm.lifetime.end.p0(i64 16, ptr %r84) #10
  %cleanup.dest99 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest99, label %cleanup103 [
    i32 0, label %cleanup.cont100
  ]

cleanup.cont100:                                  ; preds = %cleanup98
  br label %for.inc101

for.inc101:                                       ; preds = %cleanup.cont100
  %20 = load i64, ptr %i79, align 8, !tbaa !11
  %inc102 = add i64 %20, 1
  store i64 %inc102, ptr %i79, align 8, !tbaa !11
  br label %for.cond80

cleanup103:                                       ; preds = %cleanup98, %for.cond.cleanup82
  call void @llvm.lifetime.end.p0(i64 8, ptr %i79) #10
  %cleanup.dest104 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest104, label %cleanup133 [
    i32 12, label %for.end105
  ]

for.end105:                                       ; preds = %cleanup103
  call void @llvm.lifetime.start.p0(i64 8, ptr %i106) #10
  store i64 6, ptr %i106, align 8, !tbaa !11
  br label %for.cond107

for.cond107:                                      ; preds = %for.inc128, %for.end105
  %21 = load i64, ptr %i106, align 8, !tbaa !11
  %cmp108 = icmp ult i64 %21, 8
  br i1 %cmp108, label %for.body110, label %for.cond.cleanup109

for.cond.cleanup109:                              ; preds = %for.cond107
  store i32 17, ptr %cleanup.dest.slot, align 4
  br label %cleanup130

for.body110:                                      ; preds = %for.cond107
  call void @llvm.lifetime.start.p0(i64 16, ptr %r111) #10
  %22 = load i64, ptr %i106, align 8, !tbaa !11
  %arrayidx112 = getelementptr inbounds [8 x %struct.anon.56], ptr %test_vec, i64 0, i64 %22
  %a113 = getelementptr inbounds %struct.anon.56, ptr %arrayidx112, i32 0, i32 0
  %23 = load <2 x double>, ptr %a113, align 16, !tbaa !16
  %call114 = call <2 x double> @simde_mm_round_pd(<2 x double> noundef %23, i32 noundef 3)
  store <2 x double> %call114, ptr %r111, align 16, !tbaa !16
  br label %do.body115

do.body115:                                       ; preds = %for.body110
  %24 = load <2 x double>, ptr %r111, align 16, !tbaa !16
  %25 = load i64, ptr %i106, align 8, !tbaa !11
  %arrayidx116 = getelementptr inbounds [8 x %struct.anon.56], ptr %test_vec, i64 0, i64 %25
  %r117 = getelementptr inbounds %struct.anon.56, ptr %arrayidx116, i32 0, i32 2
  %26 = load <2 x double>, ptr %r117, align 16, !tbaa !16
  %call118 = call double @simde_test_f64_precision_to_slop(i32 noundef 1)
  %call119 = call i32 @simde_test_x86_assert_equal_f64x2_(<2 x double> noundef %24, <2 x double> noundef %26, double noundef %call118, ptr noundef @.str.72, i32 noundef 2909, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool120 = icmp ne i32 %call119, 0
  br i1 %tobool120, label %if.then121, label %if.end122

if.then121:                                       ; preds = %do.body115
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup125

if.end122:                                        ; preds = %do.body115
  br label %do.cond123

do.cond123:                                       ; preds = %if.end122
  br label %do.end124

do.end124:                                        ; preds = %do.cond123
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup125

cleanup125:                                       ; preds = %do.end124, %if.then121
  call void @llvm.lifetime.end.p0(i64 16, ptr %r111) #10
  %cleanup.dest126 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest126, label %cleanup130 [
    i32 0, label %cleanup.cont127
  ]

cleanup.cont127:                                  ; preds = %cleanup125
  br label %for.inc128

for.inc128:                                       ; preds = %cleanup.cont127
  %27 = load i64, ptr %i106, align 8, !tbaa !11
  %inc129 = add i64 %27, 1
  store i64 %inc129, ptr %i106, align 8, !tbaa !11
  br label %for.cond107

cleanup130:                                       ; preds = %cleanup125, %for.cond.cleanup109
  call void @llvm.lifetime.end.p0(i64 8, ptr %i106) #10
  %cleanup.dest131 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest131, label %cleanup133 [
    i32 17, label %for.end132
  ]

for.end132:                                       ; preds = %cleanup130
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup133

cleanup133:                                       ; preds = %for.end132, %cleanup130, %cleanup103, %cleanup76, %cleanup50
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %28 = load i32, ptr %retval, align 4
  ret i32 %28
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_round_ps() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.57], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r43 = alloca <4 x float>, align 16
  %i52 = alloca i64, align 8
  %r57 = alloca <4 x float>, align 16
  %i79 = alloca i64, align 8
  %r84 = alloca <4 x float>, align 16
  %i106 = alloca i64, align 8
  %r111 = alloca <4 x float>, align 16
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.57], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.57, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <4 x float> @simde_mm_set_ps(float noundef 0x406926B860000000, float noundef 0xC08E655C20000000, float noundef 0xC08B82F5C0000000, float noundef 0x405F833340000000)
  store <4 x float> %call, ptr %a, align 16, !tbaa !16
  %rounding = getelementptr inbounds %struct.anon.57, ptr %arrayinit.begin, i32 0, i32 1
  store i32 0, ptr %rounding, align 16, !tbaa !23
  %r = getelementptr inbounds %struct.anon.57, ptr %arrayinit.begin, i32 0, i32 2
  %call1 = call <4 x float> @simde_mm_set_ps(float noundef 2.010000e+02, float noundef -9.730000e+02, float noundef -8.800000e+02, float noundef 1.260000e+02)
  store <4 x float> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.57, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <4 x float> @simde_mm_set_ps(float noundef 0xC0753F0A40000000, float noundef 0x4054466660000000, float noundef 0x4084C4E140000000, float noundef 0x4069F7AE20000000)
  store <4 x float> %call3, ptr %a2, align 16, !tbaa !16
  %rounding4 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element, i32 0, i32 1
  store i32 0, ptr %rounding4, align 16, !tbaa !23
  %r5 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element, i32 0, i32 2
  %call6 = call <4 x float> @simde_mm_set_ps(float noundef -3.400000e+02, float noundef 8.100000e+01, float noundef 6.650000e+02, float noundef 2.080000e+02)
  store <4 x float> %call6, ptr %r5, align 16, !tbaa !16
  %arrayinit.element7 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element, i64 1
  %a8 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element7, i32 0, i32 0
  %call9 = call <4 x float> @simde_mm_set_ps(float noundef 0xC07DCBD700000000, float noundef 0x4074070A40000000, float noundef 0xC056766660000000, float noundef 0xC0809CCCC0000000)
  store <4 x float> %call9, ptr %a8, align 16, !tbaa !16
  %rounding10 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element7, i32 0, i32 1
  store i32 1, ptr %rounding10, align 16, !tbaa !23
  %r11 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element7, i32 0, i32 2
  %call12 = call <4 x float> @simde_mm_set_ps(float noundef -4.770000e+02, float noundef 3.200000e+02, float noundef -9.000000e+01, float noundef -5.320000e+02)
  store <4 x float> %call12, ptr %r11, align 16, !tbaa !16
  %arrayinit.element13 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element7, i64 1
  %a14 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element13, i32 0, i32 0
  %call15 = call <4 x float> @simde_mm_set_ps(float noundef 0xC089128F60000000, float noundef 0xC077DD47A0000000, float noundef 0xC0873FAE20000000, float noundef -1.800000e+02)
  store <4 x float> %call15, ptr %a14, align 16, !tbaa !16
  %rounding16 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element13, i32 0, i32 1
  store i32 1, ptr %rounding16, align 16, !tbaa !23
  %r17 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element13, i32 0, i32 2
  %call18 = call <4 x float> @simde_mm_set_ps(float noundef -8.030000e+02, float noundef -3.820000e+02, float noundef -7.440000e+02, float noundef -1.800000e+02)
  store <4 x float> %call18, ptr %r17, align 16, !tbaa !16
  %arrayinit.element19 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element13, i64 1
  %a20 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element19, i32 0, i32 0
  %call21 = call <4 x float> @simde_mm_set_ps(float noundef 0x406CF2E140000000, float noundef 0x40854B47A0000000, float noundef 0x40818F99A0000000, float noundef 0xC082B2B860000000)
  store <4 x float> %call21, ptr %a20, align 16, !tbaa !16
  %rounding22 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element19, i32 0, i32 1
  store i32 2, ptr %rounding22, align 16, !tbaa !23
  %r23 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element19, i32 0, i32 2
  %call24 = call <4 x float> @simde_mm_set_ps(float noundef 2.320000e+02, float noundef 6.820000e+02, float noundef 5.620000e+02, float noundef -5.980000e+02)
  store <4 x float> %call24, ptr %r23, align 16, !tbaa !16
  %arrayinit.element25 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element19, i64 1
  %a26 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element25, i32 0, i32 0
  %call27 = call <4 x float> @simde_mm_set_ps(float noundef 0xC07B873340000000, float noundef 0x407572E140000000, float noundef 0x40562A3D80000000, float noundef 0xC058A28F60000000)
  store <4 x float> %call27, ptr %a26, align 16, !tbaa !16
  %rounding28 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element25, i32 0, i32 1
  store i32 2, ptr %rounding28, align 16, !tbaa !23
  %r29 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element25, i32 0, i32 2
  %call30 = call <4 x float> @simde_mm_set_ps(float noundef -4.400000e+02, float noundef 3.440000e+02, float noundef 8.900000e+01, float noundef -9.800000e+01)
  store <4 x float> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element25, i64 1
  %a32 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <4 x float> @simde_mm_set_ps(float noundef 0xC0601BD700000000, float noundef 0xC08175C280000000, float noundef 0x408B0547A0000000, float noundef 0xC082018520000000)
  store <4 x float> %call33, ptr %a32, align 16, !tbaa !16
  %rounding34 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element31, i32 0, i32 1
  store i32 3, ptr %rounding34, align 16, !tbaa !23
  %r35 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element31, i32 0, i32 2
  %call36 = call <4 x float> @simde_mm_set_ps(float noundef -1.280000e+02, float noundef -5.580000e+02, float noundef 8.640000e+02, float noundef -5.760000e+02)
  store <4 x float> %call36, ptr %r35, align 16, !tbaa !16
  %arrayinit.element37 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element31, i64 1
  %a38 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <4 x float> @simde_mm_set_ps(float noundef 0x4084ED8520000000, float noundef 9.025000e+02, float noundef 0xC07DF6B860000000, float noundef 0x4081AECCC0000000)
  store <4 x float> %call39, ptr %a38, align 16, !tbaa !16
  %rounding40 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element37, i32 0, i32 1
  store i32 3, ptr %rounding40, align 16, !tbaa !23
  %r41 = getelementptr inbounds %struct.anon.57, ptr %arrayinit.element37, i32 0, i32 2
  %call42 = call <4 x float> @simde_mm_set_ps(float noundef 6.690000e+02, float noundef 9.020000e+02, float noundef -4.790000e+02, float noundef 5.650000e+02)
  store <4 x float> %call42, ptr %r41, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 2
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup50

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r43) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.57], ptr %test_vec, i64 0, i64 %1
  %a44 = getelementptr inbounds %struct.anon.57, ptr %arrayidx, i32 0, i32 0
  %2 = load <4 x float>, ptr %a44, align 16, !tbaa !16
  %call45 = call <4 x float> @simde_x_mm_round_ps(<4 x float> noundef %2, i32 noundef 0, i32 noundef 0)
  store <4 x float> %call45, ptr %r43, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <4 x float>, ptr %r43, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx46 = getelementptr inbounds [8 x %struct.anon.57], ptr %test_vec, i64 0, i64 %4
  %r47 = getelementptr inbounds %struct.anon.57, ptr %arrayidx46, i32 0, i32 2
  %5 = load <4 x float>, ptr %r47, align 16, !tbaa !16
  %call48 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call49 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %3, <4 x float> noundef %5, float noundef %call48, ptr noundef @.str.72, i32 noundef 3142, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call49, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r43) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup50 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup50:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest51 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest51, label %cleanup133 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup50
  call void @llvm.lifetime.start.p0(i64 8, ptr %i52) #10
  store i64 2, ptr %i52, align 8, !tbaa !11
  br label %for.cond53

for.cond53:                                       ; preds = %for.inc74, %for.end
  %7 = load i64, ptr %i52, align 8, !tbaa !11
  %cmp54 = icmp ult i64 %7, 4
  br i1 %cmp54, label %for.body56, label %for.cond.cleanup55

for.cond.cleanup55:                               ; preds = %for.cond53
  store i32 7, ptr %cleanup.dest.slot, align 4
  br label %cleanup76

for.body56:                                       ; preds = %for.cond53
  call void @llvm.lifetime.start.p0(i64 16, ptr %r57) #10
  %8 = load i64, ptr %i52, align 8, !tbaa !11
  %arrayidx58 = getelementptr inbounds [8 x %struct.anon.57], ptr %test_vec, i64 0, i64 %8
  %a59 = getelementptr inbounds %struct.anon.57, ptr %arrayidx58, i32 0, i32 0
  %9 = load <4 x float>, ptr %a59, align 16, !tbaa !16
  %call60 = call <4 x float> @simde_x_mm_round_ps(<4 x float> noundef %9, i32 noundef 1, i32 noundef 0)
  store <4 x float> %call60, ptr %r57, align 16, !tbaa !16
  br label %do.body61

do.body61:                                        ; preds = %for.body56
  %10 = load <4 x float>, ptr %r57, align 16, !tbaa !16
  %11 = load i64, ptr %i52, align 8, !tbaa !11
  %arrayidx62 = getelementptr inbounds [8 x %struct.anon.57], ptr %test_vec, i64 0, i64 %11
  %r63 = getelementptr inbounds %struct.anon.57, ptr %arrayidx62, i32 0, i32 2
  %12 = load <4 x float>, ptr %r63, align 16, !tbaa !16
  %call64 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call65 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %10, <4 x float> noundef %12, float noundef %call64, ptr noundef @.str.72, i32 noundef 3146, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool66 = icmp ne i32 %call65, 0
  br i1 %tobool66, label %if.then67, label %if.end68

if.then67:                                        ; preds = %do.body61
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup71

if.end68:                                         ; preds = %do.body61
  br label %do.cond69

do.cond69:                                        ; preds = %if.end68
  br label %do.end70

do.end70:                                         ; preds = %do.cond69
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup71

cleanup71:                                        ; preds = %do.end70, %if.then67
  call void @llvm.lifetime.end.p0(i64 16, ptr %r57) #10
  %cleanup.dest72 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest72, label %cleanup76 [
    i32 0, label %cleanup.cont73
  ]

cleanup.cont73:                                   ; preds = %cleanup71
  br label %for.inc74

for.inc74:                                        ; preds = %cleanup.cont73
  %13 = load i64, ptr %i52, align 8, !tbaa !11
  %inc75 = add i64 %13, 1
  store i64 %inc75, ptr %i52, align 8, !tbaa !11
  br label %for.cond53

cleanup76:                                        ; preds = %cleanup71, %for.cond.cleanup55
  call void @llvm.lifetime.end.p0(i64 8, ptr %i52) #10
  %cleanup.dest77 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest77, label %cleanup133 [
    i32 7, label %for.end78
  ]

for.end78:                                        ; preds = %cleanup76
  call void @llvm.lifetime.start.p0(i64 8, ptr %i79) #10
  store i64 4, ptr %i79, align 8, !tbaa !11
  br label %for.cond80

for.cond80:                                       ; preds = %for.inc101, %for.end78
  %14 = load i64, ptr %i79, align 8, !tbaa !11
  %cmp81 = icmp ult i64 %14, 6
  br i1 %cmp81, label %for.body83, label %for.cond.cleanup82

for.cond.cleanup82:                               ; preds = %for.cond80
  store i32 12, ptr %cleanup.dest.slot, align 4
  br label %cleanup103

for.body83:                                       ; preds = %for.cond80
  call void @llvm.lifetime.start.p0(i64 16, ptr %r84) #10
  %15 = load i64, ptr %i79, align 8, !tbaa !11
  %arrayidx85 = getelementptr inbounds [8 x %struct.anon.57], ptr %test_vec, i64 0, i64 %15
  %a86 = getelementptr inbounds %struct.anon.57, ptr %arrayidx85, i32 0, i32 0
  %16 = load <4 x float>, ptr %a86, align 16, !tbaa !16
  %call87 = call <4 x float> @simde_x_mm_round_ps(<4 x float> noundef %16, i32 noundef 2, i32 noundef 0)
  store <4 x float> %call87, ptr %r84, align 16, !tbaa !16
  br label %do.body88

do.body88:                                        ; preds = %for.body83
  %17 = load <4 x float>, ptr %r84, align 16, !tbaa !16
  %18 = load i64, ptr %i79, align 8, !tbaa !11
  %arrayidx89 = getelementptr inbounds [8 x %struct.anon.57], ptr %test_vec, i64 0, i64 %18
  %r90 = getelementptr inbounds %struct.anon.57, ptr %arrayidx89, i32 0, i32 2
  %19 = load <4 x float>, ptr %r90, align 16, !tbaa !16
  %call91 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call92 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %17, <4 x float> noundef %19, float noundef %call91, ptr noundef @.str.72, i32 noundef 3150, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool93 = icmp ne i32 %call92, 0
  br i1 %tobool93, label %if.then94, label %if.end95

if.then94:                                        ; preds = %do.body88
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup98

if.end95:                                         ; preds = %do.body88
  br label %do.cond96

do.cond96:                                        ; preds = %if.end95
  br label %do.end97

do.end97:                                         ; preds = %do.cond96
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup98

cleanup98:                                        ; preds = %do.end97, %if.then94
  call void @llvm.lifetime.end.p0(i64 16, ptr %r84) #10
  %cleanup.dest99 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest99, label %cleanup103 [
    i32 0, label %cleanup.cont100
  ]

cleanup.cont100:                                  ; preds = %cleanup98
  br label %for.inc101

for.inc101:                                       ; preds = %cleanup.cont100
  %20 = load i64, ptr %i79, align 8, !tbaa !11
  %inc102 = add i64 %20, 1
  store i64 %inc102, ptr %i79, align 8, !tbaa !11
  br label %for.cond80

cleanup103:                                       ; preds = %cleanup98, %for.cond.cleanup82
  call void @llvm.lifetime.end.p0(i64 8, ptr %i79) #10
  %cleanup.dest104 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest104, label %cleanup133 [
    i32 12, label %for.end105
  ]

for.end105:                                       ; preds = %cleanup103
  call void @llvm.lifetime.start.p0(i64 8, ptr %i106) #10
  store i64 6, ptr %i106, align 8, !tbaa !11
  br label %for.cond107

for.cond107:                                      ; preds = %for.inc128, %for.end105
  %21 = load i64, ptr %i106, align 8, !tbaa !11
  %cmp108 = icmp ult i64 %21, 8
  br i1 %cmp108, label %for.body110, label %for.cond.cleanup109

for.cond.cleanup109:                              ; preds = %for.cond107
  store i32 17, ptr %cleanup.dest.slot, align 4
  br label %cleanup130

for.body110:                                      ; preds = %for.cond107
  call void @llvm.lifetime.start.p0(i64 16, ptr %r111) #10
  %22 = load i64, ptr %i106, align 8, !tbaa !11
  %arrayidx112 = getelementptr inbounds [8 x %struct.anon.57], ptr %test_vec, i64 0, i64 %22
  %a113 = getelementptr inbounds %struct.anon.57, ptr %arrayidx112, i32 0, i32 0
  %23 = load <4 x float>, ptr %a113, align 16, !tbaa !16
  %call114 = call <4 x float> @simde_x_mm_round_ps(<4 x float> noundef %23, i32 noundef 3, i32 noundef 0)
  store <4 x float> %call114, ptr %r111, align 16, !tbaa !16
  br label %do.body115

do.body115:                                       ; preds = %for.body110
  %24 = load <4 x float>, ptr %r111, align 16, !tbaa !16
  %25 = load i64, ptr %i106, align 8, !tbaa !11
  %arrayidx116 = getelementptr inbounds [8 x %struct.anon.57], ptr %test_vec, i64 0, i64 %25
  %r117 = getelementptr inbounds %struct.anon.57, ptr %arrayidx116, i32 0, i32 2
  %26 = load <4 x float>, ptr %r117, align 16, !tbaa !16
  %call118 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call119 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %24, <4 x float> noundef %26, float noundef %call118, ptr noundef @.str.72, i32 noundef 3154, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool120 = icmp ne i32 %call119, 0
  br i1 %tobool120, label %if.then121, label %if.end122

if.then121:                                       ; preds = %do.body115
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup125

if.end122:                                        ; preds = %do.body115
  br label %do.cond123

do.cond123:                                       ; preds = %if.end122
  br label %do.end124

do.end124:                                        ; preds = %do.cond123
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup125

cleanup125:                                       ; preds = %do.end124, %if.then121
  call void @llvm.lifetime.end.p0(i64 16, ptr %r111) #10
  %cleanup.dest126 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest126, label %cleanup130 [
    i32 0, label %cleanup.cont127
  ]

cleanup.cont127:                                  ; preds = %cleanup125
  br label %for.inc128

for.inc128:                                       ; preds = %cleanup.cont127
  %27 = load i64, ptr %i106, align 8, !tbaa !11
  %inc129 = add i64 %27, 1
  store i64 %inc129, ptr %i106, align 8, !tbaa !11
  br label %for.cond107

cleanup130:                                       ; preds = %cleanup125, %for.cond.cleanup109
  call void @llvm.lifetime.end.p0(i64 8, ptr %i106) #10
  %cleanup.dest131 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest131, label %cleanup133 [
    i32 17, label %for.end132
  ]

for.end132:                                       ; preds = %cleanup130
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup133

cleanup133:                                       ; preds = %for.end132, %cleanup130, %cleanup103, %cleanup76, %cleanup50
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %28 = load i32, ptr %retval, align 4
  ret i32 %28
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_round_sd() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.58], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r58 = alloca <2 x double>, align 16
  %i69 = alloca i64, align 8
  %r74 = alloca <2 x double>, align 16
  %i98 = alloca i64, align 8
  %r103 = alloca <2 x double>, align 16
  %i127 = alloca i64, align 8
  %r132 = alloca <2 x double>, align 16
  call void @llvm.lifetime.start.p0(i64 512, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.58], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.58, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x double> @simde_mm_set_pd(double noundef -5.759000e+01, double noundef -9.148000e+01)
  store <2 x double> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.58, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x double> @simde_mm_set_pd(double noundef -1.140100e+02, double noundef 1.291800e+02)
  store <2 x double> %call1, ptr %b, align 16, !tbaa !16
  %rounding = getelementptr inbounds %struct.anon.58, ptr %arrayinit.begin, i32 0, i32 2
  store i32 0, ptr %rounding, align 16, !tbaa !27
  %r = getelementptr inbounds %struct.anon.58, ptr %arrayinit.begin, i32 0, i32 3
  %call2 = call <2 x double> @simde_mm_set_pd(double noundef -5.759000e+01, double noundef 1.290000e+02)
  store <2 x double> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.58, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <2 x double> @simde_mm_set_pd(double noundef 3.670200e+02, double noundef -2.287300e+02)
  store <2 x double> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <2 x double> @simde_mm_set_pd(double noundef -1.065700e+02, double noundef -2.488500e+02)
  store <2 x double> %call6, ptr %b5, align 16, !tbaa !16
  %rounding7 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element, i32 0, i32 2
  store i32 0, ptr %rounding7, align 16, !tbaa !27
  %r8 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element, i32 0, i32 3
  %call9 = call <2 x double> @simde_mm_set_pd(double noundef 3.670200e+02, double noundef -2.490000e+02)
  store <2 x double> %call9, ptr %r8, align 16, !tbaa !16
  %arrayinit.element10 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element, i64 1
  %a11 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element10, i32 0, i32 0
  %call12 = call <2 x double> @simde_mm_set_pd(double noundef 2.181900e+02, double noundef -1.210200e+02)
  store <2 x double> %call12, ptr %a11, align 16, !tbaa !16
  %b13 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element10, i32 0, i32 1
  %call14 = call <2 x double> @simde_mm_set_pd(double noundef -3.678400e+02, double noundef -4.921900e+02)
  store <2 x double> %call14, ptr %b13, align 16, !tbaa !16
  %rounding15 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element10, i32 0, i32 2
  store i32 1, ptr %rounding15, align 16, !tbaa !27
  %r16 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element10, i32 0, i32 3
  %call17 = call <2 x double> @simde_mm_set_pd(double noundef 2.181900e+02, double noundef -4.930000e+02)
  store <2 x double> %call17, ptr %r16, align 16, !tbaa !16
  %arrayinit.element18 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element10, i64 1
  %a19 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element18, i32 0, i32 0
  %call20 = call <2 x double> @simde_mm_set_pd(double noundef 7.062600e+02, double noundef 7.108500e+02)
  store <2 x double> %call20, ptr %a19, align 16, !tbaa !16
  %b21 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element18, i32 0, i32 1
  %call22 = call <2 x double> @simde_mm_set_pd(double noundef -3.911700e+02, double noundef -8.344400e+02)
  store <2 x double> %call22, ptr %b21, align 16, !tbaa !16
  %rounding23 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element18, i32 0, i32 2
  store i32 1, ptr %rounding23, align 16, !tbaa !27
  %r24 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element18, i32 0, i32 3
  %call25 = call <2 x double> @simde_mm_set_pd(double noundef 7.062600e+02, double noundef -8.350000e+02)
  store <2 x double> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element18, i64 1
  %a27 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <2 x double> @simde_mm_set_pd(double noundef 0xC088873333333333, double noundef -8.107300e+02)
  store <2 x double> %call28, ptr %a27, align 16, !tbaa !16
  %b29 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <2 x double> @simde_mm_set_pd(double noundef -5.544400e+02, double noundef -4.636000e+02)
  store <2 x double> %call30, ptr %b29, align 16, !tbaa !16
  %rounding31 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element26, i32 0, i32 2
  store i32 2, ptr %rounding31, align 16, !tbaa !27
  %r32 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element26, i32 0, i32 3
  %call33 = call <2 x double> @simde_mm_set_pd(double noundef 0xC088873333333333, double noundef -4.630000e+02)
  store <2 x double> %call33, ptr %r32, align 16, !tbaa !16
  %arrayinit.element34 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element26, i64 1
  %a35 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element34, i32 0, i32 0
  %call36 = call <2 x double> @simde_mm_set_pd(double noundef -9.978300e+02, double noundef 6.910000e+00)
  store <2 x double> %call36, ptr %a35, align 16, !tbaa !16
  %b37 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element34, i32 0, i32 1
  %call38 = call <2 x double> @simde_mm_set_pd(double noundef -5.124000e+01, double noundef -8.010900e+02)
  store <2 x double> %call38, ptr %b37, align 16, !tbaa !16
  %rounding39 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element34, i32 0, i32 2
  store i32 2, ptr %rounding39, align 16, !tbaa !27
  %r40 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element34, i32 0, i32 3
  %call41 = call <2 x double> @simde_mm_set_pd(double noundef -9.978300e+02, double noundef -8.010000e+02)
  store <2 x double> %call41, ptr %r40, align 16, !tbaa !16
  %arrayinit.element42 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element34, i64 1
  %a43 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element42, i32 0, i32 0
  %call44 = call <2 x double> @simde_mm_set_pd(double noundef -2.375300e+02, double noundef 2.158200e+02)
  store <2 x double> %call44, ptr %a43, align 16, !tbaa !16
  %b45 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element42, i32 0, i32 1
  %call46 = call <2 x double> @simde_mm_set_pd(double noundef -3.383200e+02, double noundef -2.890000e+02)
  store <2 x double> %call46, ptr %b45, align 16, !tbaa !16
  %rounding47 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element42, i32 0, i32 2
  store i32 3, ptr %rounding47, align 16, !tbaa !27
  %r48 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element42, i32 0, i32 3
  %call49 = call <2 x double> @simde_mm_set_pd(double noundef -2.375300e+02, double noundef -2.890000e+02)
  store <2 x double> %call49, ptr %r48, align 16, !tbaa !16
  %arrayinit.element50 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element42, i64 1
  %a51 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element50, i32 0, i32 0
  %call52 = call <2 x double> @simde_mm_set_pd(double noundef 9.643700e+02, double noundef -3.040300e+02)
  store <2 x double> %call52, ptr %a51, align 16, !tbaa !16
  %b53 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element50, i32 0, i32 1
  %call54 = call <2 x double> @simde_mm_set_pd(double noundef 2.371400e+02, double noundef 0x40836947AE147AE1)
  store <2 x double> %call54, ptr %b53, align 16, !tbaa !16
  %rounding55 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element50, i32 0, i32 2
  store i32 3, ptr %rounding55, align 16, !tbaa !27
  %r56 = getelementptr inbounds %struct.anon.58, ptr %arrayinit.element50, i32 0, i32 3
  %call57 = call <2 x double> @simde_mm_set_pd(double noundef 9.643700e+02, double noundef 6.210000e+02)
  store <2 x double> %call57, ptr %r56, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 2
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup67

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r58) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.58], ptr %test_vec, i64 0, i64 %1
  %a59 = getelementptr inbounds %struct.anon.58, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x double>, ptr %a59, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx60 = getelementptr inbounds [8 x %struct.anon.58], ptr %test_vec, i64 0, i64 %3
  %b61 = getelementptr inbounds %struct.anon.58, ptr %arrayidx60, i32 0, i32 1
  %4 = load <2 x double>, ptr %b61, align 16, !tbaa !16
  %call62 = call <2 x double> @simde_mm_round_sd(<2 x double> noundef %2, <2 x double> noundef %4, i32 noundef 0)
  store <2 x double> %call62, ptr %r58, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <2 x double>, ptr %r58, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx63 = getelementptr inbounds [8 x %struct.anon.58], ptr %test_vec, i64 0, i64 %6
  %r64 = getelementptr inbounds %struct.anon.58, ptr %arrayidx63, i32 0, i32 3
  %7 = load <2 x double>, ptr %r64, align 16, !tbaa !16
  %call65 = call double @simde_test_f64_precision_to_slop(i32 noundef 1)
  %call66 = call i32 @simde_test_x86_assert_equal_f64x2_(<2 x double> noundef %5, <2 x double> noundef %7, double noundef %call65, ptr noundef @.str.72, i32 noundef 3204, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call66, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r58) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup67 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup67:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest68 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest68, label %cleanup156 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup67
  call void @llvm.lifetime.start.p0(i64 8, ptr %i69) #10
  store i64 2, ptr %i69, align 8, !tbaa !11
  br label %for.cond70

for.cond70:                                       ; preds = %for.inc93, %for.end
  %9 = load i64, ptr %i69, align 8, !tbaa !11
  %cmp71 = icmp ult i64 %9, 4
  br i1 %cmp71, label %for.body73, label %for.cond.cleanup72

for.cond.cleanup72:                               ; preds = %for.cond70
  store i32 7, ptr %cleanup.dest.slot, align 4
  br label %cleanup95

for.body73:                                       ; preds = %for.cond70
  call void @llvm.lifetime.start.p0(i64 16, ptr %r74) #10
  %10 = load i64, ptr %i69, align 8, !tbaa !11
  %arrayidx75 = getelementptr inbounds [8 x %struct.anon.58], ptr %test_vec, i64 0, i64 %10
  %a76 = getelementptr inbounds %struct.anon.58, ptr %arrayidx75, i32 0, i32 0
  %11 = load <2 x double>, ptr %a76, align 16, !tbaa !16
  %12 = load i64, ptr %i69, align 8, !tbaa !11
  %arrayidx77 = getelementptr inbounds [8 x %struct.anon.58], ptr %test_vec, i64 0, i64 %12
  %b78 = getelementptr inbounds %struct.anon.58, ptr %arrayidx77, i32 0, i32 1
  %13 = load <2 x double>, ptr %b78, align 16, !tbaa !16
  %call79 = call <2 x double> @simde_mm_round_sd(<2 x double> noundef %11, <2 x double> noundef %13, i32 noundef 1)
  store <2 x double> %call79, ptr %r74, align 16, !tbaa !16
  br label %do.body80

do.body80:                                        ; preds = %for.body73
  %14 = load <2 x double>, ptr %r74, align 16, !tbaa !16
  %15 = load i64, ptr %i69, align 8, !tbaa !11
  %arrayidx81 = getelementptr inbounds [8 x %struct.anon.58], ptr %test_vec, i64 0, i64 %15
  %r82 = getelementptr inbounds %struct.anon.58, ptr %arrayidx81, i32 0, i32 3
  %16 = load <2 x double>, ptr %r82, align 16, !tbaa !16
  %call83 = call double @simde_test_f64_precision_to_slop(i32 noundef 1)
  %call84 = call i32 @simde_test_x86_assert_equal_f64x2_(<2 x double> noundef %14, <2 x double> noundef %16, double noundef %call83, ptr noundef @.str.72, i32 noundef 3208, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool85 = icmp ne i32 %call84, 0
  br i1 %tobool85, label %if.then86, label %if.end87

if.then86:                                        ; preds = %do.body80
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup90

if.end87:                                         ; preds = %do.body80
  br label %do.cond88

do.cond88:                                        ; preds = %if.end87
  br label %do.end89

do.end89:                                         ; preds = %do.cond88
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup90

cleanup90:                                        ; preds = %do.end89, %if.then86
  call void @llvm.lifetime.end.p0(i64 16, ptr %r74) #10
  %cleanup.dest91 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest91, label %cleanup95 [
    i32 0, label %cleanup.cont92
  ]

cleanup.cont92:                                   ; preds = %cleanup90
  br label %for.inc93

for.inc93:                                        ; preds = %cleanup.cont92
  %17 = load i64, ptr %i69, align 8, !tbaa !11
  %inc94 = add i64 %17, 1
  store i64 %inc94, ptr %i69, align 8, !tbaa !11
  br label %for.cond70

cleanup95:                                        ; preds = %cleanup90, %for.cond.cleanup72
  call void @llvm.lifetime.end.p0(i64 8, ptr %i69) #10
  %cleanup.dest96 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest96, label %cleanup156 [
    i32 7, label %for.end97
  ]

for.end97:                                        ; preds = %cleanup95
  call void @llvm.lifetime.start.p0(i64 8, ptr %i98) #10
  store i64 4, ptr %i98, align 8, !tbaa !11
  br label %for.cond99

for.cond99:                                       ; preds = %for.inc122, %for.end97
  %18 = load i64, ptr %i98, align 8, !tbaa !11
  %cmp100 = icmp ult i64 %18, 6
  br i1 %cmp100, label %for.body102, label %for.cond.cleanup101

for.cond.cleanup101:                              ; preds = %for.cond99
  store i32 12, ptr %cleanup.dest.slot, align 4
  br label %cleanup124

for.body102:                                      ; preds = %for.cond99
  call void @llvm.lifetime.start.p0(i64 16, ptr %r103) #10
  %19 = load i64, ptr %i98, align 8, !tbaa !11
  %arrayidx104 = getelementptr inbounds [8 x %struct.anon.58], ptr %test_vec, i64 0, i64 %19
  %a105 = getelementptr inbounds %struct.anon.58, ptr %arrayidx104, i32 0, i32 0
  %20 = load <2 x double>, ptr %a105, align 16, !tbaa !16
  %21 = load i64, ptr %i98, align 8, !tbaa !11
  %arrayidx106 = getelementptr inbounds [8 x %struct.anon.58], ptr %test_vec, i64 0, i64 %21
  %b107 = getelementptr inbounds %struct.anon.58, ptr %arrayidx106, i32 0, i32 1
  %22 = load <2 x double>, ptr %b107, align 16, !tbaa !16
  %call108 = call <2 x double> @simde_mm_round_sd(<2 x double> noundef %20, <2 x double> noundef %22, i32 noundef 2)
  store <2 x double> %call108, ptr %r103, align 16, !tbaa !16
  br label %do.body109

do.body109:                                       ; preds = %for.body102
  %23 = load <2 x double>, ptr %r103, align 16, !tbaa !16
  %24 = load i64, ptr %i98, align 8, !tbaa !11
  %arrayidx110 = getelementptr inbounds [8 x %struct.anon.58], ptr %test_vec, i64 0, i64 %24
  %r111 = getelementptr inbounds %struct.anon.58, ptr %arrayidx110, i32 0, i32 3
  %25 = load <2 x double>, ptr %r111, align 16, !tbaa !16
  %call112 = call double @simde_test_f64_precision_to_slop(i32 noundef 1)
  %call113 = call i32 @simde_test_x86_assert_equal_f64x2_(<2 x double> noundef %23, <2 x double> noundef %25, double noundef %call112, ptr noundef @.str.72, i32 noundef 3212, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool114 = icmp ne i32 %call113, 0
  br i1 %tobool114, label %if.then115, label %if.end116

if.then115:                                       ; preds = %do.body109
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup119

if.end116:                                        ; preds = %do.body109
  br label %do.cond117

do.cond117:                                       ; preds = %if.end116
  br label %do.end118

do.end118:                                        ; preds = %do.cond117
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup119

cleanup119:                                       ; preds = %do.end118, %if.then115
  call void @llvm.lifetime.end.p0(i64 16, ptr %r103) #10
  %cleanup.dest120 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest120, label %cleanup124 [
    i32 0, label %cleanup.cont121
  ]

cleanup.cont121:                                  ; preds = %cleanup119
  br label %for.inc122

for.inc122:                                       ; preds = %cleanup.cont121
  %26 = load i64, ptr %i98, align 8, !tbaa !11
  %inc123 = add i64 %26, 1
  store i64 %inc123, ptr %i98, align 8, !tbaa !11
  br label %for.cond99

cleanup124:                                       ; preds = %cleanup119, %for.cond.cleanup101
  call void @llvm.lifetime.end.p0(i64 8, ptr %i98) #10
  %cleanup.dest125 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest125, label %cleanup156 [
    i32 12, label %for.end126
  ]

for.end126:                                       ; preds = %cleanup124
  call void @llvm.lifetime.start.p0(i64 8, ptr %i127) #10
  store i64 6, ptr %i127, align 8, !tbaa !11
  br label %for.cond128

for.cond128:                                      ; preds = %for.inc151, %for.end126
  %27 = load i64, ptr %i127, align 8, !tbaa !11
  %cmp129 = icmp ult i64 %27, 8
  br i1 %cmp129, label %for.body131, label %for.cond.cleanup130

for.cond.cleanup130:                              ; preds = %for.cond128
  store i32 17, ptr %cleanup.dest.slot, align 4
  br label %cleanup153

for.body131:                                      ; preds = %for.cond128
  call void @llvm.lifetime.start.p0(i64 16, ptr %r132) #10
  %28 = load i64, ptr %i127, align 8, !tbaa !11
  %arrayidx133 = getelementptr inbounds [8 x %struct.anon.58], ptr %test_vec, i64 0, i64 %28
  %a134 = getelementptr inbounds %struct.anon.58, ptr %arrayidx133, i32 0, i32 0
  %29 = load <2 x double>, ptr %a134, align 16, !tbaa !16
  %30 = load i64, ptr %i127, align 8, !tbaa !11
  %arrayidx135 = getelementptr inbounds [8 x %struct.anon.58], ptr %test_vec, i64 0, i64 %30
  %b136 = getelementptr inbounds %struct.anon.58, ptr %arrayidx135, i32 0, i32 1
  %31 = load <2 x double>, ptr %b136, align 16, !tbaa !16
  %call137 = call <2 x double> @simde_mm_round_sd(<2 x double> noundef %29, <2 x double> noundef %31, i32 noundef 3)
  store <2 x double> %call137, ptr %r132, align 16, !tbaa !16
  br label %do.body138

do.body138:                                       ; preds = %for.body131
  %32 = load <2 x double>, ptr %r132, align 16, !tbaa !16
  %33 = load i64, ptr %i127, align 8, !tbaa !11
  %arrayidx139 = getelementptr inbounds [8 x %struct.anon.58], ptr %test_vec, i64 0, i64 %33
  %r140 = getelementptr inbounds %struct.anon.58, ptr %arrayidx139, i32 0, i32 3
  %34 = load <2 x double>, ptr %r140, align 16, !tbaa !16
  %call141 = call double @simde_test_f64_precision_to_slop(i32 noundef 1)
  %call142 = call i32 @simde_test_x86_assert_equal_f64x2_(<2 x double> noundef %32, <2 x double> noundef %34, double noundef %call141, ptr noundef @.str.72, i32 noundef 3216, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool143 = icmp ne i32 %call142, 0
  br i1 %tobool143, label %if.then144, label %if.end145

if.then144:                                       ; preds = %do.body138
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup148

if.end145:                                        ; preds = %do.body138
  br label %do.cond146

do.cond146:                                       ; preds = %if.end145
  br label %do.end147

do.end147:                                        ; preds = %do.cond146
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup148

cleanup148:                                       ; preds = %do.end147, %if.then144
  call void @llvm.lifetime.end.p0(i64 16, ptr %r132) #10
  %cleanup.dest149 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest149, label %cleanup153 [
    i32 0, label %cleanup.cont150
  ]

cleanup.cont150:                                  ; preds = %cleanup148
  br label %for.inc151

for.inc151:                                       ; preds = %cleanup.cont150
  %35 = load i64, ptr %i127, align 8, !tbaa !11
  %inc152 = add i64 %35, 1
  store i64 %inc152, ptr %i127, align 8, !tbaa !11
  br label %for.cond128

cleanup153:                                       ; preds = %cleanup148, %for.cond.cleanup130
  call void @llvm.lifetime.end.p0(i64 8, ptr %i127) #10
  %cleanup.dest154 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest154, label %cleanup156 [
    i32 17, label %for.end155
  ]

for.end155:                                       ; preds = %cleanup153
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup156

cleanup156:                                       ; preds = %for.end155, %cleanup153, %cleanup124, %cleanup95, %cleanup67
  call void @llvm.lifetime.end.p0(i64 512, ptr %test_vec) #10
  %36 = load i32, ptr %retval, align 4
  ret i32 %36
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_round_ss() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.59], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r58 = alloca <4 x float>, align 16
  %i69 = alloca i64, align 8
  %r74 = alloca <4 x float>, align 16
  %i98 = alloca i64, align 8
  %r103 = alloca <4 x float>, align 16
  %i127 = alloca i64, align 8
  %r132 = alloca <4 x float>, align 16
  call void @llvm.lifetime.start.p0(i64 512, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.59], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.59, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <4 x float> @simde_mm_set_ps(float noundef 0xC08E18F5C0000000, float noundef 0xC083F7AE20000000, float noundef -8.557500e+02, float noundef 0x4088ABEB80000000)
  store <4 x float> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.59, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <4 x float> @simde_mm_set_ps(float noundef 0x408E4E8F60000000, float noundef 0x402CB851E0000000, float noundef 0x404E2A3D80000000, float noundef 0xC084D4E140000000)
  store <4 x float> %call1, ptr %b, align 16, !tbaa !16
  %rounding = getelementptr inbounds %struct.anon.59, ptr %arrayinit.begin, i32 0, i32 2
  store i32 0, ptr %rounding, align 16, !tbaa !27
  %r = getelementptr inbounds %struct.anon.59, ptr %arrayinit.begin, i32 0, i32 3
  %call2 = call <4 x float> @simde_mm_set_ps(float noundef 0xC08E18F5C0000000, float noundef 0xC083F7AE20000000, float noundef -8.557500e+02, float noundef -6.670000e+02)
  store <4 x float> %call2, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.59, ptr %arrayinit.begin, i64 1
  %a3 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element, i32 0, i32 0
  %call4 = call <4 x float> @simde_mm_set_ps(float noundef 0xC04AB999A0000000, float noundef 0x4078D947A0000000, float noundef 0x40782A3D80000000, float noundef 7.790000e+02)
  store <4 x float> %call4, ptr %a3, align 16, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element, i32 0, i32 1
  %call6 = call <4 x float> @simde_mm_set_ps(float noundef 0x407F1D47A0000000, float noundef 0xC0848ACCC0000000, float noundef 0xC086410A40000000, float noundef 0x4082C75C20000000)
  store <4 x float> %call6, ptr %b5, align 16, !tbaa !16
  %rounding7 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element, i32 0, i32 2
  store i32 0, ptr %rounding7, align 16, !tbaa !27
  %r8 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element, i32 0, i32 3
  %call9 = call <4 x float> @simde_mm_set_ps(float noundef 0xC04AB999A0000000, float noundef 0x4078D947A0000000, float noundef 0x40782A3D80000000, float noundef 6.010000e+02)
  store <4 x float> %call9, ptr %r8, align 16, !tbaa !16
  %arrayinit.element10 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element, i64 1
  %a11 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element10, i32 0, i32 0
  %call12 = call <4 x float> @simde_mm_set_ps(float noundef 0xC0807D8520000000, float noundef 0xC07E778520000000, float noundef 0xC04A1D70A0000000, float noundef 0x4032B5C280000000)
  store <4 x float> %call12, ptr %a11, align 16, !tbaa !16
  %b13 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element10, i32 0, i32 1
  %call14 = call <4 x float> @simde_mm_set_ps(float noundef 0xC08C87AE20000000, float noundef 0x408C0B3340000000, float noundef 0xC08B4CB860000000, float noundef 0x404A170A40000000)
  store <4 x float> %call14, ptr %b13, align 16, !tbaa !16
  %rounding15 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element10, i32 0, i32 2
  store i32 1, ptr %rounding15, align 16, !tbaa !27
  %r16 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element10, i32 0, i32 3
  %call17 = call <4 x float> @simde_mm_set_ps(float noundef 0xC0807D8520000000, float noundef 0xC07E778520000000, float noundef 0xC04A1D70A0000000, float noundef 5.200000e+01)
  store <4 x float> %call17, ptr %r16, align 16, !tbaa !16
  %arrayinit.element18 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element10, i64 1
  %a19 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element18, i32 0, i32 0
  %call20 = call <4 x float> @simde_mm_set_ps(float noundef 0x408ACBD700000000, float noundef 0xC08A8E8F60000000, float noundef 0x408E58B860000000, float noundef 0xC08D090A40000000)
  store <4 x float> %call20, ptr %a19, align 16, !tbaa !16
  %b21 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element18, i32 0, i32 1
  %call22 = call <4 x float> @simde_mm_set_ps(float noundef 0x408B3851E0000000, float noundef 0x4071C5C280000000, float noundef 0x40818E8F60000000, float noundef 0xC06255C280000000)
  store <4 x float> %call22, ptr %b21, align 16, !tbaa !16
  %rounding23 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element18, i32 0, i32 2
  store i32 1, ptr %rounding23, align 16, !tbaa !27
  %r24 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element18, i32 0, i32 3
  %call25 = call <4 x float> @simde_mm_set_ps(float noundef 0x408ACBD700000000, float noundef 0xC08A8E8F60000000, float noundef 0x408E58B860000000, float noundef -1.470000e+02)
  store <4 x float> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element18, i64 1
  %a27 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <4 x float> @simde_mm_set_ps(float noundef 0xC08ADE7AE0000000, float noundef 0xC05A78F5C0000000, float noundef 0xC0329999A0000000, float noundef 0xC06AD2E140000000)
  store <4 x float> %call28, ptr %a27, align 16, !tbaa !16
  %b29 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <4 x float> @simde_mm_set_ps(float noundef 0xC076878520000000, float noundef 0x407D82E140000000, float noundef 0x408E07EB80000000, float noundef 0xC078C87AE0000000)
  store <4 x float> %call30, ptr %b29, align 16, !tbaa !16
  %rounding31 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element26, i32 0, i32 2
  store i32 2, ptr %rounding31, align 16, !tbaa !27
  %r32 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element26, i32 0, i32 3
  %call33 = call <4 x float> @simde_mm_set_ps(float noundef 0xC08ADE7AE0000000, float noundef 0xC05A78F5C0000000, float noundef 0xC0329999A0000000, float noundef -3.960000e+02)
  store <4 x float> %call33, ptr %r32, align 16, !tbaa !16
  %arrayinit.element34 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element26, i64 1
  %a35 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element34, i32 0, i32 0
  %call36 = call <4 x float> @simde_mm_set_ps(float noundef 0xC0848E8F60000000, float noundef 0xC08CD22900000000, float noundef 0xC06040F5C0000000, float noundef 8.777500e+02)
  store <4 x float> %call36, ptr %a35, align 16, !tbaa !16
  %b37 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element34, i32 0, i32 1
  %call38 = call <4 x float> @simde_mm_set_ps(float noundef 0xC079D999A0000000, float noundef 0x4089C58520000000, float noundef 0x405F2E1480000000, float noundef 0x40738570A0000000)
  store <4 x float> %call38, ptr %b37, align 16, !tbaa !16
  %rounding39 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element34, i32 0, i32 2
  store i32 2, ptr %rounding39, align 16, !tbaa !27
  %r40 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element34, i32 0, i32 3
  %call41 = call <4 x float> @simde_mm_set_ps(float noundef 0xC0848E8F60000000, float noundef 0xC08CD22900000000, float noundef 0xC06040F5C0000000, float noundef 3.130000e+02)
  store <4 x float> %call41, ptr %r40, align 16, !tbaa !16
  %arrayinit.element42 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element34, i64 1
  %a43 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element42, i32 0, i32 0
  %call44 = call <4 x float> @simde_mm_set_ps(float noundef 0xC083E35C20000000, float noundef 0xC08E958520000000, float noundef 0x40889DD700000000, float noundef 0xC0860AA3E0000000)
  store <4 x float> %call44, ptr %a43, align 16, !tbaa !16
  %b45 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element42, i32 0, i32 1
  %call46 = call <4 x float> @simde_mm_set_ps(float noundef 0xC0667199A0000000, float noundef 0x407870F5C0000000, float noundef 0xC0892D0A40000000, float noundef 0x4089F8CCC0000000)
  store <4 x float> %call46, ptr %b45, align 16, !tbaa !16
  %rounding47 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element42, i32 0, i32 2
  store i32 3, ptr %rounding47, align 16, !tbaa !27
  %r48 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element42, i32 0, i32 3
  %call49 = call <4 x float> @simde_mm_set_ps(float noundef 0xC083E35C20000000, float noundef 0xC08E958520000000, float noundef 0x40889DD700000000, float noundef 8.310000e+02)
  store <4 x float> %call49, ptr %r48, align 16, !tbaa !16
  %arrayinit.element50 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element42, i64 1
  %a51 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element50, i32 0, i32 0
  %call52 = call <4 x float> @simde_mm_set_ps(float noundef 0x408088A3E0000000, float noundef -6.650000e+02, float noundef 0x4088910A40000000, float noundef 0x408A58E140000000)
  store <4 x float> %call52, ptr %a51, align 16, !tbaa !16
  %b53 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element50, i32 0, i32 1
  %call54 = call <4 x float> @simde_mm_set_ps(float noundef 0xC0727EE140000000, float noundef 0xC0629CCCC0000000, float noundef 0x407E3199A0000000, float noundef 0xC088B08F60000000)
  store <4 x float> %call54, ptr %b53, align 16, !tbaa !16
  %rounding55 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element50, i32 0, i32 2
  store i32 3, ptr %rounding55, align 16, !tbaa !27
  %r56 = getelementptr inbounds %struct.anon.59, ptr %arrayinit.element50, i32 0, i32 3
  %call57 = call <4 x float> @simde_mm_set_ps(float noundef 0x408088A3E0000000, float noundef -6.650000e+02, float noundef 0x4088910A40000000, float noundef -7.900000e+02)
  store <4 x float> %call57, ptr %r56, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 2
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup67

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r58) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.59], ptr %test_vec, i64 0, i64 %1
  %a59 = getelementptr inbounds %struct.anon.59, ptr %arrayidx, i32 0, i32 0
  %2 = load <4 x float>, ptr %a59, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx60 = getelementptr inbounds [8 x %struct.anon.59], ptr %test_vec, i64 0, i64 %3
  %b61 = getelementptr inbounds %struct.anon.59, ptr %arrayidx60, i32 0, i32 1
  %4 = load <4 x float>, ptr %b61, align 16, !tbaa !16
  %call62 = call <4 x float> @simde_mm_round_ss(<4 x float> noundef %2, <4 x float> noundef %4, i32 noundef 0)
  store <4 x float> %call62, ptr %r58, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load <4 x float>, ptr %r58, align 16, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx63 = getelementptr inbounds [8 x %struct.anon.59], ptr %test_vec, i64 0, i64 %6
  %r64 = getelementptr inbounds %struct.anon.59, ptr %arrayidx63, i32 0, i32 3
  %7 = load <4 x float>, ptr %r64, align 16, !tbaa !16
  %call65 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call66 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %5, <4 x float> noundef %7, float noundef %call65, ptr noundef @.str.72, i32 noundef 3266, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call66, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r58) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup67 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup67:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest68 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest68, label %cleanup156 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup67
  call void @llvm.lifetime.start.p0(i64 8, ptr %i69) #10
  store i64 2, ptr %i69, align 8, !tbaa !11
  br label %for.cond70

for.cond70:                                       ; preds = %for.inc93, %for.end
  %9 = load i64, ptr %i69, align 8, !tbaa !11
  %cmp71 = icmp ult i64 %9, 4
  br i1 %cmp71, label %for.body73, label %for.cond.cleanup72

for.cond.cleanup72:                               ; preds = %for.cond70
  store i32 7, ptr %cleanup.dest.slot, align 4
  br label %cleanup95

for.body73:                                       ; preds = %for.cond70
  call void @llvm.lifetime.start.p0(i64 16, ptr %r74) #10
  %10 = load i64, ptr %i69, align 8, !tbaa !11
  %arrayidx75 = getelementptr inbounds [8 x %struct.anon.59], ptr %test_vec, i64 0, i64 %10
  %a76 = getelementptr inbounds %struct.anon.59, ptr %arrayidx75, i32 0, i32 0
  %11 = load <4 x float>, ptr %a76, align 16, !tbaa !16
  %12 = load i64, ptr %i69, align 8, !tbaa !11
  %arrayidx77 = getelementptr inbounds [8 x %struct.anon.59], ptr %test_vec, i64 0, i64 %12
  %b78 = getelementptr inbounds %struct.anon.59, ptr %arrayidx77, i32 0, i32 1
  %13 = load <4 x float>, ptr %b78, align 16, !tbaa !16
  %call79 = call <4 x float> @simde_mm_round_ss(<4 x float> noundef %11, <4 x float> noundef %13, i32 noundef 1)
  store <4 x float> %call79, ptr %r74, align 16, !tbaa !16
  br label %do.body80

do.body80:                                        ; preds = %for.body73
  %14 = load <4 x float>, ptr %r74, align 16, !tbaa !16
  %15 = load i64, ptr %i69, align 8, !tbaa !11
  %arrayidx81 = getelementptr inbounds [8 x %struct.anon.59], ptr %test_vec, i64 0, i64 %15
  %r82 = getelementptr inbounds %struct.anon.59, ptr %arrayidx81, i32 0, i32 3
  %16 = load <4 x float>, ptr %r82, align 16, !tbaa !16
  %call83 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call84 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %14, <4 x float> noundef %16, float noundef %call83, ptr noundef @.str.72, i32 noundef 3270, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool85 = icmp ne i32 %call84, 0
  br i1 %tobool85, label %if.then86, label %if.end87

if.then86:                                        ; preds = %do.body80
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup90

if.end87:                                         ; preds = %do.body80
  br label %do.cond88

do.cond88:                                        ; preds = %if.end87
  br label %do.end89

do.end89:                                         ; preds = %do.cond88
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup90

cleanup90:                                        ; preds = %do.end89, %if.then86
  call void @llvm.lifetime.end.p0(i64 16, ptr %r74) #10
  %cleanup.dest91 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest91, label %cleanup95 [
    i32 0, label %cleanup.cont92
  ]

cleanup.cont92:                                   ; preds = %cleanup90
  br label %for.inc93

for.inc93:                                        ; preds = %cleanup.cont92
  %17 = load i64, ptr %i69, align 8, !tbaa !11
  %inc94 = add i64 %17, 1
  store i64 %inc94, ptr %i69, align 8, !tbaa !11
  br label %for.cond70

cleanup95:                                        ; preds = %cleanup90, %for.cond.cleanup72
  call void @llvm.lifetime.end.p0(i64 8, ptr %i69) #10
  %cleanup.dest96 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest96, label %cleanup156 [
    i32 7, label %for.end97
  ]

for.end97:                                        ; preds = %cleanup95
  call void @llvm.lifetime.start.p0(i64 8, ptr %i98) #10
  store i64 4, ptr %i98, align 8, !tbaa !11
  br label %for.cond99

for.cond99:                                       ; preds = %for.inc122, %for.end97
  %18 = load i64, ptr %i98, align 8, !tbaa !11
  %cmp100 = icmp ult i64 %18, 6
  br i1 %cmp100, label %for.body102, label %for.cond.cleanup101

for.cond.cleanup101:                              ; preds = %for.cond99
  store i32 12, ptr %cleanup.dest.slot, align 4
  br label %cleanup124

for.body102:                                      ; preds = %for.cond99
  call void @llvm.lifetime.start.p0(i64 16, ptr %r103) #10
  %19 = load i64, ptr %i98, align 8, !tbaa !11
  %arrayidx104 = getelementptr inbounds [8 x %struct.anon.59], ptr %test_vec, i64 0, i64 %19
  %a105 = getelementptr inbounds %struct.anon.59, ptr %arrayidx104, i32 0, i32 0
  %20 = load <4 x float>, ptr %a105, align 16, !tbaa !16
  %21 = load i64, ptr %i98, align 8, !tbaa !11
  %arrayidx106 = getelementptr inbounds [8 x %struct.anon.59], ptr %test_vec, i64 0, i64 %21
  %b107 = getelementptr inbounds %struct.anon.59, ptr %arrayidx106, i32 0, i32 1
  %22 = load <4 x float>, ptr %b107, align 16, !tbaa !16
  %call108 = call <4 x float> @simde_mm_round_ss(<4 x float> noundef %20, <4 x float> noundef %22, i32 noundef 2)
  store <4 x float> %call108, ptr %r103, align 16, !tbaa !16
  br label %do.body109

do.body109:                                       ; preds = %for.body102
  %23 = load <4 x float>, ptr %r103, align 16, !tbaa !16
  %24 = load i64, ptr %i98, align 8, !tbaa !11
  %arrayidx110 = getelementptr inbounds [8 x %struct.anon.59], ptr %test_vec, i64 0, i64 %24
  %r111 = getelementptr inbounds %struct.anon.59, ptr %arrayidx110, i32 0, i32 3
  %25 = load <4 x float>, ptr %r111, align 16, !tbaa !16
  %call112 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call113 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %23, <4 x float> noundef %25, float noundef %call112, ptr noundef @.str.72, i32 noundef 3274, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool114 = icmp ne i32 %call113, 0
  br i1 %tobool114, label %if.then115, label %if.end116

if.then115:                                       ; preds = %do.body109
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup119

if.end116:                                        ; preds = %do.body109
  br label %do.cond117

do.cond117:                                       ; preds = %if.end116
  br label %do.end118

do.end118:                                        ; preds = %do.cond117
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup119

cleanup119:                                       ; preds = %do.end118, %if.then115
  call void @llvm.lifetime.end.p0(i64 16, ptr %r103) #10
  %cleanup.dest120 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest120, label %cleanup124 [
    i32 0, label %cleanup.cont121
  ]

cleanup.cont121:                                  ; preds = %cleanup119
  br label %for.inc122

for.inc122:                                       ; preds = %cleanup.cont121
  %26 = load i64, ptr %i98, align 8, !tbaa !11
  %inc123 = add i64 %26, 1
  store i64 %inc123, ptr %i98, align 8, !tbaa !11
  br label %for.cond99

cleanup124:                                       ; preds = %cleanup119, %for.cond.cleanup101
  call void @llvm.lifetime.end.p0(i64 8, ptr %i98) #10
  %cleanup.dest125 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest125, label %cleanup156 [
    i32 12, label %for.end126
  ]

for.end126:                                       ; preds = %cleanup124
  call void @llvm.lifetime.start.p0(i64 8, ptr %i127) #10
  store i64 6, ptr %i127, align 8, !tbaa !11
  br label %for.cond128

for.cond128:                                      ; preds = %for.inc151, %for.end126
  %27 = load i64, ptr %i127, align 8, !tbaa !11
  %cmp129 = icmp ult i64 %27, 8
  br i1 %cmp129, label %for.body131, label %for.cond.cleanup130

for.cond.cleanup130:                              ; preds = %for.cond128
  store i32 17, ptr %cleanup.dest.slot, align 4
  br label %cleanup153

for.body131:                                      ; preds = %for.cond128
  call void @llvm.lifetime.start.p0(i64 16, ptr %r132) #10
  %28 = load i64, ptr %i127, align 8, !tbaa !11
  %arrayidx133 = getelementptr inbounds [8 x %struct.anon.59], ptr %test_vec, i64 0, i64 %28
  %a134 = getelementptr inbounds %struct.anon.59, ptr %arrayidx133, i32 0, i32 0
  %29 = load <4 x float>, ptr %a134, align 16, !tbaa !16
  %30 = load i64, ptr %i127, align 8, !tbaa !11
  %arrayidx135 = getelementptr inbounds [8 x %struct.anon.59], ptr %test_vec, i64 0, i64 %30
  %b136 = getelementptr inbounds %struct.anon.59, ptr %arrayidx135, i32 0, i32 1
  %31 = load <4 x float>, ptr %b136, align 16, !tbaa !16
  %call137 = call <4 x float> @simde_mm_round_ss(<4 x float> noundef %29, <4 x float> noundef %31, i32 noundef 3)
  store <4 x float> %call137, ptr %r132, align 16, !tbaa !16
  br label %do.body138

do.body138:                                       ; preds = %for.body131
  %32 = load <4 x float>, ptr %r132, align 16, !tbaa !16
  %33 = load i64, ptr %i127, align 8, !tbaa !11
  %arrayidx139 = getelementptr inbounds [8 x %struct.anon.59], ptr %test_vec, i64 0, i64 %33
  %r140 = getelementptr inbounds %struct.anon.59, ptr %arrayidx139, i32 0, i32 3
  %34 = load <4 x float>, ptr %r140, align 16, !tbaa !16
  %call141 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call142 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %32, <4 x float> noundef %34, float noundef %call141, ptr noundef @.str.72, i32 noundef 3278, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool143 = icmp ne i32 %call142, 0
  br i1 %tobool143, label %if.then144, label %if.end145

if.then144:                                       ; preds = %do.body138
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup148

if.end145:                                        ; preds = %do.body138
  br label %do.cond146

do.cond146:                                       ; preds = %if.end145
  br label %do.end147

do.end147:                                        ; preds = %do.cond146
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup148

cleanup148:                                       ; preds = %do.end147, %if.then144
  call void @llvm.lifetime.end.p0(i64 16, ptr %r132) #10
  %cleanup.dest149 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest149, label %cleanup153 [
    i32 0, label %cleanup.cont150
  ]

cleanup.cont150:                                  ; preds = %cleanup148
  br label %for.inc151

for.inc151:                                       ; preds = %cleanup.cont150
  %35 = load i64, ptr %i127, align 8, !tbaa !11
  %inc152 = add i64 %35, 1
  store i64 %inc152, ptr %i127, align 8, !tbaa !11
  br label %for.cond128

cleanup153:                                       ; preds = %cleanup148, %for.cond.cleanup130
  call void @llvm.lifetime.end.p0(i64 8, ptr %i127) #10
  %cleanup.dest154 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest154, label %cleanup156 [
    i32 17, label %for.end155
  ]

for.end155:                                       ; preds = %cleanup153
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup156

cleanup156:                                       ; preds = %for.end155, %cleanup153, %cleanup124, %cleanup95, %cleanup67
  call void @llvm.lifetime.end.p0(i64 512, ptr %test_vec) #10
  %36 = load i32, ptr %retval, align 4
  ret i32 %36
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_round_ps_nearest() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <4 x float>, align 16
  %r = alloca <4 x float>, align 16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup10

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %a) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.60], ptr @test_simde_mm_round_ps_nearest.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.60, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [4 x float], ptr %a1, i64 0, i64 0
  %call = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay)
  store <4 x float> %call, ptr %a, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #10
  %2 = load <4 x float>, ptr %a, align 16, !tbaa !16
  %call2 = call <4 x float> @simde_x_mm_round_ps(<4 x float> noundef %2, i32 noundef 0, i32 noundef 0)
  store <4 x float> %call2, ptr %r, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <4 x float>, ptr %r, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx3 = getelementptr inbounds [8 x %struct.anon.60], ptr @test_simde_mm_round_ps_nearest.test_vec, i64 0, i64 %4
  %r4 = getelementptr inbounds %struct.anon.60, ptr %arrayidx3, i32 0, i32 1
  %arraydecay5 = getelementptr inbounds [4 x float], ptr %r4, i64 0, i64 0
  %call6 = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay5)
  %call7 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call8 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %3, <4 x float> noundef %call6, float noundef %call7, ptr noundef @.str.72, i32 noundef 2943, ptr noundef @.str.73, ptr noundef @.str.93)
  %tobool = icmp ne i32 %call8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup10 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %5, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup10:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest11 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest11, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup10
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup10
  %6 = load i32, ptr %retval, align 4
  ret i32 %6

unreachable:                                      ; preds = %cleanup10
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_round_ps_ninf() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <4 x float>, align 16
  %r = alloca <4 x float>, align 16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup10

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %a) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.61], ptr @test_simde_mm_round_ps_ninf.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.61, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [4 x float], ptr %a1, i64 0, i64 0
  %call = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay)
  store <4 x float> %call, ptr %a, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #10
  %2 = load <4 x float>, ptr %a, align 16, !tbaa !16
  %call2 = call <4 x float> @simde_x_mm_round_ps(<4 x float> noundef %2, i32 noundef 1, i32 noundef 0)
  store <4 x float> %call2, ptr %r, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <4 x float>, ptr %r, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx3 = getelementptr inbounds [8 x %struct.anon.61], ptr @test_simde_mm_round_ps_ninf.test_vec, i64 0, i64 %4
  %r4 = getelementptr inbounds %struct.anon.61, ptr %arrayidx3, i32 0, i32 1
  %arraydecay5 = getelementptr inbounds [4 x float], ptr %r4, i64 0, i64 0
  %call6 = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay5)
  %call7 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call8 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %3, <4 x float> noundef %call6, float noundef %call7, ptr noundef @.str.72, i32 noundef 2991, ptr noundef @.str.73, ptr noundef @.str.93)
  %tobool = icmp ne i32 %call8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup10 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %5, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup10:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest11 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest11, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup10
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup10
  %6 = load i32, ptr %retval, align 4
  ret i32 %6

unreachable:                                      ; preds = %cleanup10
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_round_ps_pinf() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <4 x float>, align 16
  %r = alloca <4 x float>, align 16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup10

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %a) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.62], ptr @test_simde_mm_round_ps_pinf.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.62, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [4 x float], ptr %a1, i64 0, i64 0
  %call = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay)
  store <4 x float> %call, ptr %a, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #10
  %2 = load <4 x float>, ptr %a, align 16, !tbaa !16
  %call2 = call <4 x float> @simde_x_mm_round_ps(<4 x float> noundef %2, i32 noundef 2, i32 noundef 0)
  store <4 x float> %call2, ptr %r, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <4 x float>, ptr %r, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx3 = getelementptr inbounds [8 x %struct.anon.62], ptr @test_simde_mm_round_ps_pinf.test_vec, i64 0, i64 %4
  %r4 = getelementptr inbounds %struct.anon.62, ptr %arrayidx3, i32 0, i32 1
  %arraydecay5 = getelementptr inbounds [4 x float], ptr %r4, i64 0, i64 0
  %call6 = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay5)
  %call7 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call8 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %3, <4 x float> noundef %call6, float noundef %call7, ptr noundef @.str.72, i32 noundef 3039, ptr noundef @.str.73, ptr noundef @.str.93)
  %tobool = icmp ne i32 %call8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup10 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %5, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup10:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest11 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest11, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup10
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup10
  %6 = load i32, ptr %retval, align 4
  ret i32 %6

unreachable:                                      ; preds = %cleanup10
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_round_ps_zero() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <4 x float>, align 16
  %r = alloca <4 x float>, align 16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup10

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %a) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.63], ptr @test_simde_mm_round_ps_zero.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.63, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [4 x float], ptr %a1, i64 0, i64 0
  %call = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay)
  store <4 x float> %call, ptr %a, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #10
  %2 = load <4 x float>, ptr %a, align 16, !tbaa !16
  %call2 = call <4 x float> @simde_x_mm_round_ps(<4 x float> noundef %2, i32 noundef 3, i32 noundef 0)
  store <4 x float> %call2, ptr %r, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load <4 x float>, ptr %r, align 16, !tbaa !16
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx3 = getelementptr inbounds [8 x %struct.anon.63], ptr @test_simde_mm_round_ps_zero.test_vec, i64 0, i64 %4
  %r4 = getelementptr inbounds %struct.anon.63, ptr %arrayidx3, i32 0, i32 1
  %arraydecay5 = getelementptr inbounds [4 x float], ptr %r4, i64 0, i64 0
  %call6 = call <4 x float> @simde_mm_loadu_ps(ptr noundef %arraydecay5)
  %call7 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  %call8 = call i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %3, <4 x float> noundef %call6, float noundef %call7, ptr noundef @.str.72, i32 noundef 3087, ptr noundef @.str.73, ptr noundef @.str.93)
  %tobool = icmp ne i32 %call8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup10 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %5, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup10:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest11 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest11, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup10
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup10
  %6 = load i32, ptr %retval, align 4
  ret i32 %6

unreachable:                                      ; preds = %cleanup10
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_stream_load_si128() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.64], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r36 = alloca <2 x i64>, align 16
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.64], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.64, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_mm_set_epi32(i32 noundef -547904967, i32 noundef -1362990942, i32 noundef 2066137598, i32 noundef -1778922116)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.64, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -547904967, i32 noundef -1362990942, i32 noundef 2066137598, i32 noundef -1778922116)
  store <2 x i64> %call1, ptr %r, align 16, !tbaa !16
  %arrayinit.element = getelementptr inbounds %struct.anon.64, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -2087163583, i32 noundef 2115433203, i32 noundef -1978815624, i32 noundef 1025228414)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %r4 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -2087163583, i32 noundef 2115433203, i32 noundef -1978815624, i32 noundef 1025228414)
  store <2 x i64> %call5, ptr %r4, align 16, !tbaa !16
  %arrayinit.element6 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element, i64 1
  %a7 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element6, i32 0, i32 0
  %call8 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1244490055, i32 noundef 1943548537, i32 noundef 589236062, i32 noundef -751161899)
  store <2 x i64> %call8, ptr %a7, align 16, !tbaa !16
  %r9 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element6, i32 0, i32 1
  %call10 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1244490055, i32 noundef 1943548537, i32 noundef 589236062, i32 noundef -751161899)
  store <2 x i64> %call10, ptr %r9, align 16, !tbaa !16
  %arrayinit.element11 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element6, i64 1
  %a12 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element11, i32 0, i32 0
  %call13 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1274215918, i32 noundef -1858225286, i32 noundef -472727069, i32 noundef 528679049)
  store <2 x i64> %call13, ptr %a12, align 16, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element11, i32 0, i32 1
  %call15 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1274215918, i32 noundef -1858225286, i32 noundef -472727069, i32 noundef 528679049)
  store <2 x i64> %call15, ptr %r14, align 16, !tbaa !16
  %arrayinit.element16 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element11, i64 1
  %a17 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1568552575, i32 noundef 411221897, i32 noundef -1334506552, i32 noundef 1554165859)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element16, i32 0, i32 1
  %call20 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1568552575, i32 noundef 411221897, i32 noundef -1334506552, i32 noundef 1554165859)
  store <2 x i64> %call20, ptr %r19, align 16, !tbaa !16
  %arrayinit.element21 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element16, i64 1
  %a22 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element21, i32 0, i32 0
  %call23 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1044144940, i32 noundef -1916851863, i32 noundef -589120926, i32 noundef 651795910)
  store <2 x i64> %call23, ptr %a22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element21, i32 0, i32 1
  %call25 = call <2 x i64> @simde_mm_set_epi32(i32 noundef 1044144940, i32 noundef -1916851863, i32 noundef -589120926, i32 noundef 651795910)
  store <2 x i64> %call25, ptr %r24, align 16, !tbaa !16
  %arrayinit.element26 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element21, i64 1
  %a27 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element26, i32 0, i32 0
  %call28 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -25575503, i32 noundef -1782121708, i32 noundef 751836326, i32 noundef 1005598033)
  store <2 x i64> %call28, ptr %a27, align 16, !tbaa !16
  %r29 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element26, i32 0, i32 1
  %call30 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -25575503, i32 noundef -1782121708, i32 noundef 751836326, i32 noundef 1005598033)
  store <2 x i64> %call30, ptr %r29, align 16, !tbaa !16
  %arrayinit.element31 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element26, i64 1
  %a32 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1873195901, i32 noundef -450900536, i32 noundef 904584108, i32 noundef 251416593)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %r34 = getelementptr inbounds %struct.anon.64, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_mm_set_epi32(i32 noundef -1873195901, i32 noundef -450900536, i32 noundef 904584108, i32 noundef 251416593)
  store <2 x i64> %call35, ptr %r34, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup42

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 16, ptr %r36) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.64], ptr %test_vec, i64 0, i64 %1
  %a37 = getelementptr inbounds %struct.anon.64, ptr %arrayidx, i32 0, i32 0
  %call38 = call <2 x i64> @simde_mm_stream_load_si128(ptr noundef %a37)
  store <2 x i64> %call38, ptr %r36, align 16, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %2 = load <2 x i64>, ptr %r36, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx39 = getelementptr inbounds [8 x %struct.anon.64], ptr %test_vec, i64 0, i64 %3
  %r40 = getelementptr inbounds %struct.anon.64, ptr %arrayidx39, i32 0, i32 1
  %4 = load <2 x i64>, ptr %r40, align 16, !tbaa !16
  %call41 = call i32 @simde_test_x86_assert_equal_i32x4_(<2 x i64> noundef %2, <2 x i64> noundef %4, ptr noundef @.str.72, i32 noundef 3314, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call41, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 16, ptr %r36) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup42 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %5, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup42:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest43 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest43, label %cleanup44 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup42
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup44

cleanup44:                                        ; preds = %for.end, %cleanup42
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_test_all_ones() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.65], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r28 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 256, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.65], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.65, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1, i32 noundef 1993838502, i32 noundef 1216384299, i32 noundef -1810646012)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.65, ptr %arrayinit.begin, i32 0, i32 1
  store i32 0, ptr %r, align 16, !tbaa !19
  %arrayinit.element = getelementptr inbounds %struct.anon.65, ptr %arrayinit.begin, i64 1
  %a1 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element, i32 0, i32 0
  %call2 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 708002161, i32 noundef -1, i32 noundef 1641125312, i32 noundef 1784735378)
  store <2 x i64> %call2, ptr %a1, align 16, !tbaa !16
  %r3 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element, i32 0, i32 1
  store i32 0, ptr %r3, align 16, !tbaa !19
  %arrayinit.element4 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element, i64 1
  %a5 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element4, i32 0, i32 0
  %call6 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1141573322, i32 noundef -995006247, i32 noundef -1, i32 noundef 256198680)
  store <2 x i64> %call6, ptr %a5, align 16, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element4, i32 0, i32 1
  store i32 0, ptr %r7, align 16, !tbaa !19
  %arrayinit.element8 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element4, i64 1
  %a9 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element8, i32 0, i32 0
  %call10 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1075676209, i32 noundef -1299681650, i32 noundef -941698209, i32 noundef -1)
  store <2 x i64> %call10, ptr %a9, align 16, !tbaa !16
  %r11 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element8, i32 0, i32 1
  store i32 0, ptr %r11, align 16, !tbaa !19
  %arrayinit.element12 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element8, i64 1
  %a13 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element12, i32 0, i32 0
  %call14 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1, i32 noundef 1590943288, i32 noundef -31951757, i32 noundef 1245312939)
  store <2 x i64> %call14, ptr %a13, align 16, !tbaa !16
  %r15 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element12, i32 0, i32 1
  store i32 0, ptr %r15, align 16, !tbaa !19
  %arrayinit.element16 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element12, i64 1
  %a17 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element16, i32 0, i32 0
  %call18 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1, i32 noundef -1, i32 noundef 453365074, i32 noundef 94225678)
  store <2 x i64> %call18, ptr %a17, align 16, !tbaa !16
  %r19 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element16, i32 0, i32 1
  store i32 0, ptr %r19, align 16, !tbaa !19
  %arrayinit.element20 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element16, i64 1
  %a21 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element20, i32 0, i32 0
  %call22 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1, i32 noundef -1, i32 noundef -1, i32 noundef -940813553)
  store <2 x i64> %call22, ptr %a21, align 16, !tbaa !16
  %r23 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element20, i32 0, i32 1
  store i32 0, ptr %r23, align 16, !tbaa !19
  %arrayinit.element24 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element20, i64 1
  %a25 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element24, i32 0, i32 0
  %call26 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1, i32 noundef -1, i32 noundef -1, i32 noundef -1)
  store <2 x i64> %call26, ptr %a25, align 16, !tbaa !16
  %r27 = getelementptr inbounds %struct.anon.65, ptr %arrayinit.element24, i32 0, i32 1
  store i32 1, ptr %r27, align 16, !tbaa !19
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup34

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 4, ptr %r28) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.65], ptr %test_vec, i64 0, i64 %1
  %a29 = getelementptr inbounds %struct.anon.65, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a29, align 16, !tbaa !16
  %call30 = call i32 @simde_mm_test_all_ones(<2 x i64> noundef %2)
  store i32 %call30, ptr %r28, align 4, !tbaa !5
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load i32, ptr %r28, align 4, !tbaa !5
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx31 = getelementptr inbounds [8 x %struct.anon.65], ptr %test_vec, i64 0, i64 %4
  %r32 = getelementptr inbounds %struct.anon.65, ptr %arrayidx31, i32 0, i32 1
  %5 = load i32, ptr %r32, align 16, !tbaa !19
  %call33 = call i32 @simde_assert_equal_i_(i32 noundef %3, i32 noundef %5, ptr noundef @.str.72, i32 noundef 3346, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call33, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %r28) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup34 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %6, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup34:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest35 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest35, label %cleanup36 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup34
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup36

cleanup36:                                        ; preds = %for.end, %cleanup34
  call void @llvm.lifetime.end.p0(i64 256, ptr %test_vec) #10
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_test_all_zeros() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [13 x %struct.anon.66], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r73 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 624, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [13 x %struct.anon.66], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.66, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1201894317, i32 noundef -1975735409, i32 noundef 1402528928, i32 noundef -607639262)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.66, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1967137742, i32 noundef 1472851836, i32 noundef -2113358429, i32 noundef 1889365185)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.66, ptr %arrayinit.begin, i32 0, i32 2
  store i32 0, ptr %r, align 16, !tbaa !29
  %arrayinit.element = getelementptr inbounds %struct.anon.66, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 2135448036, i32 noundef 1619848109, i32 noundef -2005127380, i32 noundef -770982649)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %b4 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 2046676780, i32 noundef 1214034345, i32 noundef 106141409, i32 noundef -75751313)
  store <2 x i64> %call5, ptr %b4, align 16, !tbaa !16
  %r6 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element, i32 0, i32 2
  store i32 0, ptr %r6, align 16, !tbaa !29
  %arrayinit.element7 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element, i64 1
  %a8 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element7, i32 0, i32 0
  %call9 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 657893603, i32 noundef -1024098599, i32 noundef 1314977284, i32 noundef -1750457345)
  store <2 x i64> %call9, ptr %a8, align 16, !tbaa !16
  %b10 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element7, i32 0, i32 1
  %call11 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1870654968, i32 noundef 687898658, i32 noundef -1869936270, i32 noundef 672223232)
  store <2 x i64> %call11, ptr %b10, align 16, !tbaa !16
  %r12 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element7, i32 0, i32 2
  store i32 1, ptr %r12, align 16, !tbaa !29
  %arrayinit.element13 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element7, i64 1
  %a14 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element13, i32 0, i32 0
  %call15 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -757326553, i32 noundef 372152333, i32 noundef -161732482, i32 noundef 396143667)
  store <2 x i64> %call15, ptr %a14, align 16, !tbaa !16
  %b16 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element13, i32 0, i32 1
  %call17 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 671105736, i32 noundef -385873936, i32 noundef 8553473, i32 noundef 541283144)
  store <2 x i64> %call17, ptr %b16, align 16, !tbaa !16
  %r18 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element13, i32 0, i32 2
  store i32 1, ptr %r18, align 16, !tbaa !29
  %arrayinit.element19 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element13, i64 1
  %a20 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element19, i32 0, i32 0
  %call21 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -2112388755, i32 noundef -230540243, i32 noundef -1692451788, i32 noundef -245732075)
  store <2 x i64> %call21, ptr %a20, align 16, !tbaa !16
  %b22 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element19, i32 0, i32 1
  %call23 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 203975314, i32 noundef 227393856, i32 noundef 536871690, i32 noundef 75760138)
  store <2 x i64> %call23, ptr %b22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element19, i32 0, i32 2
  store i32 1, ptr %r24, align 16, !tbaa !29
  %arrayinit.element25 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element19, i64 1
  %a26 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element25, i32 0, i32 0
  %call27 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 152354605, i32 noundef -2118692382, i32 noundef -1283888292, i32 noundef -447177729)
  store <2 x i64> %call27, ptr %a26, align 16, !tbaa !16
  %b28 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element25, i32 0, i32 1
  %call29 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1562291537, i32 noundef 354162251, i32 noundef 1134881489, i32 noundef -1338074611)
  store <2 x i64> %call29, ptr %b28, align 16, !tbaa !16
  %r30 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element25, i32 0, i32 2
  store i32 0, ptr %r30, align 16, !tbaa !29
  %arrayinit.element31 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element25, i64 1
  %a32 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 2096532328, i32 noundef 1165454747, i32 noundef -1019256700, i32 noundef 1593733565)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %b34 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1988174269, i32 noundef 1339821769, i32 noundef 1810810088, i32 noundef 840755548)
  store <2 x i64> %call35, ptr %b34, align 16, !tbaa !16
  %r36 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element31, i32 0, i32 2
  store i32 0, ptr %r36, align 16, !tbaa !29
  %arrayinit.element37 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element31, i64 1
  %a38 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -706133672, i32 noundef 610042197, i32 noundef 1310204993, i32 noundef 1509811379)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 571869223, i32 noundef 1235317762, i32 noundef 29362474, i32 noundef 570561100)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element37, i32 0, i32 2
  store i32 1, ptr %r42, align 16, !tbaa !29
  %arrayinit.element43 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element37, i64 1
  %a44 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element43, i32 0, i32 0
  %call45 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 0, i32 noundef 0, i32 noundef -1, i32 noundef 0)
  store <2 x i64> %call45, ptr %a44, align 16, !tbaa !16
  %b46 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element43, i32 0, i32 1
  %call47 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1, i32 noundef -1, i32 noundef -1, i32 noundef -1)
  store <2 x i64> %call47, ptr %b46, align 16, !tbaa !16
  %r48 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element43, i32 0, i32 2
  store i32 0, ptr %r48, align 16, !tbaa !29
  %arrayinit.element49 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element43, i64 1
  %a50 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element49, i32 0, i32 0
  %call51 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 0, i32 noundef 0, i32 noundef -1, i32 noundef -1)
  store <2 x i64> %call51, ptr %a50, align 16, !tbaa !16
  %b52 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element49, i32 0, i32 1
  %call53 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1, i32 noundef -1, i32 noundef -1, i32 noundef -1)
  store <2 x i64> %call53, ptr %b52, align 16, !tbaa !16
  %r54 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element49, i32 0, i32 2
  store i32 0, ptr %r54, align 16, !tbaa !29
  %arrayinit.element55 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element49, i64 1
  %a56 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element55, i32 0, i32 0
  %call57 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1, i32 noundef -1, i32 noundef 0, i32 noundef 0)
  store <2 x i64> %call57, ptr %a56, align 16, !tbaa !16
  %b58 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element55, i32 0, i32 1
  %call59 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1, i32 noundef -1, i32 noundef -1, i32 noundef -1)
  store <2 x i64> %call59, ptr %b58, align 16, !tbaa !16
  %r60 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element55, i32 0, i32 2
  store i32 0, ptr %r60, align 16, !tbaa !29
  %arrayinit.element61 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element55, i64 1
  %a62 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element61, i32 0, i32 0
  %call63 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef -1)
  store <2 x i64> %call63, ptr %a62, align 16, !tbaa !16
  %b64 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element61, i32 0, i32 1
  %call65 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1, i32 noundef -1, i32 noundef -1, i32 noundef -1)
  store <2 x i64> %call65, ptr %b64, align 16, !tbaa !16
  %r66 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element61, i32 0, i32 2
  store i32 0, ptr %r66, align 16, !tbaa !29
  %arrayinit.element67 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element61, i64 1
  %a68 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element67, i32 0, i32 0
  %call69 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 0, i32 noundef -1, i32 noundef 0, i32 noundef 0)
  store <2 x i64> %call69, ptr %a68, align 16, !tbaa !16
  %b70 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element67, i32 0, i32 1
  %call71 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1, i32 noundef -1, i32 noundef -1, i32 noundef -1)
  store <2 x i64> %call71, ptr %b70, align 16, !tbaa !16
  %r72 = getelementptr inbounds %struct.anon.66, ptr %arrayinit.element67, i32 0, i32 2
  store i32 0, ptr %r72, align 16, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 13
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup81

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 4, ptr %r73) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [13 x %struct.anon.66], ptr %test_vec, i64 0, i64 %1
  %a74 = getelementptr inbounds %struct.anon.66, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a74, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx75 = getelementptr inbounds [13 x %struct.anon.66], ptr %test_vec, i64 0, i64 %3
  %b76 = getelementptr inbounds %struct.anon.66, ptr %arrayidx75, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b76, align 16, !tbaa !16
  %call77 = call i32 @simde_mm_test_all_zeros(<2 x i64> noundef %2, <2 x i64> noundef %4)
  store i32 %call77, ptr %r73, align 4, !tbaa !5
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load i32, ptr %r73, align 4, !tbaa !5
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx78 = getelementptr inbounds [13 x %struct.anon.66], ptr %test_vec, i64 0, i64 %6
  %r79 = getelementptr inbounds %struct.anon.66, ptr %arrayidx78, i32 0, i32 2
  %7 = load i32, ptr %r79, align 16, !tbaa !29
  %call80 = call i32 @simde_assert_equal_i_(i32 noundef %5, i32 noundef %7, ptr noundef @.str.72, i32 noundef 3402, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call80, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %r73) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup81 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup81:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest82 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest82, label %cleanup83 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup81
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup83

cleanup83:                                        ; preds = %for.end, %cleanup81
  call void @llvm.lifetime.end.p0(i64 624, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_test_mix_ones_zeros() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.67], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r43 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.67], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.67, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 817555810, i32 noundef -392475562, i32 noundef -317029798, i32 noundef -1522204875)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.67, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1924103348, i32 noundef 1357836992, i32 noundef -230713529, i32 noundef -1098023807)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.67, ptr %arrayinit.begin, i32 0, i32 2
  store i32 1, ptr %r, align 16, !tbaa !29
  %arrayinit.element = getelementptr inbounds %struct.anon.67, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1969146297, i32 noundef -578764638, i32 noundef 759743671, i32 noundef -1368673071)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %b4 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1969146298, i32 noundef 578764637, i32 noundef -759743672, i32 noundef 1368673070)
  store <2 x i64> %call5, ptr %b4, align 16, !tbaa !16
  %r6 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element, i32 0, i32 2
  store i32 0, ptr %r6, align 16, !tbaa !29
  %arrayinit.element7 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element, i64 1
  %a8 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element7, i32 0, i32 0
  %call9 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -500720968, i32 noundef -1999149836, i32 noundef -1331373542, i32 noundef -2045934177)
  store <2 x i64> %call9, ptr %a8, align 16, !tbaa !16
  %b10 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element7, i32 0, i32 1
  %call11 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1810964868, i32 noundef -521949452, i32 noundef 1790481610, i32 noundef -190670089)
  store <2 x i64> %call11, ptr %b10, align 16, !tbaa !16
  %r12 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element7, i32 0, i32 2
  store i32 1, ptr %r12, align 16, !tbaa !29
  %arrayinit.element13 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element7, i64 1
  %a14 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element13, i32 0, i32 0
  %call15 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -573607366, i32 noundef 2092677361, i32 noundef -1622221207, i32 noundef -1510467891)
  store <2 x i64> %call15, ptr %a14, align 16, !tbaa !16
  %b16 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element13, i32 0, i32 1
  %call17 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 573607365, i32 noundef -2092677362, i32 noundef 1622221206, i32 noundef 1510467890)
  store <2 x i64> %call17, ptr %b16, align 16, !tbaa !16
  %r18 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element13, i32 0, i32 2
  store i32 0, ptr %r18, align 16, !tbaa !29
  %arrayinit.element19 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element13, i64 1
  %a20 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element19, i32 0, i32 0
  %call21 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1688049548, i32 noundef 227731129, i32 noundef -2107961153, i32 noundef -2103262334)
  store <2 x i64> %call21, ptr %a20, align 16, !tbaa !16
  %b22 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element19, i32 0, i32 1
  %call23 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -555212961, i32 noundef 1136006144, i32 noundef 2036111421, i32 noundef -344668565)
  store <2 x i64> %call23, ptr %b22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element19, i32 0, i32 2
  store i32 1, ptr %r24, align 16, !tbaa !29
  %arrayinit.element25 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element19, i64 1
  %a26 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element25, i32 0, i32 0
  %call27 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1874362142, i32 noundef 1034465439, i32 noundef 270210360, i32 noundef 1245331438)
  store <2 x i64> %call27, ptr %a26, align 16, !tbaa !16
  %b28 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element25, i32 0, i32 1
  %call29 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1874362141, i32 noundef -1034465440, i32 noundef -270210361, i32 noundef -1245331439)
  store <2 x i64> %call29, ptr %b28, align 16, !tbaa !16
  %r30 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element25, i32 0, i32 2
  store i32 0, ptr %r30, align 16, !tbaa !29
  %arrayinit.element31 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element25, i64 1
  %a32 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -2092814790, i32 noundef 285372976, i32 noundef -181115429, i32 noundef 1775650196)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %b34 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1343523829, i32 noundef 1206063205, i32 noundef -2016156797, i32 noundef 1561806132)
  store <2 x i64> %call35, ptr %b34, align 16, !tbaa !16
  %r36 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element31, i32 0, i32 2
  store i32 1, ptr %r36, align 16, !tbaa !29
  %arrayinit.element37 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element31, i64 1
  %a38 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1908452317, i32 noundef 2103226597, i32 noundef 427456035, i32 noundef 2075844151)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 2028307641, i32 noundef -498986905, i32 noundef 1321164258, i32 noundef 1543009672)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.67, ptr %arrayinit.element37, i32 0, i32 2
  store i32 1, ptr %r42, align 16, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup51

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 4, ptr %r43) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.67], ptr %test_vec, i64 0, i64 %1
  %a44 = getelementptr inbounds %struct.anon.67, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a44, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx45 = getelementptr inbounds [8 x %struct.anon.67], ptr %test_vec, i64 0, i64 %3
  %b46 = getelementptr inbounds %struct.anon.67, ptr %arrayidx45, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b46, align 16, !tbaa !16
  %call47 = call i32 @simde_mm_test_mix_ones_zeros(<2 x i64> noundef %2, <2 x i64> noundef %4)
  store i32 %call47, ptr %r43, align 4, !tbaa !5
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load i32, ptr %r43, align 4, !tbaa !5
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx48 = getelementptr inbounds [8 x %struct.anon.67], ptr %test_vec, i64 0, i64 %6
  %r49 = getelementptr inbounds %struct.anon.67, ptr %arrayidx48, i32 0, i32 2
  %7 = load i32, ptr %r49, align 16, !tbaa !29
  %call50 = call i32 @simde_assert_equal_i_(i32 noundef %5, i32 noundef %7, ptr noundef @.str.72, i32 noundef 3443, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call50, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %r43) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup51 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup51:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest52 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest52, label %cleanup53 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup51
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup53

cleanup53:                                        ; preds = %for.end, %cleanup51
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_testc_si128() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [11 x %struct.anon.68], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r61 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 528, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [11 x %struct.anon.68], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.68, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1464347701, i32 noundef -573067451, i32 noundef 1506484780, i32 noundef -540333059)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.68, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 135762121, i32 noundef 1485021188, i32 noundef 66080, i32 noundef 1279789969)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.68, ptr %arrayinit.begin, i32 0, i32 2
  store i32 1, ptr %r, align 16, !tbaa !29
  %arrayinit.element = getelementptr inbounds %struct.anon.68, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 193385482, i32 noundef -1565570744, i32 noundef -999408936, i32 noundef 1810466520)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %b4 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 2126857072, i32 noundef 2130569152, i32 noundef 589776977, i32 noundef -756779885)
  store <2 x i64> %call5, ptr %b4, align 16, !tbaa !16
  %r6 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element, i32 0, i32 2
  store i32 0, ptr %r6, align 16, !tbaa !29
  %arrayinit.element7 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element, i64 1
  %a8 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element7, i32 0, i32 0
  %call9 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 786883487, i32 noundef 1935834902, i32 noundef 1176572533, i32 noundef -1646723621)
  store <2 x i64> %call9, ptr %a8, align 16, !tbaa !16
  %b10 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element7, i32 0, i32 1
  %call11 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 782262300, i32 noundef 1617050388, i32 noundef 33620084, i32 noundef 294672713)
  store <2 x i64> %call11, ptr %b10, align 16, !tbaa !16
  %r12 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element7, i32 0, i32 2
  store i32 1, ptr %r12, align 16, !tbaa !29
  %arrayinit.element13 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element7, i64 1
  %a14 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element13, i32 0, i32 0
  %call15 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1041307471, i32 noundef 45744950, i32 noundef 1982345789, i32 noundef -1142335248)
  store <2 x i64> %call15, ptr %a14, align 16, !tbaa !16
  %b16 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element13, i32 0, i32 1
  %call17 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1387031193, i32 noundef 524221074, i32 noundef -1331414902, i32 noundef 26167124)
  store <2 x i64> %call17, ptr %b16, align 16, !tbaa !16
  %r18 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element13, i32 0, i32 2
  store i32 0, ptr %r18, align 16, !tbaa !29
  %arrayinit.element19 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element13, i64 1
  %a20 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element19, i32 0, i32 0
  %call21 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -198656076, i32 noundef 1013684968, i32 noundef -946326749, i32 noundef -2100139033)
  store <2 x i64> %call21, ptr %a20, align 16, !tbaa !16
  %b22 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element19, i32 0, i32 1
  %call23 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1006598892, i32 noundef 873007168, i32 noundef 127402785, i32 noundef 43000416)
  store <2 x i64> %call23, ptr %b22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element19, i32 0, i32 2
  store i32 1, ptr %r24, align 16, !tbaa !29
  %arrayinit.element25 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element19, i64 1
  %a26 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element25, i32 0, i32 0
  %call27 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -674696990, i32 noundef 102683939, i32 noundef 1921801133, i32 noundef -9258296)
  store <2 x i64> %call27, ptr %a26, align 16, !tbaa !16
  %b28 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element25, i32 0, i32 1
  %call29 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -2076139294, i32 noundef 67671297, i32 noundef 1384665613, i32 noundef 2030217920)
  store <2 x i64> %call29, ptr %b28, align 16, !tbaa !16
  %r30 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element25, i32 0, i32 2
  store i32 1, ptr %r30, align 16, !tbaa !29
  %arrayinit.element31 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element25, i64 1
  %a32 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 948424904, i32 noundef 1962159425, i32 noundef 1599818052, i32 noundef 324039513)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %b34 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 671486144, i32 noundef 1888759104, i32 noundef 1191182592, i32 noundef 319836488)
  store <2 x i64> %call35, ptr %b34, align 16, !tbaa !16
  %r36 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element31, i32 0, i32 2
  store i32 1, ptr %r36, align 16, !tbaa !29
  %arrayinit.element37 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element31, i64 1
  %a38 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1368638111, i32 noundef -1024584699, i32 noundef 628918622, i32 noundef -1197900943)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -2012726944, i32 noundef -1029173243, i32 noundef 71305480, i32 noundef 948529457)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element37, i32 0, i32 2
  store i32 1, ptr %r42, align 16, !tbaa !29
  %arrayinit.element43 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element37, i64 1
  %a44 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element43, i32 0, i32 0
  %call45 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1, i32 noundef 2, i32 noundef 4, i32 noundef 248)
  store <2 x i64> %call45, ptr %a44, align 16, !tbaa !16
  %b46 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element43, i32 0, i32 1
  %call47 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1, i32 noundef 2, i32 noundef 4, i32 noundef 248)
  store <2 x i64> %call47, ptr %b46, align 16, !tbaa !16
  %r48 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element43, i32 0, i32 2
  store i32 1, ptr %r48, align 16, !tbaa !29
  %arrayinit.element49 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element43, i64 1
  %a50 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element49, i32 0, i32 0
  %call51 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1, i32 noundef 2, i32 noundef 4, i32 noundef 248)
  store <2 x i64> %call51, ptr %a50, align 16, !tbaa !16
  %b52 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element49, i32 0, i32 1
  %call53 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 254, i32 noundef 253, i32 noundef 0, i32 noundef 0)
  store <2 x i64> %call53, ptr %b52, align 16, !tbaa !16
  %r54 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element49, i32 0, i32 2
  store i32 0, ptr %r54, align 16, !tbaa !29
  %arrayinit.element55 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element49, i64 1
  %a56 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element55, i32 0, i32 0
  %call57 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1, i32 noundef 2, i32 noundef 4, i32 noundef 248)
  store <2 x i64> %call57, ptr %a56, align 16, !tbaa !16
  %b58 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element55, i32 0, i32 1
  %call59 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 0, i32 noundef 0, i32 noundef 4, i32 noundef 0)
  store <2 x i64> %call59, ptr %b58, align 16, !tbaa !16
  %r60 = getelementptr inbounds %struct.anon.68, ptr %arrayinit.element55, i32 0, i32 2
  store i32 1, ptr %r60, align 16, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 11
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup69

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 4, ptr %r61) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [11 x %struct.anon.68], ptr %test_vec, i64 0, i64 %1
  %a62 = getelementptr inbounds %struct.anon.68, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a62, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx63 = getelementptr inbounds [11 x %struct.anon.68], ptr %test_vec, i64 0, i64 %3
  %b64 = getelementptr inbounds %struct.anon.68, ptr %arrayidx63, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b64, align 16, !tbaa !16
  %call65 = call i32 @simde_mm_testc_si128(<2 x i64> noundef %2, <2 x i64> noundef %4)
  store i32 %call65, ptr %r61, align 4, !tbaa !5
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load i32, ptr %r61, align 4, !tbaa !5
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx66 = getelementptr inbounds [11 x %struct.anon.68], ptr %test_vec, i64 0, i64 %6
  %r67 = getelementptr inbounds %struct.anon.68, ptr %arrayidx66, i32 0, i32 2
  %7 = load i32, ptr %r67, align 16, !tbaa !29
  %call68 = call i32 @simde_assert_equal_i_(i32 noundef %5, i32 noundef %7, ptr noundef @.str.72, i32 noundef 3493, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call68, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %r61) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup69 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup69:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest70 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest70, label %cleanup71 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup69
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup71

cleanup71:                                        ; preds = %for.end, %cleanup69
  call void @llvm.lifetime.end.p0(i64 528, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_testnzc_si128() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [11 x %struct.anon.69], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r61 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 528, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [11 x %struct.anon.69], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.69, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1875425415, i32 noundef -324403250, i32 noundef -1143602815, i32 noundef -648146201)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.69, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 939391786, i32 noundef 1418582693, i32 noundef -711388150, i32 noundef -1316425174)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.69, ptr %arrayinit.begin, i32 0, i32 2
  store i32 1, ptr %r, align 16, !tbaa !29
  %arrayinit.element = getelementptr inbounds %struct.anon.69, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1948733162, i32 noundef -581273352, i32 noundef -1600754043, i32 noundef 1663204587)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %b4 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1140998794, i32 noundef 1141393520, i32 noundef -1609432576, i32 noundef 1124213826)
  store <2 x i64> %call5, ptr %b4, align 16, !tbaa !16
  %r6 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element, i32 0, i32 2
  store i32 0, ptr %r6, align 16, !tbaa !29
  %arrayinit.element7 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element, i64 1
  %a8 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element7, i32 0, i32 0
  %call9 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1383702507, i32 noundef -124474505, i32 noundef 81283149, i32 noundef -1722962347)
  store <2 x i64> %call9, ptr %a8, align 16, !tbaa !16
  %b10 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element7, i32 0, i32 1
  %call11 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1383112482, i32 noundef 1049365, i32 noundef 67110920, i32 noundef 33301)
  store <2 x i64> %call11, ptr %b10, align 16, !tbaa !16
  %r12 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element7, i32 0, i32 2
  store i32 0, ptr %r12, align 16, !tbaa !29
  %arrayinit.element13 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element7, i64 1
  %a14 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element13, i32 0, i32 0
  %call15 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 122650173, i32 noundef -874569676, i32 noundef -1784616986, i32 noundef 1202770589)
  store <2 x i64> %call15, ptr %a14, align 16, !tbaa !16
  %b16 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element13, i32 0, i32 1
  %call17 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -619665284, i32 noundef 291962269, i32 noundef 1109447557, i32 noundef 739260950)
  store <2 x i64> %call17, ptr %b16, align 16, !tbaa !16
  %r18 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element13, i32 0, i32 2
  store i32 1, ptr %r18, align 16, !tbaa !29
  %arrayinit.element19 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element13, i64 1
  %a20 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element19, i32 0, i32 0
  %call21 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1579102285, i32 noundef 270245457, i32 noundef 1078977019, i32 noundef 2085912657)
  store <2 x i64> %call21, ptr %a20, align 16, !tbaa !16
  %b22 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element19, i32 0, i32 1
  %call23 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1242112064, i32 noundef 1606145, i32 noundef 688393, i32 noundef 402685968)
  store <2 x i64> %call23, ptr %b22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element19, i32 0, i32 2
  store i32 0, ptr %r24, align 16, !tbaa !29
  %arrayinit.element25 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element19, i64 1
  %a26 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element25, i32 0, i32 0
  %call27 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -900558507, i32 noundef -1634243064, i32 noundef -1977689970, i32 noundef -1089977960)
  store <2 x i64> %call27, ptr %a26, align 16, !tbaa !16
  %b28 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element25, i32 0, i32 1
  %call29 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1819319362, i32 noundef 329857933, i32 noundef -903839886, i32 noundef 743662239)
  store <2 x i64> %call29, ptr %b28, align 16, !tbaa !16
  %r30 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element25, i32 0, i32 2
  store i32 1, ptr %r30, align 16, !tbaa !29
  %arrayinit.element31 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element25, i64 1
  %a32 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -169342311, i32 noundef 2864942, i32 noundef 875515634, i32 noundef 2091317004)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %b34 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 617089160, i32 noundef 112418, i32 noundef 606079728, i32 noundef 1881276672)
  store <2 x i64> %call35, ptr %b34, align 16, !tbaa !16
  %r36 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element31, i32 0, i32 2
  store i32 0, ptr %r36, align 16, !tbaa !29
  %arrayinit.element37 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element31, i64 1
  %a38 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1872970168, i32 noundef -609143574, i32 noundef -1706512534, i32 noundef 2067412407)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -368226859, i32 noundef 589344338, i32 noundef -1336701575, i32 noundef 1121386306)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element37, i32 0, i32 2
  store i32 1, ptr %r42, align 16, !tbaa !29
  %arrayinit.element43 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element37, i64 1
  %a44 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element43, i32 0, i32 0
  %call45 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1, i32 noundef 2, i32 noundef 4, i32 noundef 248)
  store <2 x i64> %call45, ptr %a44, align 16, !tbaa !16
  %b46 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element43, i32 0, i32 1
  %call47 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0)
  store <2 x i64> %call47, ptr %b46, align 16, !tbaa !16
  %r48 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element43, i32 0, i32 2
  store i32 0, ptr %r48, align 16, !tbaa !29
  %arrayinit.element49 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element43, i64 1
  %a50 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element49, i32 0, i32 0
  %call51 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1, i32 noundef 2, i32 noundef 4, i32 noundef 248)
  store <2 x i64> %call51, ptr %a50, align 16, !tbaa !16
  %b52 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element49, i32 0, i32 1
  %call53 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1, i32 noundef 4, i32 noundef 0, i32 noundef 0)
  store <2 x i64> %call53, ptr %b52, align 16, !tbaa !16
  %r54 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element49, i32 0, i32 2
  store i32 1, ptr %r54, align 16, !tbaa !29
  %arrayinit.element55 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element49, i64 1
  %a56 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element55, i32 0, i32 0
  %call57 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1, i32 noundef 2, i32 noundef 4, i32 noundef 248)
  store <2 x i64> %call57, ptr %a56, align 16, !tbaa !16
  %b58 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element55, i32 0, i32 1
  %call59 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1, i32 noundef 2, i32 noundef 4, i32 noundef 248)
  store <2 x i64> %call59, ptr %b58, align 16, !tbaa !16
  %r60 = getelementptr inbounds %struct.anon.69, ptr %arrayinit.element55, i32 0, i32 2
  store i32 0, ptr %r60, align 16, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 11
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup69

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 4, ptr %r61) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [11 x %struct.anon.69], ptr %test_vec, i64 0, i64 %1
  %a62 = getelementptr inbounds %struct.anon.69, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a62, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx63 = getelementptr inbounds [11 x %struct.anon.69], ptr %test_vec, i64 0, i64 %3
  %b64 = getelementptr inbounds %struct.anon.69, ptr %arrayidx63, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b64, align 16, !tbaa !16
  %call65 = call i32 @simde_mm_testnzc_si128(<2 x i64> noundef %2, <2 x i64> noundef %4)
  store i32 %call65, ptr %r61, align 4, !tbaa !5
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load i32, ptr %r61, align 4, !tbaa !5
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx66 = getelementptr inbounds [11 x %struct.anon.69], ptr %test_vec, i64 0, i64 %6
  %r67 = getelementptr inbounds %struct.anon.69, ptr %arrayidx66, i32 0, i32 2
  %7 = load i32, ptr %r67, align 16, !tbaa !29
  %call68 = call i32 @simde_assert_equal_i_(i32 noundef %5, i32 noundef %7, ptr noundef @.str.72, i32 noundef 3543, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call68, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %r61) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup69 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup69:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest70 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest70, label %cleanup71 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup69
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup71

cleanup71:                                        ; preds = %for.end, %cleanup69
  call void @llvm.lifetime.end.p0(i64 528, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm_testz_si128() #3 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.70], align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r43 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 384, ptr %test_vec) #10
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.70], ptr %test_vec, i64 0, i64 0
  %a = getelementptr inbounds %struct.anon.70, ptr %arrayinit.begin, i32 0, i32 0
  %call = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -304077397, i32 noundef -64178239, i32 noundef -486506254, i32 noundef -923539886)
  store <2 x i64> %call, ptr %a, align 16, !tbaa !16
  %b = getelementptr inbounds %struct.anon.70, ptr %arrayinit.begin, i32 0, i32 1
  %call1 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 331792, i32 noundef 63127558, i32 noundef 483990789, i32 noundef 530828)
  store <2 x i64> %call1, ptr %b, align 16, !tbaa !16
  %r = getelementptr inbounds %struct.anon.70, ptr %arrayinit.begin, i32 0, i32 2
  store i32 1, ptr %r, align 16, !tbaa !29
  %arrayinit.element = getelementptr inbounds %struct.anon.70, ptr %arrayinit.begin, i64 1
  %a2 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element, i32 0, i32 0
  %call3 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -691616465, i32 noundef -1863173781, i32 noundef 1875486201, i32 noundef -764434039)
  store <2 x i64> %call3, ptr %a2, align 16, !tbaa !16
  %b4 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element, i32 0, i32 1
  %call5 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 19933776, i32 noundef 1174733824, i32 noundef -2147086332, i32 noundef 8393234)
  store <2 x i64> %call5, ptr %b4, align 16, !tbaa !16
  %r6 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element, i32 0, i32 2
  store i32 1, ptr %r6, align 16, !tbaa !29
  %arrayinit.element7 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element, i64 1
  %a8 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element7, i32 0, i32 0
  %call9 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1170870073, i32 noundef -228350297, i32 noundef 2076362673, i32 noundef 124456258)
  store <2 x i64> %call9, ptr %a8, align 16, !tbaa !16
  %b10 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element7, i32 0, i32 1
  %call11 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1170213928, i32 noundef 84416520, i32 noundef -2144073662, i32 noundef -795553751)
  store <2 x i64> %call11, ptr %b10, align 16, !tbaa !16
  %r12 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element7, i32 0, i32 2
  store i32 1, ptr %r12, align 16, !tbaa !29
  %arrayinit.element13 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element7, i64 1
  %a14 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element13, i32 0, i32 0
  %call15 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -138171292, i32 noundef 1994002854, i32 noundef -260559416, i32 noundef 600089084)
  store <2 x i64> %call15, ptr %a14, align 16, !tbaa !16
  %b16 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element13, i32 0, i32 1
  %call17 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1323887342, i32 noundef -297158645, i32 noundef 222740062, i32 noundef -305160716)
  store <2 x i64> %call17, ptr %b16, align 16, !tbaa !16
  %r18 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element13, i32 0, i32 2
  store i32 0, ptr %r18, align 16, !tbaa !29
  %arrayinit.element19 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element13, i64 1
  %a20 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element19, i32 0, i32 0
  %call21 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -164414856, i32 noundef 812777701, i32 noundef 2016424386, i32 noundef 886379222)
  store <2 x i64> %call21, ptr %a20, align 16, !tbaa !16
  %b22 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element19, i32 0, i32 1
  %call23 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 70177905, i32 noundef 2046022589, i32 noundef 670901459, i32 noundef -1316102126)
  store <2 x i64> %call23, ptr %b22, align 16, !tbaa !16
  %r24 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element19, i32 0, i32 2
  store i32 0, ptr %r24, align 16, !tbaa !29
  %arrayinit.element25 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element19, i64 1
  %a26 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element25, i32 0, i32 0
  %call27 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 192532312, i32 noundef 1467133872, i32 noundef 1075139299, i32 noundef 191167596)
  store <2 x i64> %call27, ptr %a26, align 16, !tbaa !16
  %b28 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element25, i32 0, i32 1
  %call29 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 1026534956, i32 noundef -164124048, i32 noundef -675661286, i32 noundef -696939994)
  store <2 x i64> %call29, ptr %b28, align 16, !tbaa !16
  %r30 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element25, i32 0, i32 2
  store i32 0, ptr %r30, align 16, !tbaa !29
  %arrayinit.element31 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element25, i64 1
  %a32 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element31, i32 0, i32 0
  %call33 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -1884549420, i32 noundef 74289906, i32 noundef -263127057, i32 noundef -1457085671)
  store <2 x i64> %call33, ptr %a32, align 16, !tbaa !16
  %b34 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element31, i32 0, i32 1
  %call35 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 542327083, i32 noundef 680656909, i32 noundef 184549392, i32 noundef 1421938882)
  store <2 x i64> %call35, ptr %b34, align 16, !tbaa !16
  %r36 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element31, i32 0, i32 2
  store i32 1, ptr %r36, align 16, !tbaa !29
  %arrayinit.element37 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element31, i64 1
  %a38 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element37, i32 0, i32 0
  %call39 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef -512816471, i32 noundef -969332279, i32 noundef 1617333560, i32 noundef -660530213)
  store <2 x i64> %call39, ptr %a38, align 16, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element37, i32 0, i32 1
  %call41 = call <2 x i64> @simde_x_mm_set_epu32(i32 noundef 167825730, i32 noundef 294047748, i32 noundef 126906945, i32 noundef 17884164)
  store <2 x i64> %call41, ptr %b40, align 16, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.70, ptr %arrayinit.element37, i32 0, i32 2
  store i32 1, ptr %r42, align 16, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup51

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 4, ptr %r43) #10
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.70], ptr %test_vec, i64 0, i64 %1
  %a44 = getelementptr inbounds %struct.anon.70, ptr %arrayidx, i32 0, i32 0
  %2 = load <2 x i64>, ptr %a44, align 16, !tbaa !16
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx45 = getelementptr inbounds [8 x %struct.anon.70], ptr %test_vec, i64 0, i64 %3
  %b46 = getelementptr inbounds %struct.anon.70, ptr %arrayidx45, i32 0, i32 1
  %4 = load <2 x i64>, ptr %b46, align 16, !tbaa !16
  %call47 = call i32 @simde_mm_testz_si128(<2 x i64> noundef %2, <2 x i64> noundef %4)
  store i32 %call47, ptr %r43, align 4, !tbaa !5
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load i32, ptr %r43, align 4, !tbaa !5
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx48 = getelementptr inbounds [8 x %struct.anon.70], ptr %test_vec, i64 0, i64 %6
  %r49 = getelementptr inbounds %struct.anon.70, ptr %arrayidx48, i32 0, i32 2
  %7 = load i32, ptr %r49, align 16, !tbaa !29
  %call50 = call i32 @simde_assert_equal_i_(i32 noundef %5, i32 noundef %7, ptr noundef @.str.72, i32 noundef 3584, ptr noundef @.str.73, ptr noundef @.str.74)
  %tobool = icmp ne i32 %call50, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %r43) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup51 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup51:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest52 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest52, label %cleanup53 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup51
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup53

cleanup53:                                        ; preds = %for.end, %cleanup51
  call void @llvm.lifetime.end.p0(i64 384, ptr %test_vec) #10
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_set_epi16(i16 noundef signext %e7, i16 noundef signext %e6, i16 noundef signext %e5, i16 noundef signext %e4, i16 noundef signext %e3, i16 noundef signext %e2, i16 noundef signext %e1, i16 noundef signext %e0) #4 {
entry:
  %e7.addr = alloca i16, align 2
  %e6.addr = alloca i16, align 2
  %e5.addr = alloca i16, align 2
  %e4.addr = alloca i16, align 2
  %e3.addr = alloca i16, align 2
  %e2.addr = alloca i16, align 2
  %e1.addr = alloca i16, align 2
  %e0.addr = alloca i16, align 2
  %r_ = alloca %union.simde__m128i_private, align 16
  store i16 %e7, ptr %e7.addr, align 2, !tbaa !31
  store i16 %e6, ptr %e6.addr, align 2, !tbaa !31
  store i16 %e5, ptr %e5.addr, align 2, !tbaa !31
  store i16 %e4, ptr %e4.addr, align 2, !tbaa !31
  store i16 %e3, ptr %e3.addr, align 2, !tbaa !31
  store i16 %e2, ptr %e2.addr, align 2, !tbaa !31
  store i16 %e1, ptr %e1.addr, align 2, !tbaa !31
  store i16 %e0, ptr %e0.addr, align 2, !tbaa !31
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  %0 = load i16, ptr %e0.addr, align 2, !tbaa !31
  %1 = load <8 x i16>, ptr %r_, align 16
  %vecins = insertelement <8 x i16> %1, i16 %0, i32 0
  store <8 x i16> %vecins, ptr %r_, align 16
  %2 = load i16, ptr %e1.addr, align 2, !tbaa !31
  %3 = load <8 x i16>, ptr %r_, align 16
  %vecins1 = insertelement <8 x i16> %3, i16 %2, i32 1
  store <8 x i16> %vecins1, ptr %r_, align 16
  %4 = load i16, ptr %e2.addr, align 2, !tbaa !31
  %5 = load <8 x i16>, ptr %r_, align 16
  %vecins2 = insertelement <8 x i16> %5, i16 %4, i32 2
  store <8 x i16> %vecins2, ptr %r_, align 16
  %6 = load i16, ptr %e3.addr, align 2, !tbaa !31
  %7 = load <8 x i16>, ptr %r_, align 16
  %vecins3 = insertelement <8 x i16> %7, i16 %6, i32 3
  store <8 x i16> %vecins3, ptr %r_, align 16
  %8 = load i16, ptr %e4.addr, align 2, !tbaa !31
  %9 = load <8 x i16>, ptr %r_, align 16
  %vecins4 = insertelement <8 x i16> %9, i16 %8, i32 4
  store <8 x i16> %vecins4, ptr %r_, align 16
  %10 = load i16, ptr %e5.addr, align 2, !tbaa !31
  %11 = load <8 x i16>, ptr %r_, align 16
  %vecins5 = insertelement <8 x i16> %11, i16 %10, i32 5
  store <8 x i16> %vecins5, ptr %r_, align 16
  %12 = load i16, ptr %e6.addr, align 2, !tbaa !31
  %13 = load <8 x i16>, ptr %r_, align 16
  %vecins6 = insertelement <8 x i16> %13, i16 %12, i32 6
  store <8 x i16> %vecins6, ptr %r_, align 16
  %14 = load i16, ptr %e7.addr, align 2, !tbaa !31
  %15 = load <8 x i16>, ptr %r_, align 16
  %vecins7 = insertelement <8 x i16> %15, i16 %14, i32 7
  store <8 x i16> %vecins7, ptr %r_, align 16
  %16 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %17 = load double, ptr %16, align 16
  %18 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %19 = load double, ptr %18, align 8
  %call = call <2 x i64> @simde__m128i_from_private(double %17, double %19)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal { double, double } @simde__m128i_to_private(<2 x i64> noundef %v) #4 {
entry:
  %retval = alloca %union.simde__m128i_private, align 16
  %v.addr = alloca <2 x i64>, align 16
  store <2 x i64> %v, ptr %v.addr, align 16, !tbaa !16
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %retval, ptr align 16 %v.addr, i64 16, i1 false)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %retval, i32 0, i32 0
  %0 = load { double, double }, ptr %coerce.dive, align 16
  ret { double, double } %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde__m128i_from_private(double %v.coerce0, double %v.coerce1) #4 {
entry:
  %v = alloca %union.simde__m128i_private, align 16
  %r = alloca <2 x i64>, align 16
  %0 = getelementptr inbounds { double, double }, ptr %v, i32 0, i32 0
  store double %v.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { double, double }, ptr %v, i32 0, i32 1
  store double %v.coerce1, ptr %1, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #10
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %r, ptr align 16 %v, i64 16, i1 false)
  %2 = load <2 x i64>, ptr %r, align 16, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #10
  ret <2 x i64> %2
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_x86_assert_equal_i16x8_(<2 x i64> noundef %a, <2 x i64> noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #3 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %a_ = alloca [8 x i16], align 16
  %b_ = alloca [8 x i16], align 16
  %simde_r_ = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %simde_r_1 = alloca ptr, align 8
  %tmp3 = alloca ptr, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_) #10
  %arraydecay = getelementptr inbounds [8 x i16], ptr %a_, i64 0, i64 0
  store ptr %arraydecay, ptr %simde_r_, align 8, !tbaa !9
  %0 = load ptr, ptr %simde_r_, align 8, !tbaa !9
  store ptr %0, ptr %tmp, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_) #10
  %1 = load ptr, ptr %tmp, align 8, !tbaa !9
  %2 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_si128(ptr noundef %1, <2 x i64> noundef %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_1) #10
  %arraydecay2 = getelementptr inbounds [8 x i16], ptr %b_, i64 0, i64 0
  store ptr %arraydecay2, ptr %simde_r_1, align 8, !tbaa !9
  %3 = load ptr, ptr %simde_r_1, align 8, !tbaa !9
  store ptr %3, ptr %tmp3, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_1) #10
  %4 = load ptr, ptr %tmp3, align 8, !tbaa !9
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_si128(ptr noundef %4, <2 x i64> noundef %5)
  %arraydecay4 = getelementptr inbounds [8 x i16], ptr %a_, i64 0, i64 0
  %arraydecay5 = getelementptr inbounds [8 x i16], ptr %b_, i64 0, i64 0
  %6 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %7 = load i32, ptr %line.addr, align 4, !tbaa !5
  %8 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %9 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %call = call i32 @simde_assert_equal_vi16_(i64 noundef 8, ptr noundef %arraydecay4, ptr noundef %arraydecay5, ptr noundef %6, i32 noundef %7, ptr noundef %8, ptr noundef %9)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  ret i32 %call
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #5

; Function Attrs: alwaysinline nounwind uwtable
define internal void @simde_mm_storeu_si128(ptr noundef %mem_addr, <2 x i64> noundef %a) #4 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %a.addr = alloca <2 x i64>, align 16
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  %0 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %0, ptr align 16 %a.addr, i64 16, i1 false)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_vi16_(i64 noundef %vec_len, ptr noundef %a, ptr noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %vec_len.addr = alloca i64, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i64 %vec_len, ptr %vec_len.addr, align 8, !tbaa !11
  store ptr %a, ptr %a.addr, align 8, !tbaa !9
  store ptr %b, ptr %b.addr, align 8, !tbaa !9
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %1 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %3 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds i16, ptr %4, i64 %5
  %6 = load i16, ptr %arrayidx, align 2, !tbaa !31
  %conv = sext i16 %6 to i32
  %7 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx1 = getelementptr inbounds i16, ptr %7, i64 %8
  %9 = load i16, ptr %arrayidx1, align 2, !tbaa !31
  %conv2 = sext i16 %9 to i32
  %cmp3 = icmp ne i32 %conv, %conv2
  %lnot = xor i1 %cmp3, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %10 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %11 = load i32, ptr %line.addr, align 4, !tbaa !5
  %12 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %13 = load i64, ptr %i, align 8, !tbaa !11
  %14 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %15 = load i64, ptr %i, align 8, !tbaa !11
  %16 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %17 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx7 = getelementptr inbounds i16, ptr %16, i64 %17
  %18 = load i16, ptr %arrayidx7, align 2, !tbaa !31
  %conv8 = sext i16 %18 to i32
  %19 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %20 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx9 = getelementptr inbounds i16, ptr %19, i64 %20
  %21 = load i16, ptr %arrayidx9, align 2, !tbaa !31
  %conv10 = sext i16 %21 to i32
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.75, ptr noundef %10, i32 noundef %11, ptr noundef %12, i64 noundef %13, ptr noundef %14, i64 noundef %15, i32 noundef %conv8, i32 noundef %conv10)
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %22 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %22, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup
  %23 = load i32, ptr %retval, align 4
  ret i32 %23

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(none)
declare i64 @llvm.expect.i64(i64, i64) #6

; Function Attrs: nounwind uwtable
define internal void @simde_test_debug_printf_(ptr noundef %format, ...) #0 {
entry:
  %format.addr = alloca ptr, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  store ptr %format, ptr %format.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 24, ptr %ap) #10
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_start.p0(ptr %arraydecay)
  %0 = load ptr, ptr @stderr, align 8, !tbaa !9
  %1 = load ptr, ptr %format.addr, align 8, !tbaa !9
  %arraydecay1 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %call = call i32 @vfprintf(ptr noundef %0, ptr noundef %1, ptr noundef %arraydecay1)
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_end.p0(ptr %arraydecay2)
  %2 = load ptr, ptr @stderr, align 8, !tbaa !9
  %call3 = call i32 @fflush(ptr noundef %2)
  call void @llvm.lifetime.end.p0(i64 24, ptr %ap) #10
  ret void
}

declare i32 @vfprintf(ptr noundef, ptr noundef, ptr noundef) #2

declare i32 @fflush(ptr noundef) #2

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x double> @simde_mm_set_pd(double noundef %e1, double noundef %e0) #4 {
entry:
  %e1.addr = alloca double, align 8
  %e0.addr = alloca double, align 8
  %r_ = alloca %union.simde__m128d_private, align 16
  store double %e1, ptr %e1.addr, align 8, !tbaa !33
  store double %e0, ptr %e0.addr, align 8, !tbaa !33
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  %0 = load double, ptr %e0.addr, align 8, !tbaa !33
  %1 = load <2 x double>, ptr %r_, align 16
  %vecins = insertelement <2 x double> %1, double %0, i32 0
  store <2 x double> %vecins, ptr %r_, align 16
  %2 = load double, ptr %e1.addr, align 8, !tbaa !33
  %3 = load <2 x double>, ptr %r_, align 16
  %vecins1 = insertelement <2 x double> %3, double %2, i32 1
  store <2 x double> %vecins1, ptr %r_, align 16
  %4 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %5 = load double, ptr %4, align 16
  %6 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %7 = load double, ptr %6, align 8
  %call = call <2 x double> @simde__m128d_from_private(double %5, double %7)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x double> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal { double, double } @simde__m128d_to_private(<2 x double> noundef %v) #4 {
entry:
  %retval = alloca %union.simde__m128d_private, align 16
  %v.addr = alloca <2 x double>, align 16
  store <2 x double> %v, ptr %v.addr, align 16, !tbaa !16
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %retval, ptr align 16 %v.addr, i64 16, i1 false)
  %coerce.dive = getelementptr inbounds %union.simde__m128d_private, ptr %retval, i32 0, i32 0
  %0 = load { double, double }, ptr %coerce.dive, align 16
  ret { double, double } %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x double> @simde__m128d_from_private(double %v.coerce0, double %v.coerce1) #4 {
entry:
  %v = alloca %union.simde__m128d_private, align 16
  %r = alloca <2 x double>, align 16
  %0 = getelementptr inbounds { double, double }, ptr %v, i32 0, i32 0
  store double %v.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { double, double }, ptr %v, i32 0, i32 1
  store double %v.coerce1, ptr %1, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #10
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %r, ptr align 16 %v, i64 16, i1 false)
  %2 = load <2 x double>, ptr %r, align 16, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #10
  ret <2 x double> %2
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_x86_assert_equal_f64x2_(<2 x double> noundef %a, <2 x double> noundef %b, double noundef %slop, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #3 {
entry:
  %a.addr = alloca <2 x double>, align 16
  %b.addr = alloca <2 x double>, align 16
  %slop.addr = alloca double, align 8
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %a_ = alloca [2 x double], align 16
  %b_ = alloca [2 x double], align 16
  store <2 x double> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x double> %b, ptr %b.addr, align 16, !tbaa !16
  store double %slop, ptr %slop.addr, align 8, !tbaa !33
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %arraydecay = getelementptr inbounds [2 x double], ptr %a_, i64 0, i64 0
  %0 = load <2 x double>, ptr %a.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_pd(ptr noundef %arraydecay, <2 x double> noundef %0)
  %arraydecay1 = getelementptr inbounds [2 x double], ptr %b_, i64 0, i64 0
  %1 = load <2 x double>, ptr %b.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_pd(ptr noundef %arraydecay1, <2 x double> noundef %1)
  %arraydecay2 = getelementptr inbounds [2 x double], ptr %a_, i64 0, i64 0
  %arraydecay3 = getelementptr inbounds [2 x double], ptr %b_, i64 0, i64 0
  %2 = load double, ptr %slop.addr, align 8, !tbaa !33
  %3 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %4 = load i32, ptr %line.addr, align 4, !tbaa !5
  %5 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %6 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %call = call i32 @simde_assert_equal_vf64_(i64 noundef 2, ptr noundef %arraydecay2, ptr noundef %arraydecay3, double noundef %2, ptr noundef %3, i32 noundef %4, ptr noundef %5, ptr noundef %6)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal double @simde_test_f64_precision_to_slop(i32 noundef %precision) #0 {
entry:
  %precision.addr = alloca i32, align 4
  store i32 %precision, ptr %precision.addr, align 4, !tbaa !5
  %0 = load i32, ptr %precision.addr, align 4, !tbaa !5
  %cmp = icmp eq i32 %0, 2147483647
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load i32, ptr %precision.addr, align 4, !tbaa !5
  %conv2 = sitofp i32 %1 to double
  %fneg = fneg double %conv2
  %call = call double @pow(double noundef 1.000000e+01, double noundef %fneg) #10
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ 0.000000e+00, %cond.true ], [ %call, %cond.false ]
  ret double %cond
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @simde_mm_storeu_pd(ptr noundef %mem_addr, <2 x double> noundef %a) #4 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %a.addr = alloca <2 x double>, align 16
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  store <2 x double> %a, ptr %a.addr, align 16, !tbaa !16
  %0 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %0, ptr align 16 %a.addr, i64 16, i1 false)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_vf64_(i64 noundef %vec_len, ptr noundef %a, ptr noundef %b, double noundef %slop, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %vec_len.addr = alloca i64, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %slop.addr = alloca double, align 8
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i64 %vec_len, ptr %vec_len.addr, align 8, !tbaa !11
  store ptr %a, ptr %a.addr, align 8, !tbaa !9
  store ptr %b, ptr %b.addr, align 8, !tbaa !9
  store double %slop, ptr %slop.addr, align 8, !tbaa !33
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %1 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %3 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds double, ptr %4, i64 %5
  %6 = load double, ptr %arrayidx, align 8, !tbaa !33
  %7 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx1 = getelementptr inbounds double, ptr %7, i64 %8
  %9 = load double, ptr %arrayidx1, align 8, !tbaa !33
  %10 = load double, ptr %slop.addr, align 8, !tbaa !33
  %call = call i32 @simde_test_equal_f64(double noundef %6, double noundef %9, double noundef %10)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %11 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %12 = load i32, ptr %line.addr, align 4, !tbaa !5
  %13 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %14 = load i64, ptr %i, align 8, !tbaa !11
  %15 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %16 = load i64, ptr %i, align 8, !tbaa !11
  %17 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %18 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx5 = getelementptr inbounds double, ptr %17, i64 %18
  %19 = load double, ptr %arrayidx5, align 8, !tbaa !33
  %20 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %21 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx6 = getelementptr inbounds double, ptr %20, i64 %21
  %22 = load double, ptr %arrayidx6, align 8, !tbaa !33
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.76, ptr noundef %11, i32 noundef %12, ptr noundef %13, i64 noundef %14, ptr noundef %15, i64 noundef %16, double noundef %19, double noundef %22)
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %23 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %23, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup
  %24 = load i32, ptr %retval, align 4
  ret i32 %24

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_equal_f64(double noundef %a, double noundef %b, double noundef %slop) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca double, align 8
  %b.addr = alloca double, align 8
  %slop.addr = alloca double, align 8
  %lo = alloca double, align 8
  %hi = alloca double, align 8
  store double %a, ptr %a.addr, align 8, !tbaa !33
  store double %b, ptr %b.addr, align 8, !tbaa !33
  store double %slop, ptr %slop.addr, align 8, !tbaa !33
  %0 = load double, ptr %a.addr, align 8, !tbaa !33
  %1 = call i1 @llvm.is.fpclass.f64(double %0, i32 3)
  br i1 %1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load double, ptr %b.addr, align 8, !tbaa !33
  %3 = call i1 @llvm.is.fpclass.f64(double %2, i32 3)
  %4 = zext i1 %3 to i32
  store i32 %4, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %5 = load double, ptr %a.addr, align 8, !tbaa !33
  %6 = call i1 @llvm.is.fpclass.f64(double %5, i32 516)
  br i1 %6, label %if.then1, label %if.else3

if.then1:                                         ; preds = %if.else
  %7 = load double, ptr %a.addr, align 8, !tbaa !33
  %8 = load double, ptr %b.addr, align 8, !tbaa !33
  %cmp = fcmp olt double %7, %8
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then1
  %9 = load double, ptr %a.addr, align 8, !tbaa !33
  %10 = load double, ptr %b.addr, align 8, !tbaa !33
  %cmp2 = fcmp ogt double %9, %10
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then1
  %11 = phi i1 [ true, %if.then1 ], [ %cmp2, %lor.rhs ]
  %lnot = xor i1 %11, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, ptr %retval, align 4
  br label %return

if.else3:                                         ; preds = %if.else
  %12 = load double, ptr %slop.addr, align 8, !tbaa !33
  %cmp4 = fcmp oeq double %12, 0.000000e+00
  br i1 %cmp4, label %if.then5, label %if.else8

if.then5:                                         ; preds = %if.else3
  %call = call i32 @memcmp(ptr noundef %a.addr, ptr noundef %b.addr, i64 noundef 8) #10
  %tobool = icmp ne i32 %call, 0
  %lnot6 = xor i1 %tobool, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  store i32 %lnot.ext7, ptr %retval, align 4
  br label %return

if.else8:                                         ; preds = %if.else3
  call void @llvm.lifetime.start.p0(i64 8, ptr %lo) #10
  %13 = load double, ptr %a.addr, align 8, !tbaa !33
  %14 = load double, ptr %slop.addr, align 8, !tbaa !33
  %sub = fsub double %13, %14
  store double %sub, ptr %lo, align 8, !tbaa !33
  %15 = load double, ptr %lo, align 8, !tbaa !33
  %16 = load double, ptr %a.addr, align 8, !tbaa !33
  %cmp9 = fcmp oeq double %15, %16
  %lnot10 = xor i1 %cmp9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv = sext i32 %lnot.ext13 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool14 = icmp ne i64 %expval, 0
  br i1 %tobool14, label %if.then15, label %if.end

if.then15:                                        ; preds = %if.else8
  %17 = load double, ptr %a.addr, align 8, !tbaa !33
  %call16 = call double @nextafter(double noundef %17, double noundef 0xFFF0000000000000) #10
  store double %call16, ptr %lo, align 8, !tbaa !33
  br label %if.end

if.end:                                           ; preds = %if.then15, %if.else8
  call void @llvm.lifetime.start.p0(i64 8, ptr %hi) #10
  %18 = load double, ptr %a.addr, align 8, !tbaa !33
  %19 = load double, ptr %slop.addr, align 8, !tbaa !33
  %add = fadd double %18, %19
  store double %add, ptr %hi, align 8, !tbaa !33
  %20 = load double, ptr %hi, align 8, !tbaa !33
  %21 = load double, ptr %a.addr, align 8, !tbaa !33
  %cmp17 = fcmp oeq double %20, %21
  %lnot19 = xor i1 %cmp17, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %expval24 = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool25 = icmp ne i64 %expval24, 0
  br i1 %tobool25, label %if.then26, label %if.end28

if.then26:                                        ; preds = %if.end
  %22 = load double, ptr %a.addr, align 8, !tbaa !33
  %call27 = call double @nextafter(double noundef %22, double noundef 0x7FF0000000000000) #10
  store double %call27, ptr %hi, align 8, !tbaa !33
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %if.end
  %23 = load double, ptr %b.addr, align 8, !tbaa !33
  %24 = load double, ptr %lo, align 8, !tbaa !33
  %cmp29 = fcmp oge double %23, %24
  br i1 %cmp29, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end28
  %25 = load double, ptr %b.addr, align 8, !tbaa !33
  %26 = load double, ptr %hi, align 8, !tbaa !33
  %cmp31 = fcmp ole double %25, %26
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end28
  %27 = phi i1 [ false, %if.end28 ], [ %cmp31, %land.rhs ]
  %land.ext = zext i1 %27 to i32
  store i32 %land.ext, ptr %retval, align 4
  call void @llvm.lifetime.end.p0(i64 8, ptr %hi) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %lo) #10
  br label %return

return:                                           ; preds = %land.end, %if.then5, %lor.end, %if.then
  %28 = load i32, ptr %retval, align 4
  ret i32 %28
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i1 @llvm.is.fpclass.f64(double, i32 immarg) #7

; Function Attrs: nounwind
declare i32 @memcmp(ptr noundef, ptr noundef, i64 noundef) #8

; Function Attrs: nounwind
declare double @nextafter(double noundef, double noundef) #8

; Function Attrs: nounwind
declare double @pow(double noundef, double noundef) #8

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x float> @simde_mm_set_ps(float noundef %e3, float noundef %e2, float noundef %e1, float noundef %e0) #4 {
entry:
  %e3.addr = alloca float, align 4
  %e2.addr = alloca float, align 4
  %e1.addr = alloca float, align 4
  %e0.addr = alloca float, align 4
  %r_ = alloca %union.simde__m128_private, align 16
  store float %e3, ptr %e3.addr, align 4, !tbaa !35
  store float %e2, ptr %e2.addr, align 4, !tbaa !35
  store float %e1, ptr %e1.addr, align 4, !tbaa !35
  store float %e0, ptr %e0.addr, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  %0 = load float, ptr %e0.addr, align 4, !tbaa !35
  %1 = load <4 x float>, ptr %r_, align 16
  %vecins = insertelement <4 x float> %1, float %0, i32 0
  store <4 x float> %vecins, ptr %r_, align 16
  %2 = load float, ptr %e1.addr, align 4, !tbaa !35
  %3 = load <4 x float>, ptr %r_, align 16
  %vecins1 = insertelement <4 x float> %3, float %2, i32 1
  store <4 x float> %vecins1, ptr %r_, align 16
  %4 = load float, ptr %e2.addr, align 4, !tbaa !35
  %5 = load <4 x float>, ptr %r_, align 16
  %vecins2 = insertelement <4 x float> %5, float %4, i32 2
  store <4 x float> %vecins2, ptr %r_, align 16
  %6 = load float, ptr %e3.addr, align 4, !tbaa !35
  %7 = load <4 x float>, ptr %r_, align 16
  %vecins3 = insertelement <4 x float> %7, float %6, i32 3
  store <4 x float> %vecins3, ptr %r_, align 16
  %8 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %9 = load double, ptr %8, align 16
  %10 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %11 = load double, ptr %10, align 8
  %call = call <4 x float> @simde__m128_from_private(double %9, double %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <4 x float> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal { double, double } @simde__m128_to_private(<4 x float> noundef %v) #4 {
entry:
  %retval = alloca %union.simde__m128_private, align 16
  %v.addr = alloca <4 x float>, align 16
  store <4 x float> %v, ptr %v.addr, align 16, !tbaa !16
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %retval, ptr align 16 %v.addr, i64 16, i1 false)
  %coerce.dive = getelementptr inbounds %union.simde__m128_private, ptr %retval, i32 0, i32 0
  %0 = load { double, double }, ptr %coerce.dive, align 16
  ret { double, double } %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x float> @simde__m128_from_private(double %v.coerce0, double %v.coerce1) #4 {
entry:
  %v = alloca %union.simde__m128_private, align 16
  %r = alloca <4 x float>, align 16
  %0 = getelementptr inbounds { double, double }, ptr %v, i32 0, i32 0
  store double %v.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { double, double }, ptr %v, i32 0, i32 1
  store double %v.coerce1, ptr %1, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #10
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %r, ptr align 16 %v, i64 16, i1 false)
  %2 = load <4 x float>, ptr %r, align 16, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #10
  ret <4 x float> %2
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_x86_assert_equal_f32x4_(<4 x float> noundef %a, <4 x float> noundef %b, float noundef %slop, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #3 {
entry:
  %a.addr = alloca <4 x float>, align 16
  %b.addr = alloca <4 x float>, align 16
  %slop.addr = alloca float, align 4
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %a_ = alloca [4 x float], align 16
  %b_ = alloca [4 x float], align 16
  store <4 x float> %a, ptr %a.addr, align 16, !tbaa !16
  store <4 x float> %b, ptr %b.addr, align 16, !tbaa !16
  store float %slop, ptr %slop.addr, align 4, !tbaa !35
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %arraydecay = getelementptr inbounds [4 x float], ptr %a_, i64 0, i64 0
  %0 = load <4 x float>, ptr %a.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_ps(ptr noundef %arraydecay, <4 x float> noundef %0)
  %arraydecay1 = getelementptr inbounds [4 x float], ptr %b_, i64 0, i64 0
  %1 = load <4 x float>, ptr %b.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_ps(ptr noundef %arraydecay1, <4 x float> noundef %1)
  %arraydecay2 = getelementptr inbounds [4 x float], ptr %a_, i64 0, i64 0
  %arraydecay3 = getelementptr inbounds [4 x float], ptr %b_, i64 0, i64 0
  %2 = load float, ptr %slop.addr, align 4, !tbaa !35
  %3 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %4 = load i32, ptr %line.addr, align 4, !tbaa !5
  %5 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %6 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %call = call i32 @simde_assert_equal_vf32_(i64 noundef 4, ptr noundef %arraydecay2, ptr noundef %arraydecay3, float noundef %2, ptr noundef %3, i32 noundef %4, ptr noundef %5, ptr noundef %6)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal float @simde_test_f32_precision_to_slop(i32 noundef %precision) #0 {
entry:
  %precision.addr = alloca i32, align 4
  store i32 %precision, ptr %precision.addr, align 4, !tbaa !5
  %0 = load i32, ptr %precision.addr, align 4, !tbaa !5
  %cmp = icmp eq i32 %0, 2147483647
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load i32, ptr %precision.addr, align 4, !tbaa !5
  %conv2 = sitofp i32 %1 to float
  %fneg = fneg float %conv2
  %call = call float @powf(float noundef 1.000000e+01, float noundef %fneg) #10
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ 0.000000e+00, %cond.true ], [ %call, %cond.false ]
  ret float %cond
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @simde_mm_storeu_ps(ptr noundef %mem_addr, <4 x float> noundef %a) #4 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %a.addr = alloca <4 x float>, align 16
  %a_ = alloca %union.simde__m128_private, align 16
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  store <4 x float> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <4 x float>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128_to_private(<4 x float> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  %5 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %5, ptr align 16 %a_, i64 16, i1 false)
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_vf32_(i64 noundef %vec_len, ptr noundef %a, ptr noundef %b, float noundef %slop, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %vec_len.addr = alloca i64, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %slop.addr = alloca float, align 4
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i64 %vec_len, ptr %vec_len.addr, align 8, !tbaa !11
  store ptr %a, ptr %a.addr, align 8, !tbaa !9
  store ptr %b, ptr %b.addr, align 8, !tbaa !9
  store float %slop, ptr %slop.addr, align 4, !tbaa !35
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %1 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %3 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds float, ptr %4, i64 %5
  %6 = load float, ptr %arrayidx, align 4, !tbaa !35
  %7 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx1 = getelementptr inbounds float, ptr %7, i64 %8
  %9 = load float, ptr %arrayidx1, align 4, !tbaa !35
  %10 = load float, ptr %slop.addr, align 4, !tbaa !35
  %call = call i32 @simde_test_equal_f32(float noundef %6, float noundef %9, float noundef %10)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %11 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %12 = load i32, ptr %line.addr, align 4, !tbaa !5
  %13 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %14 = load i64, ptr %i, align 8, !tbaa !11
  %15 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %16 = load i64, ptr %i, align 8, !tbaa !11
  %17 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %18 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx5 = getelementptr inbounds float, ptr %17, i64 %18
  %19 = load float, ptr %arrayidx5, align 4, !tbaa !35
  %conv6 = fpext float %19 to double
  %20 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %21 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx7 = getelementptr inbounds float, ptr %20, i64 %21
  %22 = load float, ptr %arrayidx7, align 4, !tbaa !35
  %conv8 = fpext float %22 to double
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.76, ptr noundef %11, i32 noundef %12, ptr noundef %13, i64 noundef %14, ptr noundef %15, i64 noundef %16, double noundef %conv6, double noundef %conv8)
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %23 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %23, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup
  %24 = load i32, ptr %retval, align 4
  ret i32 %24

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_equal_f32(float noundef %a, float noundef %b, float noundef %slop) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca float, align 4
  %b.addr = alloca float, align 4
  %slop.addr = alloca float, align 4
  %lo = alloca float, align 4
  %hi = alloca float, align 4
  store float %a, ptr %a.addr, align 4, !tbaa !35
  store float %b, ptr %b.addr, align 4, !tbaa !35
  store float %slop, ptr %slop.addr, align 4, !tbaa !35
  %0 = load float, ptr %a.addr, align 4, !tbaa !35
  %1 = call i1 @llvm.is.fpclass.f32(float %0, i32 3)
  br i1 %1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load float, ptr %b.addr, align 4, !tbaa !35
  %3 = call i1 @llvm.is.fpclass.f32(float %2, i32 3)
  %4 = zext i1 %3 to i32
  store i32 %4, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %5 = load float, ptr %a.addr, align 4, !tbaa !35
  %6 = call i1 @llvm.is.fpclass.f32(float %5, i32 516)
  br i1 %6, label %if.then1, label %if.else3

if.then1:                                         ; preds = %if.else
  %7 = load float, ptr %a.addr, align 4, !tbaa !35
  %8 = load float, ptr %b.addr, align 4, !tbaa !35
  %cmp = fcmp olt float %7, %8
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then1
  %9 = load float, ptr %a.addr, align 4, !tbaa !35
  %10 = load float, ptr %b.addr, align 4, !tbaa !35
  %cmp2 = fcmp ogt float %9, %10
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then1
  %11 = phi i1 [ true, %if.then1 ], [ %cmp2, %lor.rhs ]
  %lnot = xor i1 %11, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, ptr %retval, align 4
  br label %return

if.else3:                                         ; preds = %if.else
  %12 = load float, ptr %slop.addr, align 4, !tbaa !35
  %cmp4 = fcmp oeq float %12, 0.000000e+00
  br i1 %cmp4, label %if.then5, label %if.else8

if.then5:                                         ; preds = %if.else3
  %call = call i32 @memcmp(ptr noundef %a.addr, ptr noundef %b.addr, i64 noundef 4) #10
  %tobool = icmp ne i32 %call, 0
  %lnot6 = xor i1 %tobool, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  store i32 %lnot.ext7, ptr %retval, align 4
  br label %return

if.else8:                                         ; preds = %if.else3
  call void @llvm.lifetime.start.p0(i64 4, ptr %lo) #10
  %13 = load float, ptr %a.addr, align 4, !tbaa !35
  %14 = load float, ptr %slop.addr, align 4, !tbaa !35
  %sub = fsub float %13, %14
  store float %sub, ptr %lo, align 4, !tbaa !35
  %15 = load float, ptr %lo, align 4, !tbaa !35
  %16 = load float, ptr %a.addr, align 4, !tbaa !35
  %cmp9 = fcmp oeq float %15, %16
  %lnot10 = xor i1 %cmp9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv = sext i32 %lnot.ext13 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool14 = icmp ne i64 %expval, 0
  br i1 %tobool14, label %if.then15, label %if.end

if.then15:                                        ; preds = %if.else8
  %17 = load float, ptr %a.addr, align 4, !tbaa !35
  %call16 = call float @nextafterf(float noundef %17, float noundef 0xFFF0000000000000) #10
  store float %call16, ptr %lo, align 4, !tbaa !35
  br label %if.end

if.end:                                           ; preds = %if.then15, %if.else8
  call void @llvm.lifetime.start.p0(i64 4, ptr %hi) #10
  %18 = load float, ptr %a.addr, align 4, !tbaa !35
  %19 = load float, ptr %slop.addr, align 4, !tbaa !35
  %add = fadd float %18, %19
  store float %add, ptr %hi, align 4, !tbaa !35
  %20 = load float, ptr %hi, align 4, !tbaa !35
  %21 = load float, ptr %a.addr, align 4, !tbaa !35
  %cmp17 = fcmp oeq float %20, %21
  %lnot19 = xor i1 %cmp17, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %expval24 = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool25 = icmp ne i64 %expval24, 0
  br i1 %tobool25, label %if.then26, label %if.end28

if.then26:                                        ; preds = %if.end
  %22 = load float, ptr %a.addr, align 4, !tbaa !35
  %call27 = call float @nextafterf(float noundef %22, float noundef 0x7FF0000000000000) #10
  store float %call27, ptr %hi, align 4, !tbaa !35
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %if.end
  %23 = load float, ptr %b.addr, align 4, !tbaa !35
  %24 = load float, ptr %lo, align 4, !tbaa !35
  %cmp29 = fcmp oge float %23, %24
  br i1 %cmp29, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end28
  %25 = load float, ptr %b.addr, align 4, !tbaa !35
  %26 = load float, ptr %hi, align 4, !tbaa !35
  %cmp31 = fcmp ole float %25, %26
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end28
  %27 = phi i1 [ false, %if.end28 ], [ %cmp31, %land.rhs ]
  %land.ext = zext i1 %27 to i32
  store i32 %land.ext, ptr %retval, align 4
  call void @llvm.lifetime.end.p0(i64 4, ptr %hi) #10
  call void @llvm.lifetime.end.p0(i64 4, ptr %lo) #10
  br label %return

return:                                           ; preds = %land.end, %if.then5, %lor.end, %if.then
  %28 = load i32, ptr %retval, align 4
  ret i32 %28
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i1 @llvm.is.fpclass.f32(float, i32 immarg) #7

; Function Attrs: nounwind
declare float @nextafterf(float noundef, float noundef) #8

; Function Attrs: nounwind
declare float @powf(float noundef, float noundef) #8

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_set_epi8(i8 noundef signext %e15, i8 noundef signext %e14, i8 noundef signext %e13, i8 noundef signext %e12, i8 noundef signext %e11, i8 noundef signext %e10, i8 noundef signext %e9, i8 noundef signext %e8, i8 noundef signext %e7, i8 noundef signext %e6, i8 noundef signext %e5, i8 noundef signext %e4, i8 noundef signext %e3, i8 noundef signext %e2, i8 noundef signext %e1, i8 noundef signext %e0) #4 {
entry:
  %e15.addr = alloca i8, align 1
  %e14.addr = alloca i8, align 1
  %e13.addr = alloca i8, align 1
  %e12.addr = alloca i8, align 1
  %e11.addr = alloca i8, align 1
  %e10.addr = alloca i8, align 1
  %e9.addr = alloca i8, align 1
  %e8.addr = alloca i8, align 1
  %e7.addr = alloca i8, align 1
  %e6.addr = alloca i8, align 1
  %e5.addr = alloca i8, align 1
  %e4.addr = alloca i8, align 1
  %e3.addr = alloca i8, align 1
  %e2.addr = alloca i8, align 1
  %e1.addr = alloca i8, align 1
  %e0.addr = alloca i8, align 1
  %r_ = alloca %union.simde__m128i_private, align 16
  store i8 %e15, ptr %e15.addr, align 1, !tbaa !16
  store i8 %e14, ptr %e14.addr, align 1, !tbaa !16
  store i8 %e13, ptr %e13.addr, align 1, !tbaa !16
  store i8 %e12, ptr %e12.addr, align 1, !tbaa !16
  store i8 %e11, ptr %e11.addr, align 1, !tbaa !16
  store i8 %e10, ptr %e10.addr, align 1, !tbaa !16
  store i8 %e9, ptr %e9.addr, align 1, !tbaa !16
  store i8 %e8, ptr %e8.addr, align 1, !tbaa !16
  store i8 %e7, ptr %e7.addr, align 1, !tbaa !16
  store i8 %e6, ptr %e6.addr, align 1, !tbaa !16
  store i8 %e5, ptr %e5.addr, align 1, !tbaa !16
  store i8 %e4, ptr %e4.addr, align 1, !tbaa !16
  store i8 %e3, ptr %e3.addr, align 1, !tbaa !16
  store i8 %e2, ptr %e2.addr, align 1, !tbaa !16
  store i8 %e1, ptr %e1.addr, align 1, !tbaa !16
  store i8 %e0, ptr %e0.addr, align 1, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  %0 = load i8, ptr %e0.addr, align 1, !tbaa !16
  %1 = load <16 x i8>, ptr %r_, align 16
  %vecins = insertelement <16 x i8> %1, i8 %0, i32 0
  store <16 x i8> %vecins, ptr %r_, align 16
  %2 = load i8, ptr %e1.addr, align 1, !tbaa !16
  %3 = load <16 x i8>, ptr %r_, align 16
  %vecins1 = insertelement <16 x i8> %3, i8 %2, i32 1
  store <16 x i8> %vecins1, ptr %r_, align 16
  %4 = load i8, ptr %e2.addr, align 1, !tbaa !16
  %5 = load <16 x i8>, ptr %r_, align 16
  %vecins2 = insertelement <16 x i8> %5, i8 %4, i32 2
  store <16 x i8> %vecins2, ptr %r_, align 16
  %6 = load i8, ptr %e3.addr, align 1, !tbaa !16
  %7 = load <16 x i8>, ptr %r_, align 16
  %vecins3 = insertelement <16 x i8> %7, i8 %6, i32 3
  store <16 x i8> %vecins3, ptr %r_, align 16
  %8 = load i8, ptr %e4.addr, align 1, !tbaa !16
  %9 = load <16 x i8>, ptr %r_, align 16
  %vecins4 = insertelement <16 x i8> %9, i8 %8, i32 4
  store <16 x i8> %vecins4, ptr %r_, align 16
  %10 = load i8, ptr %e5.addr, align 1, !tbaa !16
  %11 = load <16 x i8>, ptr %r_, align 16
  %vecins5 = insertelement <16 x i8> %11, i8 %10, i32 5
  store <16 x i8> %vecins5, ptr %r_, align 16
  %12 = load i8, ptr %e6.addr, align 1, !tbaa !16
  %13 = load <16 x i8>, ptr %r_, align 16
  %vecins6 = insertelement <16 x i8> %13, i8 %12, i32 6
  store <16 x i8> %vecins6, ptr %r_, align 16
  %14 = load i8, ptr %e7.addr, align 1, !tbaa !16
  %15 = load <16 x i8>, ptr %r_, align 16
  %vecins7 = insertelement <16 x i8> %15, i8 %14, i32 7
  store <16 x i8> %vecins7, ptr %r_, align 16
  %16 = load i8, ptr %e8.addr, align 1, !tbaa !16
  %17 = load <16 x i8>, ptr %r_, align 16
  %vecins8 = insertelement <16 x i8> %17, i8 %16, i32 8
  store <16 x i8> %vecins8, ptr %r_, align 16
  %18 = load i8, ptr %e9.addr, align 1, !tbaa !16
  %19 = load <16 x i8>, ptr %r_, align 16
  %vecins9 = insertelement <16 x i8> %19, i8 %18, i32 9
  store <16 x i8> %vecins9, ptr %r_, align 16
  %20 = load i8, ptr %e10.addr, align 1, !tbaa !16
  %21 = load <16 x i8>, ptr %r_, align 16
  %vecins10 = insertelement <16 x i8> %21, i8 %20, i32 10
  store <16 x i8> %vecins10, ptr %r_, align 16
  %22 = load i8, ptr %e11.addr, align 1, !tbaa !16
  %23 = load <16 x i8>, ptr %r_, align 16
  %vecins11 = insertelement <16 x i8> %23, i8 %22, i32 11
  store <16 x i8> %vecins11, ptr %r_, align 16
  %24 = load i8, ptr %e12.addr, align 1, !tbaa !16
  %25 = load <16 x i8>, ptr %r_, align 16
  %vecins12 = insertelement <16 x i8> %25, i8 %24, i32 12
  store <16 x i8> %vecins12, ptr %r_, align 16
  %26 = load i8, ptr %e13.addr, align 1, !tbaa !16
  %27 = load <16 x i8>, ptr %r_, align 16
  %vecins13 = insertelement <16 x i8> %27, i8 %26, i32 13
  store <16 x i8> %vecins13, ptr %r_, align 16
  %28 = load i8, ptr %e14.addr, align 1, !tbaa !16
  %29 = load <16 x i8>, ptr %r_, align 16
  %vecins14 = insertelement <16 x i8> %29, i8 %28, i32 14
  store <16 x i8> %vecins14, ptr %r_, align 16
  %30 = load i8, ptr %e15.addr, align 1, !tbaa !16
  %31 = load <16 x i8>, ptr %r_, align 16
  %vecins15 = insertelement <16 x i8> %31, i8 %30, i32 15
  store <16 x i8> %vecins15, ptr %r_, align 16
  %32 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %33 = load double, ptr %32, align 16
  %34 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %35 = load double, ptr %34, align 8
  %call = call <2 x i64> @simde__m128i_from_private(double %33, double %35)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_blendv_epi8(<2 x i64> noundef %a, <2 x i64> noundef %b, <2 x i64> noundef %mask) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %mask.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %mask_ = alloca %union.simde__m128i_private, align 16
  %z = alloca <16 x i8>, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  store <2 x i64> %mask, ptr %mask.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %mask_) #10
  %10 = load <2 x i64>, ptr %mask.addr, align 16, !tbaa !16
  %call3 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %10)
  %coerce.dive4 = getelementptr inbounds %union.simde__m128i_private, ptr %mask_, i32 0, i32 0
  %11 = getelementptr inbounds { double, double }, ptr %coerce.dive4, i32 0, i32 0
  %12 = extractvalue { double, double } %call3, 0
  store double %12, ptr %11, align 16
  %13 = getelementptr inbounds { double, double }, ptr %coerce.dive4, i32 0, i32 1
  %14 = extractvalue { double, double } %call3, 1
  store double %14, ptr %13, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %z) #10
  store <16 x i8> zeroinitializer, ptr %z, align 16, !tbaa !16
  %15 = load <16 x i8>, ptr %mask_, align 16, !tbaa !16
  %16 = load <16 x i8>, ptr %z, align 16, !tbaa !16
  %cmp = icmp slt <16 x i8> %15, %16
  %sext = sext <16 x i1> %cmp to <16 x i8>
  store <16 x i8> %sext, ptr %mask_, align 16, !tbaa !16
  %17 = load <16 x i8>, ptr %mask_, align 16, !tbaa !16
  %18 = load <16 x i8>, ptr %b_, align 16, !tbaa !16
  %and = and <16 x i8> %17, %18
  %19 = load <16 x i8>, ptr %mask_, align 16, !tbaa !16
  %not = xor <16 x i8> %19, <i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1>
  %20 = load <16 x i8>, ptr %a_, align 16, !tbaa !16
  %and5 = and <16 x i8> %not, %20
  %or = or <16 x i8> %and, %and5
  store <16 x i8> %or, ptr %r_, align 16, !tbaa !16
  %21 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %22 = load double, ptr %21, align 16
  %23 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %24 = load double, ptr %23, align 8
  %call6 = call <2 x i64> @simde__m128i_from_private(double %22, double %24)
  call void @llvm.lifetime.end.p0(i64 16, ptr %z) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %mask_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call6
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_x86_assert_equal_i8x16_(<2 x i64> noundef %a, <2 x i64> noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #3 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %a_ = alloca [16 x i8], align 16
  %b_ = alloca [16 x i8], align 16
  %simde_r_ = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %simde_r_1 = alloca ptr, align 8
  %tmp3 = alloca ptr, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_) #10
  %arraydecay = getelementptr inbounds [16 x i8], ptr %a_, i64 0, i64 0
  store ptr %arraydecay, ptr %simde_r_, align 8, !tbaa !9
  %0 = load ptr, ptr %simde_r_, align 8, !tbaa !9
  store ptr %0, ptr %tmp, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_) #10
  %1 = load ptr, ptr %tmp, align 8, !tbaa !9
  %2 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_si128(ptr noundef %1, <2 x i64> noundef %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_1) #10
  %arraydecay2 = getelementptr inbounds [16 x i8], ptr %b_, i64 0, i64 0
  store ptr %arraydecay2, ptr %simde_r_1, align 8, !tbaa !9
  %3 = load ptr, ptr %simde_r_1, align 8, !tbaa !9
  store ptr %3, ptr %tmp3, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_1) #10
  %4 = load ptr, ptr %tmp3, align 8, !tbaa !9
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_si128(ptr noundef %4, <2 x i64> noundef %5)
  %arraydecay4 = getelementptr inbounds [16 x i8], ptr %a_, i64 0, i64 0
  %arraydecay5 = getelementptr inbounds [16 x i8], ptr %b_, i64 0, i64 0
  %6 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %7 = load i32, ptr %line.addr, align 4, !tbaa !5
  %8 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %9 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %call = call i32 @simde_assert_equal_vi8_(i64 noundef 16, ptr noundef %arraydecay4, ptr noundef %arraydecay5, ptr noundef %6, i32 noundef %7, ptr noundef %8, ptr noundef %9)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_vi8_(i64 noundef %vec_len, ptr noundef %a, ptr noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %vec_len.addr = alloca i64, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i64 %vec_len, ptr %vec_len.addr, align 8, !tbaa !11
  store ptr %a, ptr %a.addr, align 8, !tbaa !9
  store ptr %b, ptr %b.addr, align 8, !tbaa !9
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %1 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %3 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds i8, ptr %4, i64 %5
  %6 = load i8, ptr %arrayidx, align 1, !tbaa !16
  %conv = sext i8 %6 to i32
  %7 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx1 = getelementptr inbounds i8, ptr %7, i64 %8
  %9 = load i8, ptr %arrayidx1, align 1, !tbaa !16
  %conv2 = sext i8 %9 to i32
  %cmp3 = icmp ne i32 %conv, %conv2
  %lnot = xor i1 %cmp3, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %10 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %11 = load i32, ptr %line.addr, align 4, !tbaa !5
  %12 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %13 = load i64, ptr %i, align 8, !tbaa !11
  %14 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %15 = load i64, ptr %i, align 8, !tbaa !11
  %16 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %17 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx7 = getelementptr inbounds i8, ptr %16, i64 %17
  %18 = load i8, ptr %arrayidx7, align 1, !tbaa !16
  %conv8 = sext i8 %18 to i32
  %19 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %20 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx9 = getelementptr inbounds i8, ptr %19, i64 %20
  %21 = load i8, ptr %arrayidx9, align 1, !tbaa !16
  %conv10 = sext i8 %21 to i32
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.75, ptr noundef %10, i32 noundef %11, ptr noundef %12, i64 noundef %13, ptr noundef %14, i64 noundef %15, i32 noundef %conv8, i32 noundef %conv10)
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %22 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %22, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup
  %23 = load i32, ptr %retval, align 4
  ret i32 %23

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_x_mm_blendv_epi16(<2 x i64> noundef %a, <2 x i64> noundef %b, <2 x i64> noundef %mask) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %mask.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %mask_ = alloca %union.simde__m128i_private, align 16
  %z = alloca <8 x i16>, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  store <2 x i64> %mask, ptr %mask.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %mask_) #10
  %10 = load <2 x i64>, ptr %mask.addr, align 16, !tbaa !16
  %call3 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %10)
  %coerce.dive4 = getelementptr inbounds %union.simde__m128i_private, ptr %mask_, i32 0, i32 0
  %11 = getelementptr inbounds { double, double }, ptr %coerce.dive4, i32 0, i32 0
  %12 = extractvalue { double, double } %call3, 0
  store double %12, ptr %11, align 16
  %13 = getelementptr inbounds { double, double }, ptr %coerce.dive4, i32 0, i32 1
  %14 = extractvalue { double, double } %call3, 1
  store double %14, ptr %13, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %z) #10
  store <8 x i16> zeroinitializer, ptr %z, align 16, !tbaa !16
  %15 = load <8 x i16>, ptr %mask_, align 16, !tbaa !16
  %16 = load <8 x i16>, ptr %z, align 16, !tbaa !16
  %cmp = icmp slt <8 x i16> %15, %16
  %sext = sext <8 x i1> %cmp to <8 x i16>
  store <8 x i16> %sext, ptr %mask_, align 16, !tbaa !16
  %17 = load <8 x i16>, ptr %mask_, align 16, !tbaa !16
  %18 = load <8 x i16>, ptr %b_, align 16, !tbaa !16
  %and = and <8 x i16> %17, %18
  %19 = load <8 x i16>, ptr %mask_, align 16, !tbaa !16
  %not = xor <8 x i16> %19, <i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1>
  %20 = load <8 x i16>, ptr %a_, align 16, !tbaa !16
  %and5 = and <8 x i16> %not, %20
  %or = or <8 x i16> %and, %and5
  store <8 x i16> %or, ptr %r_, align 16, !tbaa !16
  %21 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %22 = load double, ptr %21, align 16
  %23 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %24 = load double, ptr %23, align 8
  %call6 = call <2 x i64> @simde__m128i_from_private(double %22, double %24)
  call void @llvm.lifetime.end.p0(i64 16, ptr %z) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %mask_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call6
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_set_epi32(i32 noundef %e3, i32 noundef %e2, i32 noundef %e1, i32 noundef %e0) #4 {
entry:
  %e3.addr = alloca i32, align 4
  %e2.addr = alloca i32, align 4
  %e1.addr = alloca i32, align 4
  %e0.addr = alloca i32, align 4
  %r_ = alloca %union.simde__m128i_private, align 16
  store i32 %e3, ptr %e3.addr, align 4, !tbaa !5
  store i32 %e2, ptr %e2.addr, align 4, !tbaa !5
  store i32 %e1, ptr %e1.addr, align 4, !tbaa !5
  store i32 %e0, ptr %e0.addr, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  %0 = load i32, ptr %e0.addr, align 4, !tbaa !5
  %1 = load <4 x i32>, ptr %r_, align 16
  %vecins = insertelement <4 x i32> %1, i32 %0, i32 0
  store <4 x i32> %vecins, ptr %r_, align 16
  %2 = load i32, ptr %e1.addr, align 4, !tbaa !5
  %3 = load <4 x i32>, ptr %r_, align 16
  %vecins1 = insertelement <4 x i32> %3, i32 %2, i32 1
  store <4 x i32> %vecins1, ptr %r_, align 16
  %4 = load i32, ptr %e2.addr, align 4, !tbaa !5
  %5 = load <4 x i32>, ptr %r_, align 16
  %vecins2 = insertelement <4 x i32> %5, i32 %4, i32 2
  store <4 x i32> %vecins2, ptr %r_, align 16
  %6 = load i32, ptr %e3.addr, align 4, !tbaa !5
  %7 = load <4 x i32>, ptr %r_, align 16
  %vecins3 = insertelement <4 x i32> %7, i32 %6, i32 3
  store <4 x i32> %vecins3, ptr %r_, align 16
  %8 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %9 = load double, ptr %8, align 16
  %10 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %11 = load double, ptr %10, align 8
  %call = call <2 x i64> @simde__m128i_from_private(double %9, double %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_x_mm_blendv_epi32(<2 x i64> noundef %a, <2 x i64> noundef %b, <2 x i64> noundef %mask) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %mask.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %mask_ = alloca %union.simde__m128i_private, align 16
  %z = alloca <4 x i32>, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  store <2 x i64> %mask, ptr %mask.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %mask_) #10
  %10 = load <2 x i64>, ptr %mask.addr, align 16, !tbaa !16
  %call3 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %10)
  %coerce.dive4 = getelementptr inbounds %union.simde__m128i_private, ptr %mask_, i32 0, i32 0
  %11 = getelementptr inbounds { double, double }, ptr %coerce.dive4, i32 0, i32 0
  %12 = extractvalue { double, double } %call3, 0
  store double %12, ptr %11, align 16
  %13 = getelementptr inbounds { double, double }, ptr %coerce.dive4, i32 0, i32 1
  %14 = extractvalue { double, double } %call3, 1
  store double %14, ptr %13, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %z) #10
  store <4 x i32> zeroinitializer, ptr %z, align 16, !tbaa !16
  %15 = load <4 x i32>, ptr %mask_, align 16, !tbaa !16
  %16 = load <4 x i32>, ptr %z, align 16, !tbaa !16
  %cmp = icmp slt <4 x i32> %15, %16
  %sext = sext <4 x i1> %cmp to <4 x i32>
  store <4 x i32> %sext, ptr %mask_, align 16, !tbaa !16
  %17 = load <4 x i32>, ptr %mask_, align 16, !tbaa !16
  %18 = load <4 x i32>, ptr %b_, align 16, !tbaa !16
  %and = and <4 x i32> %17, %18
  %19 = load <4 x i32>, ptr %mask_, align 16, !tbaa !16
  %not = xor <4 x i32> %19, <i32 -1, i32 -1, i32 -1, i32 -1>
  %20 = load <4 x i32>, ptr %a_, align 16, !tbaa !16
  %and5 = and <4 x i32> %not, %20
  %or = or <4 x i32> %and, %and5
  store <4 x i32> %or, ptr %r_, align 16, !tbaa !16
  %21 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %22 = load double, ptr %21, align 16
  %23 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %24 = load double, ptr %23, align 8
  %call6 = call <2 x i64> @simde__m128i_from_private(double %22, double %24)
  call void @llvm.lifetime.end.p0(i64 16, ptr %z) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %mask_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call6
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_x86_assert_equal_i32x4_(<2 x i64> noundef %a, <2 x i64> noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #3 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %a_ = alloca [4 x i32], align 16
  %b_ = alloca [4 x i32], align 16
  %simde_r_ = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %simde_r_1 = alloca ptr, align 8
  %tmp3 = alloca ptr, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_) #10
  %arraydecay = getelementptr inbounds [4 x i32], ptr %a_, i64 0, i64 0
  store ptr %arraydecay, ptr %simde_r_, align 8, !tbaa !9
  %0 = load ptr, ptr %simde_r_, align 8, !tbaa !9
  store ptr %0, ptr %tmp, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_) #10
  %1 = load ptr, ptr %tmp, align 8, !tbaa !9
  %2 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_si128(ptr noundef %1, <2 x i64> noundef %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_1) #10
  %arraydecay2 = getelementptr inbounds [4 x i32], ptr %b_, i64 0, i64 0
  store ptr %arraydecay2, ptr %simde_r_1, align 8, !tbaa !9
  %3 = load ptr, ptr %simde_r_1, align 8, !tbaa !9
  store ptr %3, ptr %tmp3, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_1) #10
  %4 = load ptr, ptr %tmp3, align 8, !tbaa !9
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_si128(ptr noundef %4, <2 x i64> noundef %5)
  %arraydecay4 = getelementptr inbounds [4 x i32], ptr %a_, i64 0, i64 0
  %arraydecay5 = getelementptr inbounds [4 x i32], ptr %b_, i64 0, i64 0
  %6 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %7 = load i32, ptr %line.addr, align 4, !tbaa !5
  %8 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %9 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %call = call i32 @simde_assert_equal_vi32_(i64 noundef 4, ptr noundef %arraydecay4, ptr noundef %arraydecay5, ptr noundef %6, i32 noundef %7, ptr noundef %8, ptr noundef %9)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_vi32_(i64 noundef %vec_len, ptr noundef %a, ptr noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %vec_len.addr = alloca i64, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i64 %vec_len, ptr %vec_len.addr, align 8, !tbaa !11
  store ptr %a, ptr %a.addr, align 8, !tbaa !9
  store ptr %b, ptr %b.addr, align 8, !tbaa !9
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %1 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %3 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds i32, ptr %4, i64 %5
  %6 = load i32, ptr %arrayidx, align 4, !tbaa !5
  %7 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx1 = getelementptr inbounds i32, ptr %7, i64 %8
  %9 = load i32, ptr %arrayidx1, align 4, !tbaa !5
  %cmp2 = icmp ne i32 %6, %9
  %lnot = xor i1 %cmp2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %10 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %11 = load i32, ptr %line.addr, align 4, !tbaa !5
  %12 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %13 = load i64, ptr %i, align 8, !tbaa !11
  %14 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %15 = load i64, ptr %i, align 8, !tbaa !11
  %16 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %17 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx4 = getelementptr inbounds i32, ptr %16, i64 %17
  %18 = load i32, ptr %arrayidx4, align 4, !tbaa !5
  %19 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %20 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx5 = getelementptr inbounds i32, ptr %19, i64 %20
  %21 = load i32, ptr %arrayidx5, align 4, !tbaa !5
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.75, ptr noundef %10, i32 noundef %11, ptr noundef %12, i64 noundef %13, ptr noundef %14, i64 noundef %15, i32 noundef %18, i32 noundef %21)
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %22 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %22, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup
  %23 = load i32, ptr %retval, align 4
  ret i32 %23

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_set_epi64x(i64 noundef %e1, i64 noundef %e0) #4 {
entry:
  %e1.addr = alloca i64, align 8
  %e0.addr = alloca i64, align 8
  %r_ = alloca %union.simde__m128i_private, align 16
  store i64 %e1, ptr %e1.addr, align 8, !tbaa !11
  store i64 %e0, ptr %e0.addr, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  %0 = load i64, ptr %e0.addr, align 8, !tbaa !11
  %1 = load <2 x i64>, ptr %r_, align 16
  %vecins = insertelement <2 x i64> %1, i64 %0, i32 0
  store <2 x i64> %vecins, ptr %r_, align 16
  %2 = load i64, ptr %e1.addr, align 8, !tbaa !11
  %3 = load <2 x i64>, ptr %r_, align 16
  %vecins1 = insertelement <2 x i64> %3, i64 %2, i32 1
  store <2 x i64> %vecins1, ptr %r_, align 16
  %4 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %5 = load double, ptr %4, align 16
  %6 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %7 = load double, ptr %6, align 8
  %call = call <2 x i64> @simde__m128i_from_private(double %5, double %7)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_x_mm_blendv_epi64(<2 x i64> noundef %a, <2 x i64> noundef %b, <2 x i64> noundef %mask) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %mask.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %mask_ = alloca %union.simde__m128i_private, align 16
  %z = alloca <2 x i64>, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  store <2 x i64> %mask, ptr %mask.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %mask_) #10
  %10 = load <2 x i64>, ptr %mask.addr, align 16, !tbaa !16
  %call3 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %10)
  %coerce.dive4 = getelementptr inbounds %union.simde__m128i_private, ptr %mask_, i32 0, i32 0
  %11 = getelementptr inbounds { double, double }, ptr %coerce.dive4, i32 0, i32 0
  %12 = extractvalue { double, double } %call3, 0
  store double %12, ptr %11, align 16
  %13 = getelementptr inbounds { double, double }, ptr %coerce.dive4, i32 0, i32 1
  %14 = extractvalue { double, double } %call3, 1
  store double %14, ptr %13, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %z) #10
  store <2 x i64> zeroinitializer, ptr %z, align 16, !tbaa !16
  %15 = load <2 x i64>, ptr %mask_, align 16, !tbaa !16
  %16 = load <2 x i64>, ptr %z, align 16, !tbaa !16
  %cmp = icmp slt <2 x i64> %15, %16
  %sext = sext <2 x i1> %cmp to <2 x i64>
  store <2 x i64> %sext, ptr %mask_, align 16, !tbaa !16
  %17 = load <2 x i64>, ptr %mask_, align 16, !tbaa !16
  %18 = load <2 x i64>, ptr %b_, align 16, !tbaa !16
  %and = and <2 x i64> %17, %18
  %19 = load <2 x i64>, ptr %mask_, align 16, !tbaa !16
  %not = xor <2 x i64> %19, <i64 -1, i64 -1>
  %20 = load <2 x i64>, ptr %a_, align 16, !tbaa !16
  %and5 = and <2 x i64> %not, %20
  %or = or <2 x i64> %and, %and5
  store <2 x i64> %or, ptr %r_, align 16, !tbaa !16
  %21 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %22 = load double, ptr %21, align 16
  %23 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %24 = load double, ptr %23, align 8
  %call6 = call <2 x i64> @simde__m128i_from_private(double %22, double %24)
  call void @llvm.lifetime.end.p0(i64 16, ptr %z) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %mask_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call6
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_x86_assert_equal_i64x2_(<2 x i64> noundef %a, <2 x i64> noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #3 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %a_ = alloca [2 x i64], align 16
  %b_ = alloca [2 x i64], align 16
  %simde_r_ = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %simde_r_1 = alloca ptr, align 8
  %tmp3 = alloca ptr, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_) #10
  %arraydecay = getelementptr inbounds [2 x i64], ptr %a_, i64 0, i64 0
  store ptr %arraydecay, ptr %simde_r_, align 8, !tbaa !9
  %0 = load ptr, ptr %simde_r_, align 8, !tbaa !9
  store ptr %0, ptr %tmp, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_) #10
  %1 = load ptr, ptr %tmp, align 8, !tbaa !9
  %2 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_si128(ptr noundef %1, <2 x i64> noundef %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_1) #10
  %arraydecay2 = getelementptr inbounds [2 x i64], ptr %b_, i64 0, i64 0
  store ptr %arraydecay2, ptr %simde_r_1, align 8, !tbaa !9
  %3 = load ptr, ptr %simde_r_1, align 8, !tbaa !9
  store ptr %3, ptr %tmp3, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_1) #10
  %4 = load ptr, ptr %tmp3, align 8, !tbaa !9
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_si128(ptr noundef %4, <2 x i64> noundef %5)
  %arraydecay4 = getelementptr inbounds [2 x i64], ptr %a_, i64 0, i64 0
  %arraydecay5 = getelementptr inbounds [2 x i64], ptr %b_, i64 0, i64 0
  %6 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %7 = load i32, ptr %line.addr, align 4, !tbaa !5
  %8 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %9 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %call = call i32 @simde_assert_equal_vi64_(i64 noundef 2, ptr noundef %arraydecay4, ptr noundef %arraydecay5, ptr noundef %6, i32 noundef %7, ptr noundef %8, ptr noundef %9)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_vi64_(i64 noundef %vec_len, ptr noundef %a, ptr noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %vec_len.addr = alloca i64, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i64 %vec_len, ptr %vec_len.addr, align 8, !tbaa !11
  store ptr %a, ptr %a.addr, align 8, !tbaa !9
  store ptr %b, ptr %b.addr, align 8, !tbaa !9
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %1 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %3 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds i64, ptr %4, i64 %5
  %6 = load i64, ptr %arrayidx, align 8, !tbaa !11
  %7 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx1 = getelementptr inbounds i64, ptr %7, i64 %8
  %9 = load i64, ptr %arrayidx1, align 8, !tbaa !11
  %cmp2 = icmp ne i64 %6, %9
  %lnot = xor i1 %cmp2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %10 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %11 = load i32, ptr %line.addr, align 4, !tbaa !5
  %12 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %13 = load i64, ptr %i, align 8, !tbaa !11
  %14 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %15 = load i64, ptr %i, align 8, !tbaa !11
  %16 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %17 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx4 = getelementptr inbounds i64, ptr %16, i64 %17
  %18 = load i64, ptr %arrayidx4, align 8, !tbaa !11
  %19 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %20 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx5 = getelementptr inbounds i64, ptr %19, i64 %20
  %21 = load i64, ptr %arrayidx5, align 8, !tbaa !11
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.77, ptr noundef %10, i32 noundef %11, ptr noundef %12, i64 noundef %13, ptr noundef %14, i64 noundef %15, i64 noundef %18, i64 noundef %21)
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %22 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %22, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup
  %23 = load i32, ptr %retval, align 4
  ret i32 %23

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_x_mm_set_epu64x(i64 noundef %e1, i64 noundef %e0) #4 {
entry:
  %e1.addr = alloca i64, align 8
  %e0.addr = alloca i64, align 8
  %r_ = alloca %union.simde__m128i_private, align 16
  store i64 %e1, ptr %e1.addr, align 8, !tbaa !11
  store i64 %e0, ptr %e0.addr, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  %0 = load i64, ptr %e0.addr, align 8, !tbaa !11
  %1 = load <2 x i64>, ptr %r_, align 16
  %vecins = insertelement <2 x i64> %1, i64 %0, i32 0
  store <2 x i64> %vecins, ptr %r_, align 16
  %2 = load i64, ptr %e1.addr, align 8, !tbaa !11
  %3 = load <2 x i64>, ptr %r_, align 16
  %vecins1 = insertelement <2 x i64> %3, i64 %2, i32 1
  store <2 x i64> %vecins1, ptr %r_, align 16
  %4 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %5 = load double, ptr %4, align 16
  %6 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %7 = load double, ptr %6, align 8
  %call = call <2 x i64> @simde__m128i_from_private(double %5, double %7)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x double> @simde_mm_blendv_pd(<2 x double> noundef %a, <2 x double> noundef %b, <2 x double> noundef %mask) #4 {
entry:
  %a.addr = alloca <2 x double>, align 16
  %b.addr = alloca <2 x double>, align 16
  %mask.addr = alloca <2 x double>, align 16
  store <2 x double> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x double> %b, ptr %b.addr, align 16, !tbaa !16
  store <2 x double> %mask, ptr %mask.addr, align 16, !tbaa !16
  %0 = load <2 x double>, ptr %a.addr, align 16, !tbaa !16
  %call = call <2 x i64> @simde_mm_castpd_si128(<2 x double> noundef %0)
  %1 = load <2 x double>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call <2 x i64> @simde_mm_castpd_si128(<2 x double> noundef %1)
  %2 = load <2 x double>, ptr %mask.addr, align 16, !tbaa !16
  %call2 = call <2 x i64> @simde_mm_castpd_si128(<2 x double> noundef %2)
  %call3 = call <2 x i64> @simde_x_mm_blendv_epi64(<2 x i64> noundef %call, <2 x i64> noundef %call1, <2 x i64> noundef %call2)
  %call4 = call <2 x double> @simde_mm_castsi128_pd(<2 x i64> noundef %call3)
  ret <2 x double> %call4
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x double> @simde_mm_castsi128_pd(<2 x i64> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %r = alloca <2 x double>, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #10
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %r, ptr align 16 %a.addr, i64 16, i1 false)
  %0 = load <2 x double>, ptr %r, align 16, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #10
  ret <2 x double> %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_castpd_si128(<2 x double> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x double>, align 16
  %r = alloca <2 x i64>, align 16
  store <2 x double> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #10
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %r, ptr align 16 %a.addr, i64 16, i1 false)
  %0 = load <2 x i64>, ptr %r, align 16, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #10
  ret <2 x i64> %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_x_mm_set_epu32(i32 noundef %e3, i32 noundef %e2, i32 noundef %e1, i32 noundef %e0) #4 {
entry:
  %e3.addr = alloca i32, align 4
  %e2.addr = alloca i32, align 4
  %e1.addr = alloca i32, align 4
  %e0.addr = alloca i32, align 4
  %r_ = alloca %union.simde__m128i_private, align 16
  store i32 %e3, ptr %e3.addr, align 4, !tbaa !5
  store i32 %e2, ptr %e2.addr, align 4, !tbaa !5
  store i32 %e1, ptr %e1.addr, align 4, !tbaa !5
  store i32 %e0, ptr %e0.addr, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  %0 = load i32, ptr %e0.addr, align 4, !tbaa !5
  %1 = load <4 x i32>, ptr %r_, align 16
  %vecins = insertelement <4 x i32> %1, i32 %0, i32 0
  store <4 x i32> %vecins, ptr %r_, align 16
  %2 = load i32, ptr %e1.addr, align 4, !tbaa !5
  %3 = load <4 x i32>, ptr %r_, align 16
  %vecins1 = insertelement <4 x i32> %3, i32 %2, i32 1
  store <4 x i32> %vecins1, ptr %r_, align 16
  %4 = load i32, ptr %e2.addr, align 4, !tbaa !5
  %5 = load <4 x i32>, ptr %r_, align 16
  %vecins2 = insertelement <4 x i32> %5, i32 %4, i32 2
  store <4 x i32> %vecins2, ptr %r_, align 16
  %6 = load i32, ptr %e3.addr, align 4, !tbaa !5
  %7 = load <4 x i32>, ptr %r_, align 16
  %vecins3 = insertelement <4 x i32> %7, i32 %6, i32 3
  store <4 x i32> %vecins3, ptr %r_, align 16
  %8 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %9 = load double, ptr %8, align 16
  %10 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %11 = load double, ptr %10, align 8
  %call = call <2 x i64> @simde__m128i_from_private(double %9, double %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x float> @simde_mm_blendv_ps(<4 x float> noundef %a, <4 x float> noundef %b, <4 x float> noundef %mask) #4 {
entry:
  %a.addr = alloca <4 x float>, align 16
  %b.addr = alloca <4 x float>, align 16
  %mask.addr = alloca <4 x float>, align 16
  store <4 x float> %a, ptr %a.addr, align 16, !tbaa !16
  store <4 x float> %b, ptr %b.addr, align 16, !tbaa !16
  store <4 x float> %mask, ptr %mask.addr, align 16, !tbaa !16
  %0 = load <4 x float>, ptr %a.addr, align 16, !tbaa !16
  %call = call <2 x i64> @simde_mm_castps_si128(<4 x float> noundef %0)
  %1 = load <4 x float>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call <2 x i64> @simde_mm_castps_si128(<4 x float> noundef %1)
  %2 = load <4 x float>, ptr %mask.addr, align 16, !tbaa !16
  %call2 = call <2 x i64> @simde_mm_castps_si128(<4 x float> noundef %2)
  %call3 = call <2 x i64> @simde_x_mm_blendv_epi32(<2 x i64> noundef %call, <2 x i64> noundef %call1, <2 x i64> noundef %call2)
  %call4 = call <4 x float> @simde_mm_castsi128_ps(<2 x i64> noundef %call3)
  ret <4 x float> %call4
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x float> @simde_mm_castsi128_ps(<2 x i64> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %r = alloca <4 x float>, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #10
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %r, ptr align 16 %a.addr, i64 16, i1 false)
  %0 = load <4 x float>, ptr %r, align 16, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #10
  ret <4 x float> %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_castps_si128(<4 x float> noundef %a) #4 {
entry:
  %a.addr = alloca <4 x float>, align 16
  %r = alloca <2 x i64>, align 16
  store <4 x float> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #10
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %r, ptr align 16 %a.addr, i64 16, i1 false)
  %0 = load <2 x i64>, ptr %r, align 16, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #10
  ret <2 x i64> %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x double> @simde_mm_ceil_pd(<2 x double> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x double>, align 16
  store <2 x double> %a, ptr %a.addr, align 16, !tbaa !16
  %0 = load <2 x double>, ptr %a.addr, align 16, !tbaa !16
  %call = call <2 x double> @simde_mm_round_pd(<2 x double> noundef %0, i32 noundef 2)
  ret <2 x double> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x double> @simde_mm_round_pd(<2 x double> noundef %a, i32 noundef %rounding) #4 {
entry:
  %a.addr = alloca <2 x double>, align 16
  %rounding.addr = alloca i32, align 4
  %r_ = alloca %union.simde__m128d_private, align 16
  %a_ = alloca %union.simde__m128d_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  %tmp3 = alloca i64, align 8
  %.omp.iv4 = alloca i64, align 8
  %i5 = alloca i64, align 8
  %tmp19 = alloca i64, align 8
  %.omp.iv20 = alloca i64, align 8
  %i21 = alloca i64, align 8
  %tmp35 = alloca i64, align 8
  %.omp.iv36 = alloca i64, align 8
  %i37 = alloca i64, align 8
  %tmp51 = alloca i64, align 8
  %.omp.iv52 = alloca i64, align 8
  %i53 = alloca i64, align 8
  store <2 x double> %a, ptr %a.addr, align 16, !tbaa !16
  store i32 %rounding, ptr %rounding.addr, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x double>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128d_to_private(<2 x double> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128d_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  %5 = load i32, ptr %rounding.addr, align 4, !tbaa !5
  %and = and i32 %5, -9
  switch i32 %and, label %sw.default [
    i32 4, label %sw.bb
    i32 0, label %sw.bb2
    i32 1, label %sw.bb18
    i32 2, label %sw.bb34
    i32 3, label %sw.bb50
  ]

sw.bb:                                            ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %sw.bb
  %6 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !37
  %cmp = icmp ult i64 %6, 2
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %7 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !37
  %mul = mul i64 %7, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !37
  %8 = load <2 x double>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !37
  %9 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !37
  %vecext = extractelement <2 x double> %8, i64 %9
  %10 = call double @llvm.nearbyint.f64(double %vecext)
  %11 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !37
  %12 = load <2 x double>, ptr %r_, align 16, !llvm.access.group !37
  %vecins = insertelement <2 x double> %12, double %10, i64 %11
  store <2 x double> %vecins, ptr %r_, align 16, !llvm.access.group !37
  br label %omp.body.continue

omp.body.continue:                                ; preds = %omp.inner.for.body
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %13 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !37
  %add1 = add i64 %13, 1
  store i64 %add1, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !37
  br label %omp.inner.for.cond, !llvm.loop !38

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 2, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv4) #10
  store i64 0, ptr %.omp.iv4, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i5) #10
  br label %omp.inner.for.cond6

omp.inner.for.cond6:                              ; preds = %omp.inner.for.inc15, %sw.bb2
  %14 = load i64, ptr %.omp.iv4, align 8, !tbaa !11, !llvm.access.group !41
  %cmp7 = icmp ult i64 %14, 2
  br i1 %cmp7, label %omp.inner.for.body9, label %omp.inner.for.cond.cleanup8

omp.inner.for.cond.cleanup8:                      ; preds = %omp.inner.for.cond6
  br label %omp.inner.for.end17

omp.inner.for.body9:                              ; preds = %omp.inner.for.cond6
  %15 = load i64, ptr %.omp.iv4, align 8, !tbaa !11, !llvm.access.group !41
  %mul10 = mul i64 %15, 1
  %add11 = add i64 0, %mul10
  store i64 %add11, ptr %i5, align 8, !tbaa !11, !llvm.access.group !41
  %16 = load <2 x double>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !41
  %17 = load i64, ptr %i5, align 8, !tbaa !11, !llvm.access.group !41
  %vecext12 = extractelement <2 x double> %16, i64 %17
  %18 = call double @llvm.roundeven.f64(double %vecext12)
  %19 = load i64, ptr %i5, align 8, !tbaa !11, !llvm.access.group !41
  %20 = load <2 x double>, ptr %r_, align 16, !llvm.access.group !41
  %vecins13 = insertelement <2 x double> %20, double %18, i64 %19
  store <2 x double> %vecins13, ptr %r_, align 16, !llvm.access.group !41
  br label %omp.body.continue14

omp.body.continue14:                              ; preds = %omp.inner.for.body9
  br label %omp.inner.for.inc15

omp.inner.for.inc15:                              ; preds = %omp.body.continue14
  %21 = load i64, ptr %.omp.iv4, align 8, !tbaa !11, !llvm.access.group !41
  %add16 = add i64 %21, 1
  store i64 %add16, ptr %.omp.iv4, align 8, !tbaa !11, !llvm.access.group !41
  br label %omp.inner.for.cond6, !llvm.loop !42

omp.inner.for.end17:                              ; preds = %omp.inner.for.cond.cleanup8
  store i64 2, ptr %i5, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i5) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv4) #10
  br label %sw.epilog

sw.bb18:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv20) #10
  store i64 0, ptr %.omp.iv20, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i21) #10
  br label %omp.inner.for.cond22

omp.inner.for.cond22:                             ; preds = %omp.inner.for.inc31, %sw.bb18
  %22 = load i64, ptr %.omp.iv20, align 8, !tbaa !11, !llvm.access.group !44
  %cmp23 = icmp ult i64 %22, 2
  br i1 %cmp23, label %omp.inner.for.body25, label %omp.inner.for.cond.cleanup24

omp.inner.for.cond.cleanup24:                     ; preds = %omp.inner.for.cond22
  br label %omp.inner.for.end33

omp.inner.for.body25:                             ; preds = %omp.inner.for.cond22
  %23 = load i64, ptr %.omp.iv20, align 8, !tbaa !11, !llvm.access.group !44
  %mul26 = mul i64 %23, 1
  %add27 = add i64 0, %mul26
  store i64 %add27, ptr %i21, align 8, !tbaa !11, !llvm.access.group !44
  %24 = load <2 x double>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !44
  %25 = load i64, ptr %i21, align 8, !tbaa !11, !llvm.access.group !44
  %vecext28 = extractelement <2 x double> %24, i64 %25
  %26 = call double @llvm.floor.f64(double %vecext28)
  %27 = load i64, ptr %i21, align 8, !tbaa !11, !llvm.access.group !44
  %28 = load <2 x double>, ptr %r_, align 16, !llvm.access.group !44
  %vecins29 = insertelement <2 x double> %28, double %26, i64 %27
  store <2 x double> %vecins29, ptr %r_, align 16, !llvm.access.group !44
  br label %omp.body.continue30

omp.body.continue30:                              ; preds = %omp.inner.for.body25
  br label %omp.inner.for.inc31

omp.inner.for.inc31:                              ; preds = %omp.body.continue30
  %29 = load i64, ptr %.omp.iv20, align 8, !tbaa !11, !llvm.access.group !44
  %add32 = add i64 %29, 1
  store i64 %add32, ptr %.omp.iv20, align 8, !tbaa !11, !llvm.access.group !44
  br label %omp.inner.for.cond22, !llvm.loop !45

omp.inner.for.end33:                              ; preds = %omp.inner.for.cond.cleanup24
  store i64 2, ptr %i21, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i21) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv20) #10
  br label %sw.epilog

sw.bb34:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv36) #10
  store i64 0, ptr %.omp.iv36, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i37) #10
  br label %omp.inner.for.cond38

omp.inner.for.cond38:                             ; preds = %omp.inner.for.inc47, %sw.bb34
  %30 = load i64, ptr %.omp.iv36, align 8, !tbaa !11, !llvm.access.group !47
  %cmp39 = icmp ult i64 %30, 2
  br i1 %cmp39, label %omp.inner.for.body41, label %omp.inner.for.cond.cleanup40

omp.inner.for.cond.cleanup40:                     ; preds = %omp.inner.for.cond38
  br label %omp.inner.for.end49

omp.inner.for.body41:                             ; preds = %omp.inner.for.cond38
  %31 = load i64, ptr %.omp.iv36, align 8, !tbaa !11, !llvm.access.group !47
  %mul42 = mul i64 %31, 1
  %add43 = add i64 0, %mul42
  store i64 %add43, ptr %i37, align 8, !tbaa !11, !llvm.access.group !47
  %32 = load <2 x double>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !47
  %33 = load i64, ptr %i37, align 8, !tbaa !11, !llvm.access.group !47
  %vecext44 = extractelement <2 x double> %32, i64 %33
  %34 = call double @llvm.ceil.f64(double %vecext44)
  %35 = load i64, ptr %i37, align 8, !tbaa !11, !llvm.access.group !47
  %36 = load <2 x double>, ptr %r_, align 16, !llvm.access.group !47
  %vecins45 = insertelement <2 x double> %36, double %34, i64 %35
  store <2 x double> %vecins45, ptr %r_, align 16, !llvm.access.group !47
  br label %omp.body.continue46

omp.body.continue46:                              ; preds = %omp.inner.for.body41
  br label %omp.inner.for.inc47

omp.inner.for.inc47:                              ; preds = %omp.body.continue46
  %37 = load i64, ptr %.omp.iv36, align 8, !tbaa !11, !llvm.access.group !47
  %add48 = add i64 %37, 1
  store i64 %add48, ptr %.omp.iv36, align 8, !tbaa !11, !llvm.access.group !47
  br label %omp.inner.for.cond38, !llvm.loop !48

omp.inner.for.end49:                              ; preds = %omp.inner.for.cond.cleanup40
  store i64 2, ptr %i37, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i37) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv36) #10
  br label %sw.epilog

sw.bb50:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv52) #10
  store i64 0, ptr %.omp.iv52, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i53) #10
  br label %omp.inner.for.cond54

omp.inner.for.cond54:                             ; preds = %omp.inner.for.inc63, %sw.bb50
  %38 = load i64, ptr %.omp.iv52, align 8, !tbaa !11, !llvm.access.group !50
  %cmp55 = icmp ult i64 %38, 2
  br i1 %cmp55, label %omp.inner.for.body57, label %omp.inner.for.cond.cleanup56

omp.inner.for.cond.cleanup56:                     ; preds = %omp.inner.for.cond54
  br label %omp.inner.for.end65

omp.inner.for.body57:                             ; preds = %omp.inner.for.cond54
  %39 = load i64, ptr %.omp.iv52, align 8, !tbaa !11, !llvm.access.group !50
  %mul58 = mul i64 %39, 1
  %add59 = add i64 0, %mul58
  store i64 %add59, ptr %i53, align 8, !tbaa !11, !llvm.access.group !50
  %40 = load <2 x double>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !50
  %41 = load i64, ptr %i53, align 8, !tbaa !11, !llvm.access.group !50
  %vecext60 = extractelement <2 x double> %40, i64 %41
  %42 = call double @llvm.trunc.f64(double %vecext60)
  %43 = load i64, ptr %i53, align 8, !tbaa !11, !llvm.access.group !50
  %44 = load <2 x double>, ptr %r_, align 16, !llvm.access.group !50
  %vecins61 = insertelement <2 x double> %44, double %42, i64 %43
  store <2 x double> %vecins61, ptr %r_, align 16, !llvm.access.group !50
  br label %omp.body.continue62

omp.body.continue62:                              ; preds = %omp.inner.for.body57
  br label %omp.inner.for.inc63

omp.inner.for.inc63:                              ; preds = %omp.body.continue62
  %45 = load i64, ptr %.omp.iv52, align 8, !tbaa !11, !llvm.access.group !50
  %add64 = add i64 %45, 1
  store i64 %add64, ptr %.omp.iv52, align 8, !tbaa !11, !llvm.access.group !50
  br label %omp.inner.for.cond54, !llvm.loop !51

omp.inner.for.end65:                              ; preds = %omp.inner.for.cond.cleanup56
  store i64 2, ptr %i53, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i53) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv52) #10
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  unreachable

sw.epilog:                                        ; preds = %omp.inner.for.end65, %omp.inner.for.end49, %omp.inner.for.end33, %omp.inner.for.end17, %omp.inner.for.end
  %46 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %47 = load double, ptr %46, align 16
  %48 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %49 = load double, ptr %48, align 8
  %call66 = call <2 x double> @simde__m128d_from_private(double %47, double %49)
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x double> %call66
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.nearbyint.f64(double) #7

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.roundeven.f64(double) #7

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.floor.f64(double) #7

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.ceil.f64(double) #7

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare double @llvm.trunc.f64(double) #7

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x float> @simde_mm_ceil_ps(<4 x float> noundef %a) #4 {
entry:
  %a.addr = alloca <4 x float>, align 16
  store <4 x float> %a, ptr %a.addr, align 16, !tbaa !16
  %0 = load <4 x float>, ptr %a.addr, align 16, !tbaa !16
  %call = call <4 x float> @simde_x_mm_round_ps(<4 x float> noundef %0, i32 noundef 2, i32 noundef 0)
  ret <4 x float> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x float> @simde_x_mm_round_ps(<4 x float> noundef %a, i32 noundef %rounding, i32 noundef %lax_rounding) #4 {
entry:
  %a.addr = alloca <4 x float>, align 16
  %rounding.addr = alloca i32, align 4
  %lax_rounding.addr = alloca i32, align 4
  %r_ = alloca %union.simde__m128_private, align 16
  %a_ = alloca %union.simde__m128_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  %tmp3 = alloca i64, align 8
  %.omp.iv4 = alloca i64, align 8
  %i5 = alloca i64, align 8
  %tmp19 = alloca i64, align 8
  %.omp.iv20 = alloca i64, align 8
  %i21 = alloca i64, align 8
  %tmp35 = alloca i64, align 8
  %.omp.iv36 = alloca i64, align 8
  %i37 = alloca i64, align 8
  %tmp51 = alloca i64, align 8
  %.omp.iv52 = alloca i64, align 8
  %i53 = alloca i64, align 8
  store <4 x float> %a, ptr %a.addr, align 16, !tbaa !16
  store i32 %rounding, ptr %rounding.addr, align 4, !tbaa !5
  store i32 %lax_rounding, ptr %lax_rounding.addr, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <4 x float>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128_to_private(<4 x float> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  %5 = load i32, ptr %lax_rounding.addr, align 4, !tbaa !5
  %6 = load i32, ptr %rounding.addr, align 4, !tbaa !5
  %and = and i32 %6, -9
  switch i32 %and, label %sw.default [
    i32 4, label %sw.bb
    i32 0, label %sw.bb2
    i32 1, label %sw.bb18
    i32 2, label %sw.bb34
    i32 3, label %sw.bb50
  ]

sw.bb:                                            ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %sw.bb
  %7 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !53
  %cmp = icmp ult i64 %7, 4
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %8 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !53
  %mul = mul i64 %8, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !53
  %9 = load <4 x float>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !53
  %10 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !53
  %vecext = extractelement <4 x float> %9, i64 %10
  %11 = call float @llvm.nearbyint.f32(float %vecext)
  %12 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !53
  %13 = load <4 x float>, ptr %r_, align 16, !llvm.access.group !53
  %vecins = insertelement <4 x float> %13, float %11, i64 %12
  store <4 x float> %vecins, ptr %r_, align 16, !llvm.access.group !53
  br label %omp.body.continue

omp.body.continue:                                ; preds = %omp.inner.for.body
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %14 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !53
  %add1 = add i64 %14, 1
  store i64 %add1, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !53
  br label %omp.inner.for.cond, !llvm.loop !54

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 4, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv4) #10
  store i64 0, ptr %.omp.iv4, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i5) #10
  br label %omp.inner.for.cond6

omp.inner.for.cond6:                              ; preds = %omp.inner.for.inc15, %sw.bb2
  %15 = load i64, ptr %.omp.iv4, align 8, !tbaa !11, !llvm.access.group !56
  %cmp7 = icmp ult i64 %15, 4
  br i1 %cmp7, label %omp.inner.for.body9, label %omp.inner.for.cond.cleanup8

omp.inner.for.cond.cleanup8:                      ; preds = %omp.inner.for.cond6
  br label %omp.inner.for.end17

omp.inner.for.body9:                              ; preds = %omp.inner.for.cond6
  %16 = load i64, ptr %.omp.iv4, align 8, !tbaa !11, !llvm.access.group !56
  %mul10 = mul i64 %16, 1
  %add11 = add i64 0, %mul10
  store i64 %add11, ptr %i5, align 8, !tbaa !11, !llvm.access.group !56
  %17 = load <4 x float>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !56
  %18 = load i64, ptr %i5, align 8, !tbaa !11, !llvm.access.group !56
  %vecext12 = extractelement <4 x float> %17, i64 %18
  %19 = call float @llvm.roundeven.f32(float %vecext12)
  %20 = load i64, ptr %i5, align 8, !tbaa !11, !llvm.access.group !56
  %21 = load <4 x float>, ptr %r_, align 16, !llvm.access.group !56
  %vecins13 = insertelement <4 x float> %21, float %19, i64 %20
  store <4 x float> %vecins13, ptr %r_, align 16, !llvm.access.group !56
  br label %omp.body.continue14

omp.body.continue14:                              ; preds = %omp.inner.for.body9
  br label %omp.inner.for.inc15

omp.inner.for.inc15:                              ; preds = %omp.body.continue14
  %22 = load i64, ptr %.omp.iv4, align 8, !tbaa !11, !llvm.access.group !56
  %add16 = add i64 %22, 1
  store i64 %add16, ptr %.omp.iv4, align 8, !tbaa !11, !llvm.access.group !56
  br label %omp.inner.for.cond6, !llvm.loop !57

omp.inner.for.end17:                              ; preds = %omp.inner.for.cond.cleanup8
  store i64 4, ptr %i5, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i5) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv4) #10
  br label %sw.epilog

sw.bb18:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv20) #10
  store i64 0, ptr %.omp.iv20, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i21) #10
  br label %omp.inner.for.cond22

omp.inner.for.cond22:                             ; preds = %omp.inner.for.inc31, %sw.bb18
  %23 = load i64, ptr %.omp.iv20, align 8, !tbaa !11, !llvm.access.group !59
  %cmp23 = icmp ult i64 %23, 4
  br i1 %cmp23, label %omp.inner.for.body25, label %omp.inner.for.cond.cleanup24

omp.inner.for.cond.cleanup24:                     ; preds = %omp.inner.for.cond22
  br label %omp.inner.for.end33

omp.inner.for.body25:                             ; preds = %omp.inner.for.cond22
  %24 = load i64, ptr %.omp.iv20, align 8, !tbaa !11, !llvm.access.group !59
  %mul26 = mul i64 %24, 1
  %add27 = add i64 0, %mul26
  store i64 %add27, ptr %i21, align 8, !tbaa !11, !llvm.access.group !59
  %25 = load <4 x float>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !59
  %26 = load i64, ptr %i21, align 8, !tbaa !11, !llvm.access.group !59
  %vecext28 = extractelement <4 x float> %25, i64 %26
  %27 = call float @llvm.floor.f32(float %vecext28)
  %28 = load i64, ptr %i21, align 8, !tbaa !11, !llvm.access.group !59
  %29 = load <4 x float>, ptr %r_, align 16, !llvm.access.group !59
  %vecins29 = insertelement <4 x float> %29, float %27, i64 %28
  store <4 x float> %vecins29, ptr %r_, align 16, !llvm.access.group !59
  br label %omp.body.continue30

omp.body.continue30:                              ; preds = %omp.inner.for.body25
  br label %omp.inner.for.inc31

omp.inner.for.inc31:                              ; preds = %omp.body.continue30
  %30 = load i64, ptr %.omp.iv20, align 8, !tbaa !11, !llvm.access.group !59
  %add32 = add i64 %30, 1
  store i64 %add32, ptr %.omp.iv20, align 8, !tbaa !11, !llvm.access.group !59
  br label %omp.inner.for.cond22, !llvm.loop !60

omp.inner.for.end33:                              ; preds = %omp.inner.for.cond.cleanup24
  store i64 4, ptr %i21, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i21) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv20) #10
  br label %sw.epilog

sw.bb34:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv36) #10
  store i64 0, ptr %.omp.iv36, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i37) #10
  br label %omp.inner.for.cond38

omp.inner.for.cond38:                             ; preds = %omp.inner.for.inc47, %sw.bb34
  %31 = load i64, ptr %.omp.iv36, align 8, !tbaa !11, !llvm.access.group !62
  %cmp39 = icmp ult i64 %31, 4
  br i1 %cmp39, label %omp.inner.for.body41, label %omp.inner.for.cond.cleanup40

omp.inner.for.cond.cleanup40:                     ; preds = %omp.inner.for.cond38
  br label %omp.inner.for.end49

omp.inner.for.body41:                             ; preds = %omp.inner.for.cond38
  %32 = load i64, ptr %.omp.iv36, align 8, !tbaa !11, !llvm.access.group !62
  %mul42 = mul i64 %32, 1
  %add43 = add i64 0, %mul42
  store i64 %add43, ptr %i37, align 8, !tbaa !11, !llvm.access.group !62
  %33 = load <4 x float>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !62
  %34 = load i64, ptr %i37, align 8, !tbaa !11, !llvm.access.group !62
  %vecext44 = extractelement <4 x float> %33, i64 %34
  %35 = call float @llvm.ceil.f32(float %vecext44)
  %36 = load i64, ptr %i37, align 8, !tbaa !11, !llvm.access.group !62
  %37 = load <4 x float>, ptr %r_, align 16, !llvm.access.group !62
  %vecins45 = insertelement <4 x float> %37, float %35, i64 %36
  store <4 x float> %vecins45, ptr %r_, align 16, !llvm.access.group !62
  br label %omp.body.continue46

omp.body.continue46:                              ; preds = %omp.inner.for.body41
  br label %omp.inner.for.inc47

omp.inner.for.inc47:                              ; preds = %omp.body.continue46
  %38 = load i64, ptr %.omp.iv36, align 8, !tbaa !11, !llvm.access.group !62
  %add48 = add i64 %38, 1
  store i64 %add48, ptr %.omp.iv36, align 8, !tbaa !11, !llvm.access.group !62
  br label %omp.inner.for.cond38, !llvm.loop !63

omp.inner.for.end49:                              ; preds = %omp.inner.for.cond.cleanup40
  store i64 4, ptr %i37, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i37) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv36) #10
  br label %sw.epilog

sw.bb50:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv52) #10
  store i64 0, ptr %.omp.iv52, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i53) #10
  br label %omp.inner.for.cond54

omp.inner.for.cond54:                             ; preds = %omp.inner.for.inc63, %sw.bb50
  %39 = load i64, ptr %.omp.iv52, align 8, !tbaa !11, !llvm.access.group !65
  %cmp55 = icmp ult i64 %39, 4
  br i1 %cmp55, label %omp.inner.for.body57, label %omp.inner.for.cond.cleanup56

omp.inner.for.cond.cleanup56:                     ; preds = %omp.inner.for.cond54
  br label %omp.inner.for.end65

omp.inner.for.body57:                             ; preds = %omp.inner.for.cond54
  %40 = load i64, ptr %.omp.iv52, align 8, !tbaa !11, !llvm.access.group !65
  %mul58 = mul i64 %40, 1
  %add59 = add i64 0, %mul58
  store i64 %add59, ptr %i53, align 8, !tbaa !11, !llvm.access.group !65
  %41 = load <4 x float>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !65
  %42 = load i64, ptr %i53, align 8, !tbaa !11, !llvm.access.group !65
  %vecext60 = extractelement <4 x float> %41, i64 %42
  %43 = call float @llvm.trunc.f32(float %vecext60)
  %44 = load i64, ptr %i53, align 8, !tbaa !11, !llvm.access.group !65
  %45 = load <4 x float>, ptr %r_, align 16, !llvm.access.group !65
  %vecins61 = insertelement <4 x float> %45, float %43, i64 %44
  store <4 x float> %vecins61, ptr %r_, align 16, !llvm.access.group !65
  br label %omp.body.continue62

omp.body.continue62:                              ; preds = %omp.inner.for.body57
  br label %omp.inner.for.inc63

omp.inner.for.inc63:                              ; preds = %omp.body.continue62
  %46 = load i64, ptr %.omp.iv52, align 8, !tbaa !11, !llvm.access.group !65
  %add64 = add i64 %46, 1
  store i64 %add64, ptr %.omp.iv52, align 8, !tbaa !11, !llvm.access.group !65
  br label %omp.inner.for.cond54, !llvm.loop !66

omp.inner.for.end65:                              ; preds = %omp.inner.for.cond.cleanup56
  store i64 4, ptr %i53, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i53) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv52) #10
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  unreachable

sw.epilog:                                        ; preds = %omp.inner.for.end65, %omp.inner.for.end49, %omp.inner.for.end33, %omp.inner.for.end17, %omp.inner.for.end
  %47 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %48 = load double, ptr %47, align 16
  %49 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %50 = load double, ptr %49, align 8
  %call66 = call <4 x float> @simde__m128_from_private(double %48, double %50)
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <4 x float> %call66
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.nearbyint.f32(float) #7

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.roundeven.f32(float) #7

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.floor.f32(float) #7

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.ceil.f32(float) #7

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.trunc.f32(float) #7

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x double> @simde_mm_ceil_sd(<2 x double> noundef %a, <2 x double> noundef %b) #4 {
entry:
  %a.addr = alloca <2 x double>, align 16
  %b.addr = alloca <2 x double>, align 16
  %r_ = alloca %union.simde__m128d_private, align 16
  %a_ = alloca %union.simde__m128d_private, align 16
  %b_ = alloca %union.simde__m128d_private, align 16
  %tmp = alloca %union.simde__m128d_private, align 16
  store <2 x double> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x double> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x double>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128d_to_private(<2 x double> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128d_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x double>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128d_to_private(<2 x double> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128d_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %tmp) #10
  %10 = load <2 x double>, ptr %a_, align 16, !tbaa !16
  %vecext = extractelement <2 x double> %10, i32 1
  %11 = load <2 x double>, ptr %b_, align 16, !tbaa !16
  %vecext3 = extractelement <2 x double> %11, i32 0
  %12 = call double @llvm.ceil.f64(double %vecext3)
  %call4 = call <2 x double> @simde_mm_set_pd(double noundef %vecext, double noundef %12)
  %call5 = call { double, double } @simde__m128d_to_private(<2 x double> noundef %call4)
  %coerce.dive6 = getelementptr inbounds %union.simde__m128d_private, ptr %tmp, i32 0, i32 0
  %13 = getelementptr inbounds { double, double }, ptr %coerce.dive6, i32 0, i32 0
  %14 = extractvalue { double, double } %call5, 0
  store double %14, ptr %13, align 16
  %15 = getelementptr inbounds { double, double }, ptr %coerce.dive6, i32 0, i32 1
  %16 = extractvalue { double, double } %call5, 1
  store double %16, ptr %15, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %r_, ptr align 16 %tmp, i64 16, i1 false), !tbaa.struct !68
  call void @llvm.lifetime.end.p0(i64 16, ptr %tmp) #10
  %17 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %18 = load double, ptr %17, align 16
  %19 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %20 = load double, ptr %19, align 8
  %call7 = call <2 x double> @simde__m128d_from_private(double %18, double %20)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x double> %call7
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x float> @simde_mm_ceil_ss(<4 x float> noundef %a, <4 x float> noundef %b) #4 {
entry:
  %a.addr = alloca <4 x float>, align 16
  %b.addr = alloca <4 x float>, align 16
  %r_ = alloca %union.simde__m128_private, align 16
  %a_ = alloca %union.simde__m128_private, align 16
  %b_ = alloca %union.simde__m128_private, align 16
  %tmp = alloca %union.simde__m128_private, align 16
  store <4 x float> %a, ptr %a.addr, align 16, !tbaa !16
  store <4 x float> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <4 x float>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128_to_private(<4 x float> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <4 x float>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128_to_private(<4 x float> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %tmp) #10
  %10 = load <4 x float>, ptr %a_, align 16, !tbaa !16
  %vecext = extractelement <4 x float> %10, i32 3
  %11 = load <4 x float>, ptr %a_, align 16, !tbaa !16
  %vecext3 = extractelement <4 x float> %11, i32 2
  %12 = load <4 x float>, ptr %a_, align 16, !tbaa !16
  %vecext4 = extractelement <4 x float> %12, i32 1
  %13 = load <4 x float>, ptr %b_, align 16, !tbaa !16
  %vecext5 = extractelement <4 x float> %13, i32 0
  %14 = call float @llvm.ceil.f32(float %vecext5)
  %call6 = call <4 x float> @simde_mm_set_ps(float noundef %vecext, float noundef %vecext3, float noundef %vecext4, float noundef %14)
  %call7 = call { double, double } @simde__m128_to_private(<4 x float> noundef %call6)
  %coerce.dive8 = getelementptr inbounds %union.simde__m128_private, ptr %tmp, i32 0, i32 0
  %15 = getelementptr inbounds { double, double }, ptr %coerce.dive8, i32 0, i32 0
  %16 = extractvalue { double, double } %call7, 0
  store double %16, ptr %15, align 16
  %17 = getelementptr inbounds { double, double }, ptr %coerce.dive8, i32 0, i32 1
  %18 = extractvalue { double, double } %call7, 1
  store double %18, ptr %17, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %r_, ptr align 16 %tmp, i64 16, i1 false), !tbaa.struct !69
  call void @llvm.lifetime.end.p0(i64 16, ptr %tmp) #10
  %19 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %20 = load double, ptr %19, align 16
  %21 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %22 = load double, ptr %21, align 8
  %call9 = call <4 x float> @simde__m128_from_private(double %20, double %22)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <4 x float> %call9
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_cmpeq_epi64(<2 x i64> noundef %a, <2 x i64> noundef %b) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  %10 = load <2 x i64>, ptr %a_, align 16, !tbaa !16
  %11 = load <2 x i64>, ptr %b_, align 16, !tbaa !16
  %cmp = icmp eq <2 x i64> %10, %11
  %sext = sext <2 x i1> %cmp to <2 x i64>
  store <2 x i64> %sext, ptr %r_, align 16, !tbaa !16
  %12 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %13 = load double, ptr %12, align 16
  %14 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %15 = load double, ptr %14, align 8
  %call3 = call <2 x i64> @simde__m128i_from_private(double %13, double %15)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call3
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_cvtepi8_epi16(<2 x i64> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  %5 = load <16 x i8>, ptr %a_, align 16, !tbaa !16
  %6 = load <16 x i8>, ptr %a_, align 16, !tbaa !16
  %shuffle = shufflevector <16 x i8> %5, <16 x i8> %6, <16 x i32> <i32 poison, i32 0, i32 poison, i32 1, i32 poison, i32 2, i32 poison, i32 3, i32 poison, i32 4, i32 poison, i32 5, i32 poison, i32 6, i32 poison, i32 7>
  %7 = bitcast <16 x i8> %shuffle to <8 x i16>
  store <8 x i16> %7, ptr %r_, align 16, !tbaa !16
  %8 = load <8 x i16>, ptr %r_, align 16, !tbaa !16
  %shr = ashr <8 x i16> %8, <i16 8, i16 8, i16 8, i16 8, i16 8, i16 8, i16 8, i16 8>
  store <8 x i16> %shr, ptr %r_, align 16, !tbaa !16
  %9 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %10 = load double, ptr %9, align 16
  %11 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %12 = load double, ptr %11, align 8
  %call1 = call <2 x i64> @simde__m128i_from_private(double %10, double %12)
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_cvtepi8_epi32(<2 x i64> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  %5 = load <16 x i8>, ptr %a_, align 16, !tbaa !16
  %6 = load <16 x i8>, ptr %a_, align 16, !tbaa !16
  %shuffle = shufflevector <16 x i8> %5, <16 x i8> %6, <16 x i32> <i32 poison, i32 poison, i32 poison, i32 0, i32 poison, i32 poison, i32 poison, i32 1, i32 poison, i32 poison, i32 poison, i32 2, i32 poison, i32 poison, i32 poison, i32 3>
  %7 = bitcast <16 x i8> %shuffle to <4 x i32>
  store <4 x i32> %7, ptr %r_, align 16, !tbaa !16
  %8 = load <4 x i32>, ptr %r_, align 16, !tbaa !16
  %shr = ashr <4 x i32> %8, <i32 24, i32 24, i32 24, i32 24>
  store <4 x i32> %shr, ptr %r_, align 16, !tbaa !16
  %9 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %10 = load double, ptr %9, align 16
  %11 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %12 = load double, ptr %11, align 8
  %call1 = call <2 x i64> @simde__m128i_from_private(double %10, double %12)
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_cvtepi8_epi64(<2 x i64> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %5 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !70
  %cmp = icmp ult i64 %5, 2
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %6 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !70
  %mul = mul i64 %6, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !70
  %7 = load <16 x i8>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !70
  %8 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !70
  %vecext = extractelement <16 x i8> %7, i64 %8
  %conv = sext i8 %vecext to i64
  %9 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !70
  %10 = load <2 x i64>, ptr %r_, align 16, !llvm.access.group !70
  %vecins = insertelement <2 x i64> %10, i64 %conv, i64 %9
  store <2 x i64> %vecins, ptr %r_, align 16, !llvm.access.group !70
  br label %omp.body.continue

omp.body.continue:                                ; preds = %omp.inner.for.body
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !70
  %add1 = add i64 %11, 1
  store i64 %add1, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !70
  br label %omp.inner.for.cond, !llvm.loop !71

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 2, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  %12 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %13 = load double, ptr %12, align 16
  %14 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %15 = load double, ptr %14, align 8
  %call2 = call <2 x i64> @simde__m128i_from_private(double %13, double %15)
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call2
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_x_mm_set_epu8(i8 noundef zeroext %e15, i8 noundef zeroext %e14, i8 noundef zeroext %e13, i8 noundef zeroext %e12, i8 noundef zeroext %e11, i8 noundef zeroext %e10, i8 noundef zeroext %e9, i8 noundef zeroext %e8, i8 noundef zeroext %e7, i8 noundef zeroext %e6, i8 noundef zeroext %e5, i8 noundef zeroext %e4, i8 noundef zeroext %e3, i8 noundef zeroext %e2, i8 noundef zeroext %e1, i8 noundef zeroext %e0) #4 {
entry:
  %e15.addr = alloca i8, align 1
  %e14.addr = alloca i8, align 1
  %e13.addr = alloca i8, align 1
  %e12.addr = alloca i8, align 1
  %e11.addr = alloca i8, align 1
  %e10.addr = alloca i8, align 1
  %e9.addr = alloca i8, align 1
  %e8.addr = alloca i8, align 1
  %e7.addr = alloca i8, align 1
  %e6.addr = alloca i8, align 1
  %e5.addr = alloca i8, align 1
  %e4.addr = alloca i8, align 1
  %e3.addr = alloca i8, align 1
  %e2.addr = alloca i8, align 1
  %e1.addr = alloca i8, align 1
  %e0.addr = alloca i8, align 1
  %r_ = alloca %union.simde__m128i_private, align 16
  store i8 %e15, ptr %e15.addr, align 1, !tbaa !16
  store i8 %e14, ptr %e14.addr, align 1, !tbaa !16
  store i8 %e13, ptr %e13.addr, align 1, !tbaa !16
  store i8 %e12, ptr %e12.addr, align 1, !tbaa !16
  store i8 %e11, ptr %e11.addr, align 1, !tbaa !16
  store i8 %e10, ptr %e10.addr, align 1, !tbaa !16
  store i8 %e9, ptr %e9.addr, align 1, !tbaa !16
  store i8 %e8, ptr %e8.addr, align 1, !tbaa !16
  store i8 %e7, ptr %e7.addr, align 1, !tbaa !16
  store i8 %e6, ptr %e6.addr, align 1, !tbaa !16
  store i8 %e5, ptr %e5.addr, align 1, !tbaa !16
  store i8 %e4, ptr %e4.addr, align 1, !tbaa !16
  store i8 %e3, ptr %e3.addr, align 1, !tbaa !16
  store i8 %e2, ptr %e2.addr, align 1, !tbaa !16
  store i8 %e1, ptr %e1.addr, align 1, !tbaa !16
  store i8 %e0, ptr %e0.addr, align 1, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  %0 = load i8, ptr %e0.addr, align 1, !tbaa !16
  %1 = load <16 x i8>, ptr %r_, align 16
  %vecins = insertelement <16 x i8> %1, i8 %0, i32 0
  store <16 x i8> %vecins, ptr %r_, align 16
  %2 = load i8, ptr %e1.addr, align 1, !tbaa !16
  %3 = load <16 x i8>, ptr %r_, align 16
  %vecins1 = insertelement <16 x i8> %3, i8 %2, i32 1
  store <16 x i8> %vecins1, ptr %r_, align 16
  %4 = load i8, ptr %e2.addr, align 1, !tbaa !16
  %5 = load <16 x i8>, ptr %r_, align 16
  %vecins2 = insertelement <16 x i8> %5, i8 %4, i32 2
  store <16 x i8> %vecins2, ptr %r_, align 16
  %6 = load i8, ptr %e3.addr, align 1, !tbaa !16
  %7 = load <16 x i8>, ptr %r_, align 16
  %vecins3 = insertelement <16 x i8> %7, i8 %6, i32 3
  store <16 x i8> %vecins3, ptr %r_, align 16
  %8 = load i8, ptr %e4.addr, align 1, !tbaa !16
  %9 = load <16 x i8>, ptr %r_, align 16
  %vecins4 = insertelement <16 x i8> %9, i8 %8, i32 4
  store <16 x i8> %vecins4, ptr %r_, align 16
  %10 = load i8, ptr %e5.addr, align 1, !tbaa !16
  %11 = load <16 x i8>, ptr %r_, align 16
  %vecins5 = insertelement <16 x i8> %11, i8 %10, i32 5
  store <16 x i8> %vecins5, ptr %r_, align 16
  %12 = load i8, ptr %e6.addr, align 1, !tbaa !16
  %13 = load <16 x i8>, ptr %r_, align 16
  %vecins6 = insertelement <16 x i8> %13, i8 %12, i32 6
  store <16 x i8> %vecins6, ptr %r_, align 16
  %14 = load i8, ptr %e7.addr, align 1, !tbaa !16
  %15 = load <16 x i8>, ptr %r_, align 16
  %vecins7 = insertelement <16 x i8> %15, i8 %14, i32 7
  store <16 x i8> %vecins7, ptr %r_, align 16
  %16 = load i8, ptr %e8.addr, align 1, !tbaa !16
  %17 = load <16 x i8>, ptr %r_, align 16
  %vecins8 = insertelement <16 x i8> %17, i8 %16, i32 8
  store <16 x i8> %vecins8, ptr %r_, align 16
  %18 = load i8, ptr %e9.addr, align 1, !tbaa !16
  %19 = load <16 x i8>, ptr %r_, align 16
  %vecins9 = insertelement <16 x i8> %19, i8 %18, i32 9
  store <16 x i8> %vecins9, ptr %r_, align 16
  %20 = load i8, ptr %e10.addr, align 1, !tbaa !16
  %21 = load <16 x i8>, ptr %r_, align 16
  %vecins10 = insertelement <16 x i8> %21, i8 %20, i32 10
  store <16 x i8> %vecins10, ptr %r_, align 16
  %22 = load i8, ptr %e11.addr, align 1, !tbaa !16
  %23 = load <16 x i8>, ptr %r_, align 16
  %vecins11 = insertelement <16 x i8> %23, i8 %22, i32 11
  store <16 x i8> %vecins11, ptr %r_, align 16
  %24 = load i8, ptr %e12.addr, align 1, !tbaa !16
  %25 = load <16 x i8>, ptr %r_, align 16
  %vecins12 = insertelement <16 x i8> %25, i8 %24, i32 12
  store <16 x i8> %vecins12, ptr %r_, align 16
  %26 = load i8, ptr %e13.addr, align 1, !tbaa !16
  %27 = load <16 x i8>, ptr %r_, align 16
  %vecins13 = insertelement <16 x i8> %27, i8 %26, i32 13
  store <16 x i8> %vecins13, ptr %r_, align 16
  %28 = load i8, ptr %e14.addr, align 1, !tbaa !16
  %29 = load <16 x i8>, ptr %r_, align 16
  %vecins14 = insertelement <16 x i8> %29, i8 %28, i32 14
  store <16 x i8> %vecins14, ptr %r_, align 16
  %30 = load i8, ptr %e15.addr, align 1, !tbaa !16
  %31 = load <16 x i8>, ptr %r_, align 16
  %vecins15 = insertelement <16 x i8> %31, i8 %30, i32 15
  store <16 x i8> %vecins15, ptr %r_, align 16
  %32 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %33 = load double, ptr %32, align 16
  %34 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %35 = load double, ptr %34, align 8
  %call = call <2 x i64> @simde__m128i_from_private(double %33, double %35)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_cvtepu8_epi16(<2 x i64> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %z = alloca <16 x i8>, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %z) #10
  store <16 x i8> zeroinitializer, ptr %z, align 16, !tbaa !16
  %5 = load <16 x i8>, ptr %a_, align 16, !tbaa !16
  %6 = load <16 x i8>, ptr %z, align 16, !tbaa !16
  %shuffle = shufflevector <16 x i8> %5, <16 x i8> %6, <16 x i32> <i32 0, i32 16, i32 1, i32 17, i32 2, i32 18, i32 3, i32 19, i32 4, i32 20, i32 5, i32 21, i32 6, i32 22, i32 7, i32 23>
  %7 = bitcast <16 x i8> %shuffle to <8 x i16>
  store <8 x i16> %7, ptr %r_, align 16, !tbaa !16
  %8 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %9 = load double, ptr %8, align 16
  %10 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %11 = load double, ptr %10, align 8
  %call1 = call <2 x i64> @simde__m128i_from_private(double %9, double %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %z) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_cvtepu8_epi32(<2 x i64> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %z = alloca <16 x i8>, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %z) #10
  store <16 x i8> zeroinitializer, ptr %z, align 16, !tbaa !16
  %5 = load <16 x i8>, ptr %a_, align 16, !tbaa !16
  %6 = load <16 x i8>, ptr %z, align 16, !tbaa !16
  %shuffle = shufflevector <16 x i8> %5, <16 x i8> %6, <16 x i32> <i32 0, i32 17, i32 18, i32 19, i32 1, i32 21, i32 22, i32 23, i32 2, i32 25, i32 26, i32 27, i32 3, i32 29, i32 30, i32 31>
  %7 = bitcast <16 x i8> %shuffle to <4 x i32>
  store <4 x i32> %7, ptr %r_, align 16, !tbaa !16
  %8 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %9 = load double, ptr %8, align 16
  %10 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %11 = load double, ptr %10, align 8
  %call1 = call <2 x i64> @simde__m128i_from_private(double %9, double %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %z) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_cvtepu8_epi64(<2 x i64> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %z = alloca <16 x i8>, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %z) #10
  store <16 x i8> zeroinitializer, ptr %z, align 16, !tbaa !16
  %5 = load <16 x i8>, ptr %a_, align 16, !tbaa !16
  %6 = load <16 x i8>, ptr %z, align 16, !tbaa !16
  %shuffle = shufflevector <16 x i8> %5, <16 x i8> %6, <16 x i32> <i32 0, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 1, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31>
  %7 = bitcast <16 x i8> %shuffle to <2 x i64>
  store <2 x i64> %7, ptr %r_, align 16, !tbaa !16
  %8 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %9 = load double, ptr %8, align 16
  %10 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %11 = load double, ptr %10, align 8
  %call1 = call <2 x i64> @simde__m128i_from_private(double %9, double %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %z) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_cvtepi16_epi32(<2 x i64> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  %5 = load <8 x i16>, ptr %a_, align 16, !tbaa !16
  %6 = load <8 x i16>, ptr %a_, align 16, !tbaa !16
  %shuffle = shufflevector <8 x i16> %5, <8 x i16> %6, <8 x i32> <i32 8, i32 0, i32 10, i32 1, i32 12, i32 2, i32 14, i32 3>
  %7 = bitcast <8 x i16> %shuffle to <4 x i32>
  store <4 x i32> %7, ptr %r_, align 16, !tbaa !16
  %8 = load <4 x i32>, ptr %r_, align 16, !tbaa !16
  %shr = ashr <4 x i32> %8, <i32 16, i32 16, i32 16, i32 16>
  store <4 x i32> %shr, ptr %r_, align 16, !tbaa !16
  %9 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %10 = load double, ptr %9, align 16
  %11 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %12 = load double, ptr %11, align 8
  %call1 = call <2 x i64> @simde__m128i_from_private(double %10, double %12)
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_cvtepi16_epi64(<2 x i64> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %5 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !73
  %cmp = icmp ult i64 %5, 2
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %6 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !73
  %mul = mul i64 %6, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !73
  %7 = load <8 x i16>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !73
  %8 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !73
  %vecext = extractelement <8 x i16> %7, i64 %8
  %conv = sext i16 %vecext to i64
  %9 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !73
  %10 = load <2 x i64>, ptr %r_, align 16, !llvm.access.group !73
  %vecins = insertelement <2 x i64> %10, i64 %conv, i64 %9
  store <2 x i64> %vecins, ptr %r_, align 16, !llvm.access.group !73
  br label %omp.body.continue

omp.body.continue:                                ; preds = %omp.inner.for.body
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !73
  %add1 = add i64 %11, 1
  store i64 %add1, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !73
  br label %omp.inner.for.cond, !llvm.loop !74

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 2, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  %12 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %13 = load double, ptr %12, align 16
  %14 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %15 = load double, ptr %14, align 8
  %call2 = call <2 x i64> @simde__m128i_from_private(double %13, double %15)
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call2
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_x_mm_set_epu16(i16 noundef zeroext %e7, i16 noundef zeroext %e6, i16 noundef zeroext %e5, i16 noundef zeroext %e4, i16 noundef zeroext %e3, i16 noundef zeroext %e2, i16 noundef zeroext %e1, i16 noundef zeroext %e0) #4 {
entry:
  %e7.addr = alloca i16, align 2
  %e6.addr = alloca i16, align 2
  %e5.addr = alloca i16, align 2
  %e4.addr = alloca i16, align 2
  %e3.addr = alloca i16, align 2
  %e2.addr = alloca i16, align 2
  %e1.addr = alloca i16, align 2
  %e0.addr = alloca i16, align 2
  %r_ = alloca %union.simde__m128i_private, align 16
  store i16 %e7, ptr %e7.addr, align 2, !tbaa !31
  store i16 %e6, ptr %e6.addr, align 2, !tbaa !31
  store i16 %e5, ptr %e5.addr, align 2, !tbaa !31
  store i16 %e4, ptr %e4.addr, align 2, !tbaa !31
  store i16 %e3, ptr %e3.addr, align 2, !tbaa !31
  store i16 %e2, ptr %e2.addr, align 2, !tbaa !31
  store i16 %e1, ptr %e1.addr, align 2, !tbaa !31
  store i16 %e0, ptr %e0.addr, align 2, !tbaa !31
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  %0 = load i16, ptr %e0.addr, align 2, !tbaa !31
  %1 = load <8 x i16>, ptr %r_, align 16
  %vecins = insertelement <8 x i16> %1, i16 %0, i32 0
  store <8 x i16> %vecins, ptr %r_, align 16
  %2 = load i16, ptr %e1.addr, align 2, !tbaa !31
  %3 = load <8 x i16>, ptr %r_, align 16
  %vecins1 = insertelement <8 x i16> %3, i16 %2, i32 1
  store <8 x i16> %vecins1, ptr %r_, align 16
  %4 = load i16, ptr %e2.addr, align 2, !tbaa !31
  %5 = load <8 x i16>, ptr %r_, align 16
  %vecins2 = insertelement <8 x i16> %5, i16 %4, i32 2
  store <8 x i16> %vecins2, ptr %r_, align 16
  %6 = load i16, ptr %e3.addr, align 2, !tbaa !31
  %7 = load <8 x i16>, ptr %r_, align 16
  %vecins3 = insertelement <8 x i16> %7, i16 %6, i32 3
  store <8 x i16> %vecins3, ptr %r_, align 16
  %8 = load i16, ptr %e4.addr, align 2, !tbaa !31
  %9 = load <8 x i16>, ptr %r_, align 16
  %vecins4 = insertelement <8 x i16> %9, i16 %8, i32 4
  store <8 x i16> %vecins4, ptr %r_, align 16
  %10 = load i16, ptr %e5.addr, align 2, !tbaa !31
  %11 = load <8 x i16>, ptr %r_, align 16
  %vecins5 = insertelement <8 x i16> %11, i16 %10, i32 5
  store <8 x i16> %vecins5, ptr %r_, align 16
  %12 = load i16, ptr %e6.addr, align 2, !tbaa !31
  %13 = load <8 x i16>, ptr %r_, align 16
  %vecins6 = insertelement <8 x i16> %13, i16 %12, i32 6
  store <8 x i16> %vecins6, ptr %r_, align 16
  %14 = load i16, ptr %e7.addr, align 2, !tbaa !31
  %15 = load <8 x i16>, ptr %r_, align 16
  %vecins7 = insertelement <8 x i16> %15, i16 %14, i32 7
  store <8 x i16> %vecins7, ptr %r_, align 16
  %16 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %17 = load double, ptr %16, align 16
  %18 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %19 = load double, ptr %18, align 8
  %call = call <2 x i64> @simde__m128i_from_private(double %17, double %19)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_cvtepu16_epi32(<2 x i64> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %z = alloca <8 x i16>, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %z) #10
  store <8 x i16> zeroinitializer, ptr %z, align 16, !tbaa !16
  %5 = load <8 x i16>, ptr %a_, align 16, !tbaa !16
  %6 = load <8 x i16>, ptr %z, align 16, !tbaa !16
  %shuffle = shufflevector <8 x i16> %5, <8 x i16> %6, <8 x i32> <i32 0, i32 9, i32 1, i32 11, i32 2, i32 13, i32 3, i32 15>
  %7 = bitcast <8 x i16> %shuffle to <4 x i32>
  store <4 x i32> %7, ptr %r_, align 16, !tbaa !16
  %8 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %9 = load double, ptr %8, align 16
  %10 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %11 = load double, ptr %10, align 8
  %call1 = call <2 x i64> @simde__m128i_from_private(double %9, double %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %z) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_cvtepu16_epi64(<2 x i64> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %z = alloca <8 x i16>, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %z) #10
  store <8 x i16> zeroinitializer, ptr %z, align 16, !tbaa !16
  %5 = load <8 x i16>, ptr %a_, align 16, !tbaa !16
  %6 = load <8 x i16>, ptr %z, align 16, !tbaa !16
  %shuffle = shufflevector <8 x i16> %5, <8 x i16> %6, <8 x i32> <i32 0, i32 9, i32 10, i32 11, i32 1, i32 13, i32 14, i32 15>
  %7 = bitcast <8 x i16> %shuffle to <2 x i64>
  store <2 x i64> %7, ptr %r_, align 16, !tbaa !16
  %8 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %9 = load double, ptr %8, align 16
  %10 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %11 = load double, ptr %10, align 8
  %call1 = call <2 x i64> @simde__m128i_from_private(double %9, double %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %z) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_cvtepi32_epi64(<2 x i64> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  %5 = load <4 x i32>, ptr %a_, align 16, !tbaa !16
  %6 = load <4 x i32>, ptr %a_, align 16, !tbaa !16
  %shuffle = shufflevector <4 x i32> %5, <4 x i32> %6, <4 x i32> <i32 poison, i32 0, i32 poison, i32 1>
  %7 = bitcast <4 x i32> %shuffle to <2 x i64>
  store <2 x i64> %7, ptr %r_, align 16, !tbaa !16
  %8 = load <2 x i64>, ptr %r_, align 16, !tbaa !16
  %shr = ashr <2 x i64> %8, <i64 32, i64 32>
  store <2 x i64> %shr, ptr %r_, align 16, !tbaa !16
  %9 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %10 = load double, ptr %9, align 16
  %11 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %12 = load double, ptr %11, align 8
  %call1 = call <2 x i64> @simde__m128i_from_private(double %10, double %12)
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_cvtepu32_epi64(<2 x i64> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %z = alloca <4 x i32>, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %z) #10
  store <4 x i32> zeroinitializer, ptr %z, align 16, !tbaa !16
  %5 = load <4 x i32>, ptr %a_, align 16, !tbaa !16
  %6 = load <4 x i32>, ptr %z, align 16, !tbaa !16
  %shuffle = shufflevector <4 x i32> %5, <4 x i32> %6, <4 x i32> <i32 0, i32 4, i32 1, i32 6>
  %7 = bitcast <4 x i32> %shuffle to <2 x i64>
  store <2 x i64> %7, ptr %r_, align 16, !tbaa !16
  %8 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %9 = load double, ptr %8, align 16
  %10 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %11 = load double, ptr %10, align 8
  %call1 = call <2 x i64> @simde__m128i_from_private(double %9, double %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %z) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x double> @simde_mm_loadu_pd(ptr noundef %mem_addr) #4 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %r_ = alloca %union.simde__m128d_private, align 16
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  %0 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %r_, ptr align 8 %0, i64 16, i1 false)
  %1 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %2 = load double, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %4 = load double, ptr %3, align 8
  %call = call <2 x double> @simde__m128d_from_private(double %2, double %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x double> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x double> @simde_mm_dp_pd(<2 x double> noundef %a, <2 x double> noundef %b, i32 noundef %imm8) #4 {
entry:
  %a.addr = alloca <2 x double>, align 16
  %b.addr = alloca <2 x double>, align 16
  %imm8.addr = alloca i32, align 4
  %r_ = alloca %union.simde__m128d_private, align 16
  %a_ = alloca %union.simde__m128d_private, align 16
  %b_ = alloca %union.simde__m128d_private, align 16
  %sum = alloca double, align 8
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  %sum3 = alloca double, align 8
  %tmp10 = alloca i64, align 8
  %.omp.iv11 = alloca i64, align 8
  %i12 = alloca i64, align 8
  store <2 x double> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x double> %b, ptr %b.addr, align 16, !tbaa !16
  store i32 %imm8, ptr %imm8.addr, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x double>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128d_to_private(<2 x double> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128d_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x double>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128d_to_private(<2 x double> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128d_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %sum) #10
  store double 0.000000e+00, ptr %sum, align 8, !tbaa !33
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.start.p0(i64 8, ptr %sum3) #10
  store double 0.000000e+00, ptr %sum3, align 8, !tbaa !33
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %10 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !76
  %cmp = icmp ult i64 %10, 2
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !76
  %mul = mul i64 %11, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !76
  %12 = load i32, ptr %imm8.addr, align 4, !tbaa !5, !llvm.access.group !76
  %13 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !76
  %add4 = add i64 %13, 4
  %sh_prom = trunc i64 %add4 to i32
  %shr = ashr i32 %12, %sh_prom
  %and = and i32 %shr, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %omp.inner.for.body
  %14 = load <2 x double>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !76
  %15 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !76
  %vecext = extractelement <2 x double> %14, i64 %15
  %16 = load <2 x double>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !76
  %17 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !76
  %vecext5 = extractelement <2 x double> %16, i64 %17
  %mul6 = fmul double %vecext, %vecext5
  br label %cond.end

cond.false:                                       ; preds = %omp.inner.for.body
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %mul6, %cond.true ], [ 0.000000e+00, %cond.false ]
  %18 = load double, ptr %sum3, align 8, !tbaa !33, !llvm.access.group !76
  %add7 = fadd double %18, %cond
  store double %add7, ptr %sum3, align 8, !tbaa !33, !llvm.access.group !76
  br label %omp.body.continue

omp.body.continue:                                ; preds = %cond.end
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %19 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !76
  %add8 = add i64 %19, 1
  store i64 %add8, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !76
  br label %omp.inner.for.cond, !llvm.loop !77

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 2, ptr %i, align 8, !tbaa !11
  %20 = load double, ptr %sum, align 8, !tbaa !33
  %21 = load double, ptr %sum3, align 8, !tbaa !33
  %add9 = fadd double %20, %21
  store double %add9, ptr %sum, align 8, !tbaa !33
  call void @llvm.lifetime.end.p0(i64 8, ptr %sum3) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv11) #10
  store i64 0, ptr %.omp.iv11, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i12) #10
  br label %omp.inner.for.cond13

omp.inner.for.cond13:                             ; preds = %omp.inner.for.inc28, %omp.inner.for.end
  %22 = load i64, ptr %.omp.iv11, align 8, !tbaa !11, !llvm.access.group !79
  %cmp14 = icmp ult i64 %22, 2
  br i1 %cmp14, label %omp.inner.for.body16, label %omp.inner.for.cond.cleanup15

omp.inner.for.cond.cleanup15:                     ; preds = %omp.inner.for.cond13
  br label %omp.inner.for.end30

omp.inner.for.body16:                             ; preds = %omp.inner.for.cond13
  %23 = load i64, ptr %.omp.iv11, align 8, !tbaa !11, !llvm.access.group !79
  %mul17 = mul i64 %23, 1
  %add18 = add i64 0, %mul17
  store i64 %add18, ptr %i12, align 8, !tbaa !11, !llvm.access.group !79
  %24 = load i32, ptr %imm8.addr, align 4, !tbaa !5, !llvm.access.group !79
  %25 = load i64, ptr %i12, align 8, !tbaa !11, !llvm.access.group !79
  %sh_prom19 = trunc i64 %25 to i32
  %shr20 = ashr i32 %24, %sh_prom19
  %and21 = and i32 %shr20, 1
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %cond.true23, label %cond.false24

cond.true23:                                      ; preds = %omp.inner.for.body16
  %26 = load double, ptr %sum, align 8, !tbaa !33, !llvm.access.group !79
  br label %cond.end25

cond.false24:                                     ; preds = %omp.inner.for.body16
  br label %cond.end25

cond.end25:                                       ; preds = %cond.false24, %cond.true23
  %cond26 = phi double [ %26, %cond.true23 ], [ 0.000000e+00, %cond.false24 ]
  %27 = load i64, ptr %i12, align 8, !tbaa !11, !llvm.access.group !79
  %28 = load <2 x double>, ptr %r_, align 16, !llvm.access.group !79
  %vecins = insertelement <2 x double> %28, double %cond26, i64 %27
  store <2 x double> %vecins, ptr %r_, align 16, !llvm.access.group !79
  br label %omp.body.continue27

omp.body.continue27:                              ; preds = %cond.end25
  br label %omp.inner.for.inc28

omp.inner.for.inc28:                              ; preds = %omp.body.continue27
  %29 = load i64, ptr %.omp.iv11, align 8, !tbaa !11, !llvm.access.group !79
  %add29 = add i64 %29, 1
  store i64 %add29, ptr %.omp.iv11, align 8, !tbaa !11, !llvm.access.group !79
  br label %omp.inner.for.cond13, !llvm.loop !80

omp.inner.for.end30:                              ; preds = %omp.inner.for.cond.cleanup15
  store i64 2, ptr %i12, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i12) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv11) #10
  %30 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %31 = load double, ptr %30, align 16
  %32 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %33 = load double, ptr %32, align 8
  %call31 = call <2 x double> @simde__m128d_from_private(double %31, double %33)
  call void @llvm.lifetime.end.p0(i64 8, ptr %sum) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x double> %call31
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x float> @simde_mm_loadu_ps(ptr noundef %mem_addr) #4 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %r_ = alloca %union.simde__m128_private, align 16
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  %0 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %r_, ptr align 4 %0, i64 16, i1 false)
  %1 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %2 = load double, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %4 = load double, ptr %3, align 8
  %call = call <4 x float> @simde__m128_from_private(double %2, double %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <4 x float> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x float> @simde_mm_dp_ps(<4 x float> noundef %a, <4 x float> noundef %b, i32 noundef %imm8) #4 {
entry:
  %a.addr = alloca <4 x float>, align 16
  %b.addr = alloca <4 x float>, align 16
  %imm8.addr = alloca i32, align 4
  %r_ = alloca %union.simde__m128_private, align 16
  %a_ = alloca %union.simde__m128_private, align 16
  %b_ = alloca %union.simde__m128_private, align 16
  %sum = alloca float, align 4
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  %sum3 = alloca float, align 4
  %tmp10 = alloca i64, align 8
  %.omp.iv11 = alloca i64, align 8
  %i12 = alloca i64, align 8
  store <4 x float> %a, ptr %a.addr, align 16, !tbaa !16
  store <4 x float> %b, ptr %b.addr, align 16, !tbaa !16
  store i32 %imm8, ptr %imm8.addr, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <4 x float>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128_to_private(<4 x float> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <4 x float>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128_to_private(<4 x float> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr %sum) #10
  store float 0.000000e+00, ptr %sum, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.start.p0(i64 4, ptr %sum3) #10
  store float 0.000000e+00, ptr %sum3, align 4, !tbaa !35
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %10 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !82
  %cmp = icmp ult i64 %10, 4
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !82
  %mul = mul i64 %11, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !82
  %12 = load i32, ptr %imm8.addr, align 4, !tbaa !5, !llvm.access.group !82
  %13 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !82
  %add4 = add i64 %13, 4
  %sh_prom = trunc i64 %add4 to i32
  %shr = ashr i32 %12, %sh_prom
  %and = and i32 %shr, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %omp.inner.for.body
  %14 = load <4 x float>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !82
  %15 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !82
  %vecext = extractelement <4 x float> %14, i64 %15
  %16 = load <4 x float>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !82
  %17 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !82
  %vecext5 = extractelement <4 x float> %16, i64 %17
  %mul6 = fmul float %vecext, %vecext5
  br label %cond.end

cond.false:                                       ; preds = %omp.inner.for.body
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ %mul6, %cond.true ], [ 0.000000e+00, %cond.false ]
  %18 = load float, ptr %sum3, align 4, !tbaa !35, !llvm.access.group !82
  %add7 = fadd float %18, %cond
  store float %add7, ptr %sum3, align 4, !tbaa !35, !llvm.access.group !82
  br label %omp.body.continue

omp.body.continue:                                ; preds = %cond.end
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %19 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !82
  %add8 = add i64 %19, 1
  store i64 %add8, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !82
  br label %omp.inner.for.cond, !llvm.loop !83

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 4, ptr %i, align 8, !tbaa !11
  %20 = load float, ptr %sum, align 4, !tbaa !35
  %21 = load float, ptr %sum3, align 4, !tbaa !35
  %add9 = fadd float %20, %21
  store float %add9, ptr %sum, align 4, !tbaa !35
  call void @llvm.lifetime.end.p0(i64 4, ptr %sum3) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv11) #10
  store i64 0, ptr %.omp.iv11, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i12) #10
  br label %omp.inner.for.cond13

omp.inner.for.cond13:                             ; preds = %omp.inner.for.inc28, %omp.inner.for.end
  %22 = load i64, ptr %.omp.iv11, align 8, !tbaa !11, !llvm.access.group !85
  %cmp14 = icmp ult i64 %22, 4
  br i1 %cmp14, label %omp.inner.for.body16, label %omp.inner.for.cond.cleanup15

omp.inner.for.cond.cleanup15:                     ; preds = %omp.inner.for.cond13
  br label %omp.inner.for.end30

omp.inner.for.body16:                             ; preds = %omp.inner.for.cond13
  %23 = load i64, ptr %.omp.iv11, align 8, !tbaa !11, !llvm.access.group !85
  %mul17 = mul i64 %23, 1
  %add18 = add i64 0, %mul17
  store i64 %add18, ptr %i12, align 8, !tbaa !11, !llvm.access.group !85
  %24 = load i32, ptr %imm8.addr, align 4, !tbaa !5, !llvm.access.group !85
  %25 = load i64, ptr %i12, align 8, !tbaa !11, !llvm.access.group !85
  %sh_prom19 = trunc i64 %25 to i32
  %shr20 = ashr i32 %24, %sh_prom19
  %and21 = and i32 %shr20, 1
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %cond.true23, label %cond.false24

cond.true23:                                      ; preds = %omp.inner.for.body16
  %26 = load float, ptr %sum, align 4, !tbaa !35, !llvm.access.group !85
  br label %cond.end25

cond.false24:                                     ; preds = %omp.inner.for.body16
  br label %cond.end25

cond.end25:                                       ; preds = %cond.false24, %cond.true23
  %cond26 = phi float [ %26, %cond.true23 ], [ 0.000000e+00, %cond.false24 ]
  %27 = load i64, ptr %i12, align 8, !tbaa !11, !llvm.access.group !85
  %28 = load <4 x float>, ptr %r_, align 16, !llvm.access.group !85
  %vecins = insertelement <4 x float> %28, float %cond26, i64 %27
  store <4 x float> %vecins, ptr %r_, align 16, !llvm.access.group !85
  br label %omp.body.continue27

omp.body.continue27:                              ; preds = %cond.end25
  br label %omp.inner.for.inc28

omp.inner.for.inc28:                              ; preds = %omp.body.continue27
  %29 = load i64, ptr %.omp.iv11, align 8, !tbaa !11, !llvm.access.group !85
  %add29 = add i64 %29, 1
  store i64 %add29, ptr %.omp.iv11, align 8, !tbaa !11, !llvm.access.group !85
  br label %omp.inner.for.cond13, !llvm.loop !86

omp.inner.for.end30:                              ; preds = %omp.inner.for.cond.cleanup15
  store i64 4, ptr %i12, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i12) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv11) #10
  %30 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %31 = load double, ptr %30, align 16
  %32 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %33 = load double, ptr %32, align 8
  %call31 = call <4 x float> @simde__m128_from_private(double %31, double %33)
  call void @llvm.lifetime.end.p0(i64 4, ptr %sum) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <4 x float> %call31
}

; Function Attrs: alwaysinline nounwind uwtable
define internal signext i8 @simde_mm_extract_epi8(<2 x i64> noundef %a, i32 noundef %imm8) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %imm8.addr = alloca i32, align 4
  %a_ = alloca %union.simde__m128i_private, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store i32 %imm8, ptr %imm8.addr, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  %5 = load <16 x i8>, ptr %a_, align 16, !tbaa !16
  %6 = load i32, ptr %imm8.addr, align 4, !tbaa !5
  %and = and i32 %6, 15
  %vecext = extractelement <16 x i8> %5, i32 %and
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  ret i8 %vecext
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_i8_(i8 noundef signext %a, i8 noundef signext %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8, align 1
  %b.addr = alloca i8, align 1
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  store i8 %a, ptr %a.addr, align 1, !tbaa !16
  store i8 %b, ptr %b.addr, align 1, !tbaa !16
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i8, ptr %a.addr, align 1, !tbaa !16
  %conv = sext i8 %0 to i32
  %1 = load i8, ptr %b.addr, align 1, !tbaa !16
  %conv1 = sext i8 %1 to i32
  %cmp = icmp ne i32 %conv, %conv1
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %3 = load i32, ptr %line.addr, align 4, !tbaa !5
  %4 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %5 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %6 = load i8, ptr %a.addr, align 1, !tbaa !16
  %conv5 = sext i8 %6 to i32
  %7 = load i8, ptr %b.addr, align 1, !tbaa !16
  %conv6 = sext i8 %7 to i32
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.87, ptr noundef %2, i32 noundef %3, ptr noundef %4, ptr noundef %5, i32 noundef %conv5, i32 noundef %conv6)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @simde_mm_extract_epi32(<2 x i64> noundef %a, i32 noundef %imm8) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %imm8.addr = alloca i32, align 4
  %a_ = alloca %union.simde__m128i_private, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store i32 %imm8, ptr %imm8.addr, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  %5 = load <4 x i32>, ptr %a_, align 16, !tbaa !16
  %6 = load i32, ptr %imm8.addr, align 4, !tbaa !5
  %and = and i32 %6, 3
  %vecext = extractelement <4 x i32> %5, i32 %and
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  ret i32 %vecext
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_i32_(i32 noundef %a, i32 noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4, !tbaa !5
  store i32 %b, ptr %b.addr, align 4, !tbaa !5
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i32, ptr %a.addr, align 4, !tbaa !5
  %1 = load i32, ptr %b.addr, align 4, !tbaa !5
  %cmp = icmp ne i32 %0, %1
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %3 = load i32, ptr %line.addr, align 4, !tbaa !5
  %4 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %5 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %6 = load i32, ptr %a.addr, align 4, !tbaa !5
  %7 = load i32, ptr %b.addr, align 4, !tbaa !5
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.87, ptr noundef %2, i32 noundef %3, ptr noundef %4, ptr noundef %5, i32 noundef %6, i32 noundef %7)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i64 @simde_mm_extract_epi64(<2 x i64> noundef %a, i32 noundef %imm8) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %imm8.addr = alloca i32, align 4
  %a_ = alloca %union.simde__m128i_private, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store i32 %imm8, ptr %imm8.addr, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  %5 = load <2 x i64>, ptr %a_, align 16, !tbaa !16
  %6 = load i32, ptr %imm8.addr, align 4, !tbaa !5
  %and = and i32 %6, 1
  %vecext = extractelement <2 x i64> %5, i32 %and
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  ret i64 %vecext
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_i64_(i64 noundef %a, i64 noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8, !tbaa !11
  store i64 %b, ptr %b.addr, align 8, !tbaa !11
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i64, ptr %a.addr, align 8, !tbaa !11
  %1 = load i64, ptr %b.addr, align 8, !tbaa !11
  %cmp = icmp ne i64 %0, %1
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %3 = load i32, ptr %line.addr, align 4, !tbaa !5
  %4 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %5 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %6 = load i64, ptr %a.addr, align 8, !tbaa !11
  %7 = load i64, ptr %b.addr, align 8, !tbaa !11
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.88, ptr noundef %2, i32 noundef %3, ptr noundef %4, ptr noundef %5, i64 noundef %6, i64 noundef %7)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @simde_mm_extract_ps(<4 x float> noundef %a, i32 noundef %imm8) #4 {
entry:
  %a.addr = alloca <4 x float>, align 16
  %imm8.addr = alloca i32, align 4
  %a_ = alloca %union.simde__m128_private, align 16
  store <4 x float> %a, ptr %a.addr, align 16, !tbaa !16
  store i32 %imm8, ptr %imm8.addr, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <4 x float>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128_to_private(<4 x float> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  %5 = load <4 x i32>, ptr %a_, align 16, !tbaa !16
  %6 = load i32, ptr %imm8.addr, align 4, !tbaa !5
  %and = and i32 %6, 3
  %vecext = extractelement <4 x i32> %5, i32 %and
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  ret i32 %vecext
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x double> @simde_mm_floor_pd(<2 x double> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x double>, align 16
  store <2 x double> %a, ptr %a.addr, align 16, !tbaa !16
  %0 = load <2 x double>, ptr %a.addr, align 16, !tbaa !16
  %call = call <2 x double> @simde_mm_round_pd(<2 x double> noundef %0, i32 noundef 1)
  ret <2 x double> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x float> @simde_mm_floor_ps(<4 x float> noundef %a) #4 {
entry:
  %a.addr = alloca <4 x float>, align 16
  store <4 x float> %a, ptr %a.addr, align 16, !tbaa !16
  %0 = load <4 x float>, ptr %a.addr, align 16, !tbaa !16
  %call = call <4 x float> @simde_x_mm_round_ps(<4 x float> noundef %0, i32 noundef 1, i32 noundef 0)
  ret <4 x float> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x double> @simde_mm_floor_sd(<2 x double> noundef %a, <2 x double> noundef %b) #4 {
entry:
  %a.addr = alloca <2 x double>, align 16
  %b.addr = alloca <2 x double>, align 16
  %r_ = alloca %union.simde__m128d_private, align 16
  %a_ = alloca %union.simde__m128d_private, align 16
  %b_ = alloca %union.simde__m128d_private, align 16
  store <2 x double> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x double> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x double>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128d_to_private(<2 x double> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128d_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x double>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128d_to_private(<2 x double> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128d_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  %10 = load <2 x double>, ptr %b_, align 16, !tbaa !16
  %vecext = extractelement <2 x double> %10, i32 0
  %11 = call double @llvm.floor.f64(double %vecext)
  %12 = load <2 x double>, ptr %r_, align 16
  %vecins = insertelement <2 x double> %12, double %11, i32 0
  store <2 x double> %vecins, ptr %r_, align 16
  %13 = load <2 x double>, ptr %a_, align 16, !tbaa !16
  %vecext3 = extractelement <2 x double> %13, i32 1
  %14 = load <2 x double>, ptr %r_, align 16
  %vecins4 = insertelement <2 x double> %14, double %vecext3, i32 1
  store <2 x double> %vecins4, ptr %r_, align 16
  %15 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %16 = load double, ptr %15, align 16
  %17 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %18 = load double, ptr %17, align 8
  %call5 = call <2 x double> @simde__m128d_from_private(double %16, double %18)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x double> %call5
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x float> @simde_mm_floor_ss(<4 x float> noundef %a, <4 x float> noundef %b) #4 {
entry:
  %a.addr = alloca <4 x float>, align 16
  %b.addr = alloca <4 x float>, align 16
  %r_ = alloca %union.simde__m128_private, align 16
  %a_ = alloca %union.simde__m128_private, align 16
  %b_ = alloca %union.simde__m128_private, align 16
  %i = alloca i64, align 8
  store <4 x float> %a, ptr %a.addr, align 16, !tbaa !16
  store <4 x float> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <4 x float>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128_to_private(<4 x float> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <4 x float>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128_to_private(<4 x float> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  %10 = load <4 x float>, ptr %b_, align 16, !tbaa !16
  %vecext = extractelement <4 x float> %10, i32 0
  %11 = call float @llvm.floor.f32(float %vecext)
  %12 = load <4 x float>, ptr %r_, align 16
  %vecins = insertelement <4 x float> %12, float %11, i32 0
  store <4 x float> %vecins, ptr %r_, align 16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 1, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %13 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %13, 4
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  br label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load <4 x float>, ptr %a_, align 16, !tbaa !16
  %15 = load i64, ptr %i, align 8, !tbaa !11
  %vecext3 = extractelement <4 x float> %14, i64 %15
  %16 = load i64, ptr %i, align 8, !tbaa !11
  %17 = load <4 x float>, ptr %r_, align 16
  %vecins4 = insertelement <4 x float> %17, float %vecext3, i64 %16
  store <4 x float> %vecins4, ptr %r_, align 16
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %18 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %18, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.end:                                          ; preds = %for.cond.cleanup
  %19 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %20 = load double, ptr %19, align 16
  %21 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %22 = load double, ptr %21, align 8
  %call5 = call <4 x float> @simde__m128_from_private(double %20, double %22)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <4 x float> %call5
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_insert_epi8(<2 x i64> noundef %a, i32 noundef %i, i32 noundef %imm8) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %i.addr = alloca i32, align 4
  %imm8.addr = alloca i32, align 4
  %r_ = alloca %union.simde__m128i_private, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store i32 %i, ptr %i.addr, align 4, !tbaa !5
  store i32 %imm8, ptr %imm8.addr, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %r_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  %5 = load i32, ptr %i.addr, align 4, !tbaa !5
  %conv = trunc i32 %5 to i8
  %6 = load i32, ptr %imm8.addr, align 4, !tbaa !5
  %7 = load <16 x i8>, ptr %r_, align 16
  %vecins = insertelement <16 x i8> %7, i8 %conv, i32 %6
  store <16 x i8> %vecins, ptr %r_, align 16
  %8 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %9 = load double, ptr %8, align 16
  %10 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %11 = load double, ptr %10, align 8
  %call1 = call <2 x i64> @simde__m128i_from_private(double %9, double %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_insert_epi32(<2 x i64> noundef %a, i32 noundef %i, i32 noundef %imm8) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %i.addr = alloca i32, align 4
  %imm8.addr = alloca i32, align 4
  %r_ = alloca %union.simde__m128i_private, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store i32 %i, ptr %i.addr, align 4, !tbaa !5
  store i32 %imm8, ptr %imm8.addr, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %r_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  %5 = load i32, ptr %i.addr, align 4, !tbaa !5
  %6 = load i32, ptr %imm8.addr, align 4, !tbaa !5
  %7 = load <4 x i32>, ptr %r_, align 16
  %vecins = insertelement <4 x i32> %7, i32 %5, i32 %6
  store <4 x i32> %vecins, ptr %r_, align 16
  %8 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %9 = load double, ptr %8, align 16
  %10 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %11 = load double, ptr %10, align 8
  %call1 = call <2 x i64> @simde__m128i_from_private(double %9, double %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_insert_epi64(<2 x i64> noundef %a, i64 noundef %i, i32 noundef %imm8) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %i.addr = alloca i64, align 8
  %imm8.addr = alloca i32, align 4
  %r_ = alloca %union.simde__m128i_private, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store i64 %i, ptr %i.addr, align 8, !tbaa !11
  store i32 %imm8, ptr %imm8.addr, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %r_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  %5 = load i64, ptr %i.addr, align 8, !tbaa !11
  %6 = load i32, ptr %imm8.addr, align 4, !tbaa !5
  %7 = load <2 x i64>, ptr %r_, align 16
  %vecins = insertelement <2 x i64> %7, i64 %5, i32 %6
  store <2 x i64> %vecins, ptr %r_, align 16
  %8 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %9 = load double, ptr %8, align 16
  %10 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %11 = load double, ptr %10, align 8
  %call1 = call <2 x i64> @simde__m128i_from_private(double %9, double %11)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x float> @simde_mm_insert_ps(<4 x float> noundef %a, <4 x float> noundef %b, i32 noundef %imm8) #4 {
entry:
  %a.addr = alloca <4 x float>, align 16
  %b.addr = alloca <4 x float>, align 16
  %imm8.addr = alloca i32, align 4
  %r_ = alloca %union.simde__m128_private, align 16
  %a_ = alloca %union.simde__m128_private, align 16
  %b_ = alloca %union.simde__m128_private, align 16
  %tmp1_ = alloca float, align 4
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store <4 x float> %a, ptr %a.addr, align 16, !tbaa !16
  store <4 x float> %b, ptr %b.addr, align 16, !tbaa !16
  store i32 %imm8, ptr %imm8.addr, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <4 x float>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128_to_private(<4 x float> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <4 x float>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128_to_private(<4 x float> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr %tmp1_) #10
  %10 = load <4 x float>, ptr %b_, align 16, !tbaa !16
  %11 = load i32, ptr %imm8.addr, align 4, !tbaa !5
  %shr = ashr i32 %11, 6
  %and = and i32 %shr, 3
  %vecext = extractelement <4 x float> %10, i32 %and
  store float %vecext, ptr %tmp1_, align 4, !tbaa !35
  %12 = load float, ptr %tmp1_, align 4, !tbaa !35
  %13 = load i32, ptr %imm8.addr, align 4, !tbaa !5
  %shr3 = ashr i32 %13, 4
  %and4 = and i32 %shr3, 3
  %14 = load <4 x float>, ptr %a_, align 16
  %vecins = insertelement <4 x float> %14, float %12, i32 %and4
  store <4 x float> %vecins, ptr %a_, align 16
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %15 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !88
  %cmp = icmp ult i64 %15, 4
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %16 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !88
  %mul = mul i64 %16, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !88
  %17 = load i32, ptr %imm8.addr, align 4, !tbaa !5, !llvm.access.group !88
  %18 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !88
  %sh_prom = trunc i64 %18 to i32
  %shr5 = ashr i32 %17, %sh_prom
  %and6 = and i32 %shr5, 1
  %tobool = icmp ne i32 %and6, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %omp.inner.for.body
  br label %cond.end

cond.false:                                       ; preds = %omp.inner.for.body
  %19 = load <4 x float>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !88
  %20 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !88
  %vecext7 = extractelement <4 x float> %19, i64 %20
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ 0.000000e+00, %cond.true ], [ %vecext7, %cond.false ]
  %21 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !88
  %22 = load <4 x float>, ptr %r_, align 16, !llvm.access.group !88
  %vecins8 = insertelement <4 x float> %22, float %cond, i64 %21
  store <4 x float> %vecins8, ptr %r_, align 16, !llvm.access.group !88
  br label %omp.body.continue

omp.body.continue:                                ; preds = %cond.end
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %23 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !88
  %add9 = add i64 %23, 1
  store i64 %add9, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !88
  br label %omp.inner.for.cond, !llvm.loop !89

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 4, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  %24 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %25 = load double, ptr %24, align 16
  %26 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %27 = load double, ptr %26, align 8
  %call10 = call <4 x float> @simde__m128_from_private(double %25, double %27)
  call void @llvm.lifetime.end.p0(i64 4, ptr %tmp1_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <4 x float> %call10
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_max_epi8(<2 x i64> noundef %a, <2 x i64> noundef %b) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %10 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !91
  %cmp = icmp ult i64 %10, 16
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !91
  %mul = mul i64 %11, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !91
  %12 = load <16 x i8>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !91
  %13 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !91
  %vecext = extractelement <16 x i8> %12, i64 %13
  %conv = sext i8 %vecext to i32
  %14 = load <16 x i8>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !91
  %15 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !91
  %vecext3 = extractelement <16 x i8> %14, i64 %15
  %conv4 = sext i8 %vecext3 to i32
  %cmp5 = icmp sgt i32 %conv, %conv4
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %omp.inner.for.body
  %16 = load <16 x i8>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !91
  %17 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !91
  %vecext7 = extractelement <16 x i8> %16, i64 %17
  %conv8 = sext i8 %vecext7 to i32
  br label %cond.end

cond.false:                                       ; preds = %omp.inner.for.body
  %18 = load <16 x i8>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !91
  %19 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !91
  %vecext9 = extractelement <16 x i8> %18, i64 %19
  %conv10 = sext i8 %vecext9 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv8, %cond.true ], [ %conv10, %cond.false ]
  %conv11 = trunc i32 %cond to i8
  %20 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !91
  %21 = load <16 x i8>, ptr %r_, align 16, !llvm.access.group !91
  %vecins = insertelement <16 x i8> %21, i8 %conv11, i64 %20
  store <16 x i8> %vecins, ptr %r_, align 16, !llvm.access.group !91
  br label %omp.body.continue

omp.body.continue:                                ; preds = %cond.end
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %22 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !91
  %add12 = add i64 %22, 1
  store i64 %add12, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !91
  br label %omp.inner.for.cond, !llvm.loop !92

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 16, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  %23 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %24 = load double, ptr %23, align 16
  %25 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %26 = load double, ptr %25, align 8
  %call13 = call <2 x i64> @simde__m128i_from_private(double %24, double %26)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call13
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_max_epi32(<2 x i64> noundef %a, <2 x i64> noundef %b) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %10 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !94
  %cmp = icmp ult i64 %10, 4
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !94
  %mul = mul i64 %11, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !94
  %12 = load <4 x i32>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !94
  %13 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !94
  %vecext = extractelement <4 x i32> %12, i64 %13
  %14 = load <4 x i32>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !94
  %15 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !94
  %vecext3 = extractelement <4 x i32> %14, i64 %15
  %cmp4 = icmp sgt i32 %vecext, %vecext3
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %omp.inner.for.body
  %16 = load <4 x i32>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !94
  %17 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !94
  %vecext5 = extractelement <4 x i32> %16, i64 %17
  br label %cond.end

cond.false:                                       ; preds = %omp.inner.for.body
  %18 = load <4 x i32>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !94
  %19 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !94
  %vecext6 = extractelement <4 x i32> %18, i64 %19
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %vecext5, %cond.true ], [ %vecext6, %cond.false ]
  %20 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !94
  %21 = load <4 x i32>, ptr %r_, align 16, !llvm.access.group !94
  %vecins = insertelement <4 x i32> %21, i32 %cond, i64 %20
  store <4 x i32> %vecins, ptr %r_, align 16, !llvm.access.group !94
  br label %omp.body.continue

omp.body.continue:                                ; preds = %cond.end
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %22 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !94
  %add7 = add i64 %22, 1
  store i64 %add7, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !94
  br label %omp.inner.for.cond, !llvm.loop !95

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 4, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  %23 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %24 = load double, ptr %23, align 16
  %25 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %26 = load double, ptr %25, align 8
  %call8 = call <2 x i64> @simde__m128i_from_private(double %24, double %26)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call8
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_max_epu16(<2 x i64> noundef %a, <2 x i64> noundef %b) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %10 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !97
  %cmp = icmp ult i64 %10, 8
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !97
  %mul = mul i64 %11, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !97
  %12 = load <8 x i16>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !97
  %13 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !97
  %vecext = extractelement <8 x i16> %12, i64 %13
  %conv = zext i16 %vecext to i32
  %14 = load <8 x i16>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !97
  %15 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !97
  %vecext3 = extractelement <8 x i16> %14, i64 %15
  %conv4 = zext i16 %vecext3 to i32
  %cmp5 = icmp sgt i32 %conv, %conv4
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %omp.inner.for.body
  %16 = load <8 x i16>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !97
  %17 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !97
  %vecext7 = extractelement <8 x i16> %16, i64 %17
  %conv8 = zext i16 %vecext7 to i32
  br label %cond.end

cond.false:                                       ; preds = %omp.inner.for.body
  %18 = load <8 x i16>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !97
  %19 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !97
  %vecext9 = extractelement <8 x i16> %18, i64 %19
  %conv10 = zext i16 %vecext9 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv8, %cond.true ], [ %conv10, %cond.false ]
  %conv11 = trunc i32 %cond to i16
  %20 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !97
  %21 = load <8 x i16>, ptr %r_, align 16, !llvm.access.group !97
  %vecins = insertelement <8 x i16> %21, i16 %conv11, i64 %20
  store <8 x i16> %vecins, ptr %r_, align 16, !llvm.access.group !97
  br label %omp.body.continue

omp.body.continue:                                ; preds = %cond.end
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %22 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !97
  %add12 = add i64 %22, 1
  store i64 %add12, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !97
  br label %omp.inner.for.cond, !llvm.loop !98

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 8, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  %23 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %24 = load double, ptr %23, align 16
  %25 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %26 = load double, ptr %25, align 8
  %call13 = call <2 x i64> @simde__m128i_from_private(double %24, double %26)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call13
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_x86_assert_equal_u16x8_(<2 x i64> noundef %a, <2 x i64> noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #3 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %a_ = alloca [8 x i16], align 16
  %b_ = alloca [8 x i16], align 16
  %simde_r_ = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %simde_r_1 = alloca ptr, align 8
  %tmp3 = alloca ptr, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_) #10
  %arraydecay = getelementptr inbounds [8 x i16], ptr %a_, i64 0, i64 0
  store ptr %arraydecay, ptr %simde_r_, align 8, !tbaa !9
  %0 = load ptr, ptr %simde_r_, align 8, !tbaa !9
  store ptr %0, ptr %tmp, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_) #10
  %1 = load ptr, ptr %tmp, align 8, !tbaa !9
  %2 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_si128(ptr noundef %1, <2 x i64> noundef %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_1) #10
  %arraydecay2 = getelementptr inbounds [8 x i16], ptr %b_, i64 0, i64 0
  store ptr %arraydecay2, ptr %simde_r_1, align 8, !tbaa !9
  %3 = load ptr, ptr %simde_r_1, align 8, !tbaa !9
  store ptr %3, ptr %tmp3, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_1) #10
  %4 = load ptr, ptr %tmp3, align 8, !tbaa !9
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_si128(ptr noundef %4, <2 x i64> noundef %5)
  %arraydecay4 = getelementptr inbounds [8 x i16], ptr %a_, i64 0, i64 0
  %arraydecay5 = getelementptr inbounds [8 x i16], ptr %b_, i64 0, i64 0
  %6 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %7 = load i32, ptr %line.addr, align 4, !tbaa !5
  %8 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %9 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %call = call i32 @simde_assert_equal_vu16_(i64 noundef 8, ptr noundef %arraydecay4, ptr noundef %arraydecay5, ptr noundef %6, i32 noundef %7, ptr noundef %8, ptr noundef %9)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_vu16_(i64 noundef %vec_len, ptr noundef %a, ptr noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %vec_len.addr = alloca i64, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i64 %vec_len, ptr %vec_len.addr, align 8, !tbaa !11
  store ptr %a, ptr %a.addr, align 8, !tbaa !9
  store ptr %b, ptr %b.addr, align 8, !tbaa !9
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %1 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %3 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds i16, ptr %4, i64 %5
  %6 = load i16, ptr %arrayidx, align 2, !tbaa !31
  %conv = zext i16 %6 to i32
  %7 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx1 = getelementptr inbounds i16, ptr %7, i64 %8
  %9 = load i16, ptr %arrayidx1, align 2, !tbaa !31
  %conv2 = zext i16 %9 to i32
  %cmp3 = icmp ne i32 %conv, %conv2
  %lnot = xor i1 %cmp3, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %10 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %11 = load i32, ptr %line.addr, align 4, !tbaa !5
  %12 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %13 = load i64, ptr %i, align 8, !tbaa !11
  %14 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %15 = load i64, ptr %i, align 8, !tbaa !11
  %16 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %17 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx7 = getelementptr inbounds i16, ptr %16, i64 %17
  %18 = load i16, ptr %arrayidx7, align 2, !tbaa !31
  %conv8 = zext i16 %18 to i32
  %19 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %20 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx9 = getelementptr inbounds i16, ptr %19, i64 %20
  %21 = load i16, ptr %arrayidx9, align 2, !tbaa !31
  %conv10 = zext i16 %21 to i32
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.92, ptr noundef %10, i32 noundef %11, ptr noundef %12, i64 noundef %13, ptr noundef %14, i64 noundef %15, i32 noundef %conv8, i32 noundef %conv10)
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %22 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %22, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup
  %23 = load i32, ptr %retval, align 4
  ret i32 %23

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_max_epu32(<2 x i64> noundef %a, <2 x i64> noundef %b) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %10 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !100
  %cmp = icmp ult i64 %10, 4
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !100
  %mul = mul i64 %11, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !100
  %12 = load <4 x i32>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !100
  %13 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !100
  %vecext = extractelement <4 x i32> %12, i64 %13
  %14 = load <4 x i32>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !100
  %15 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !100
  %vecext3 = extractelement <4 x i32> %14, i64 %15
  %cmp4 = icmp ugt i32 %vecext, %vecext3
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %omp.inner.for.body
  %16 = load <4 x i32>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !100
  %17 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !100
  %vecext5 = extractelement <4 x i32> %16, i64 %17
  br label %cond.end

cond.false:                                       ; preds = %omp.inner.for.body
  %18 = load <4 x i32>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !100
  %19 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !100
  %vecext6 = extractelement <4 x i32> %18, i64 %19
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %vecext5, %cond.true ], [ %vecext6, %cond.false ]
  %20 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !100
  %21 = load <4 x i32>, ptr %r_, align 16, !llvm.access.group !100
  %vecins = insertelement <4 x i32> %21, i32 %cond, i64 %20
  store <4 x i32> %vecins, ptr %r_, align 16, !llvm.access.group !100
  br label %omp.body.continue

omp.body.continue:                                ; preds = %cond.end
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %22 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !100
  %add7 = add i64 %22, 1
  store i64 %add7, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !100
  br label %omp.inner.for.cond, !llvm.loop !101

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 4, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  %23 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %24 = load double, ptr %23, align 16
  %25 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %26 = load double, ptr %25, align 8
  %call8 = call <2 x i64> @simde__m128i_from_private(double %24, double %26)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call8
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_x86_assert_equal_u32x4_(<2 x i64> noundef %a, <2 x i64> noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #3 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %a_ = alloca [4 x i32], align 16
  %b_ = alloca [4 x i32], align 16
  %simde_r_ = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %simde_r_1 = alloca ptr, align 8
  %tmp3 = alloca ptr, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_) #10
  %arraydecay = getelementptr inbounds [4 x i32], ptr %a_, i64 0, i64 0
  store ptr %arraydecay, ptr %simde_r_, align 8, !tbaa !9
  %0 = load ptr, ptr %simde_r_, align 8, !tbaa !9
  store ptr %0, ptr %tmp, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_) #10
  %1 = load ptr, ptr %tmp, align 8, !tbaa !9
  %2 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_si128(ptr noundef %1, <2 x i64> noundef %2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %simde_r_1) #10
  %arraydecay2 = getelementptr inbounds [4 x i32], ptr %b_, i64 0, i64 0
  store ptr %arraydecay2, ptr %simde_r_1, align 8, !tbaa !9
  %3 = load ptr, ptr %simde_r_1, align 8, !tbaa !9
  store ptr %3, ptr %tmp3, align 8, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 8, ptr %simde_r_1) #10
  %4 = load ptr, ptr %tmp3, align 8, !tbaa !9
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  call void @simde_mm_storeu_si128(ptr noundef %4, <2 x i64> noundef %5)
  %arraydecay4 = getelementptr inbounds [4 x i32], ptr %a_, i64 0, i64 0
  %arraydecay5 = getelementptr inbounds [4 x i32], ptr %b_, i64 0, i64 0
  %6 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %7 = load i32, ptr %line.addr, align 4, !tbaa !5
  %8 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %9 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %call = call i32 @simde_assert_equal_vu32_(i64 noundef 4, ptr noundef %arraydecay4, ptr noundef %arraydecay5, ptr noundef %6, i32 noundef %7, ptr noundef %8, ptr noundef %9)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_vu32_(i64 noundef %vec_len, ptr noundef %a, ptr noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %vec_len.addr = alloca i64, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i64 %vec_len, ptr %vec_len.addr, align 8, !tbaa !11
  store ptr %a, ptr %a.addr, align 8, !tbaa !9
  store ptr %b, ptr %b.addr, align 8, !tbaa !9
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %1 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %3 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds i32, ptr %4, i64 %5
  %6 = load i32, ptr %arrayidx, align 4, !tbaa !5
  %7 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx1 = getelementptr inbounds i32, ptr %7, i64 %8
  %9 = load i32, ptr %arrayidx1, align 4, !tbaa !5
  %cmp2 = icmp ne i32 %6, %9
  %lnot = xor i1 %cmp2, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %10 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %11 = load i32, ptr %line.addr, align 4, !tbaa !5
  %12 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %13 = load i64, ptr %i, align 8, !tbaa !11
  %14 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %15 = load i64, ptr %i, align 8, !tbaa !11
  %16 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %17 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx4 = getelementptr inbounds i32, ptr %16, i64 %17
  %18 = load i32, ptr %arrayidx4, align 4, !tbaa !5
  %19 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %20 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx5 = getelementptr inbounds i32, ptr %19, i64 %20
  %21 = load i32, ptr %arrayidx5, align 4, !tbaa !5
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.92, ptr noundef %10, i32 noundef %11, ptr noundef %12, i64 noundef %13, ptr noundef %14, i64 noundef %15, i32 noundef %18, i32 noundef %21)
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %22 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %22, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup
  %23 = load i32, ptr %retval, align 4
  ret i32 %23

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_min_epi8(<2 x i64> noundef %a, <2 x i64> noundef %b) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %10 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !103
  %cmp = icmp ult i64 %10, 16
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !103
  %mul = mul i64 %11, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !103
  %12 = load <16 x i8>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !103
  %13 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !103
  %vecext = extractelement <16 x i8> %12, i64 %13
  %conv = sext i8 %vecext to i32
  %14 = load <16 x i8>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !103
  %15 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !103
  %vecext3 = extractelement <16 x i8> %14, i64 %15
  %conv4 = sext i8 %vecext3 to i32
  %cmp5 = icmp slt i32 %conv, %conv4
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %omp.inner.for.body
  %16 = load <16 x i8>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !103
  %17 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !103
  %vecext7 = extractelement <16 x i8> %16, i64 %17
  %conv8 = sext i8 %vecext7 to i32
  br label %cond.end

cond.false:                                       ; preds = %omp.inner.for.body
  %18 = load <16 x i8>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !103
  %19 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !103
  %vecext9 = extractelement <16 x i8> %18, i64 %19
  %conv10 = sext i8 %vecext9 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv8, %cond.true ], [ %conv10, %cond.false ]
  %conv11 = trunc i32 %cond to i8
  %20 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !103
  %21 = load <16 x i8>, ptr %r_, align 16, !llvm.access.group !103
  %vecins = insertelement <16 x i8> %21, i8 %conv11, i64 %20
  store <16 x i8> %vecins, ptr %r_, align 16, !llvm.access.group !103
  br label %omp.body.continue

omp.body.continue:                                ; preds = %cond.end
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %22 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !103
  %add12 = add i64 %22, 1
  store i64 %add12, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !103
  br label %omp.inner.for.cond, !llvm.loop !104

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 16, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  %23 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %24 = load double, ptr %23, align 16
  %25 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %26 = load double, ptr %25, align 8
  %call13 = call <2 x i64> @simde__m128i_from_private(double %24, double %26)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call13
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_min_epi32(<2 x i64> noundef %a, <2 x i64> noundef %b) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %10 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !106
  %cmp = icmp ult i64 %10, 4
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !106
  %mul = mul i64 %11, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !106
  %12 = load <4 x i32>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !106
  %13 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !106
  %vecext = extractelement <4 x i32> %12, i64 %13
  %14 = load <4 x i32>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !106
  %15 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !106
  %vecext3 = extractelement <4 x i32> %14, i64 %15
  %cmp4 = icmp slt i32 %vecext, %vecext3
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %omp.inner.for.body
  %16 = load <4 x i32>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !106
  %17 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !106
  %vecext5 = extractelement <4 x i32> %16, i64 %17
  br label %cond.end

cond.false:                                       ; preds = %omp.inner.for.body
  %18 = load <4 x i32>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !106
  %19 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !106
  %vecext6 = extractelement <4 x i32> %18, i64 %19
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %vecext5, %cond.true ], [ %vecext6, %cond.false ]
  %20 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !106
  %21 = load <4 x i32>, ptr %r_, align 16, !llvm.access.group !106
  %vecins = insertelement <4 x i32> %21, i32 %cond, i64 %20
  store <4 x i32> %vecins, ptr %r_, align 16, !llvm.access.group !106
  br label %omp.body.continue

omp.body.continue:                                ; preds = %cond.end
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %22 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !106
  %add7 = add i64 %22, 1
  store i64 %add7, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !106
  br label %omp.inner.for.cond, !llvm.loop !107

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 4, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  %23 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %24 = load double, ptr %23, align 16
  %25 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %26 = load double, ptr %25, align 8
  %call8 = call <2 x i64> @simde__m128i_from_private(double %24, double %26)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call8
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_min_epu16(<2 x i64> noundef %a, <2 x i64> noundef %b) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %10 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !109
  %cmp = icmp ult i64 %10, 8
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !109
  %mul = mul i64 %11, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !109
  %12 = load <8 x i16>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !109
  %13 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !109
  %vecext = extractelement <8 x i16> %12, i64 %13
  %conv = zext i16 %vecext to i32
  %14 = load <8 x i16>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !109
  %15 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !109
  %vecext3 = extractelement <8 x i16> %14, i64 %15
  %conv4 = zext i16 %vecext3 to i32
  %cmp5 = icmp slt i32 %conv, %conv4
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %omp.inner.for.body
  %16 = load <8 x i16>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !109
  %17 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !109
  %vecext7 = extractelement <8 x i16> %16, i64 %17
  %conv8 = zext i16 %vecext7 to i32
  br label %cond.end

cond.false:                                       ; preds = %omp.inner.for.body
  %18 = load <8 x i16>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !109
  %19 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !109
  %vecext9 = extractelement <8 x i16> %18, i64 %19
  %conv10 = zext i16 %vecext9 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv8, %cond.true ], [ %conv10, %cond.false ]
  %conv11 = trunc i32 %cond to i16
  %20 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !109
  %21 = load <8 x i16>, ptr %r_, align 16, !llvm.access.group !109
  %vecins = insertelement <8 x i16> %21, i16 %conv11, i64 %20
  store <8 x i16> %vecins, ptr %r_, align 16, !llvm.access.group !109
  br label %omp.body.continue

omp.body.continue:                                ; preds = %cond.end
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %22 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !109
  %add12 = add i64 %22, 1
  store i64 %add12, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !109
  br label %omp.inner.for.cond, !llvm.loop !110

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 8, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  %23 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %24 = load double, ptr %23, align 16
  %25 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %26 = load double, ptr %25, align 8
  %call13 = call <2 x i64> @simde__m128i_from_private(double %24, double %26)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call13
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_min_epu32(<2 x i64> noundef %a, <2 x i64> noundef %b) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %10 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !112
  %cmp = icmp ult i64 %10, 4
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !112
  %mul = mul i64 %11, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !112
  %12 = load <4 x i32>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !112
  %13 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !112
  %vecext = extractelement <4 x i32> %12, i64 %13
  %14 = load <4 x i32>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !112
  %15 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !112
  %vecext3 = extractelement <4 x i32> %14, i64 %15
  %cmp4 = icmp ult i32 %vecext, %vecext3
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %omp.inner.for.body
  %16 = load <4 x i32>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !112
  %17 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !112
  %vecext5 = extractelement <4 x i32> %16, i64 %17
  br label %cond.end

cond.false:                                       ; preds = %omp.inner.for.body
  %18 = load <4 x i32>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !112
  %19 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !112
  %vecext6 = extractelement <4 x i32> %18, i64 %19
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %vecext5, %cond.true ], [ %vecext6, %cond.false ]
  %20 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !112
  %21 = load <4 x i32>, ptr %r_, align 16, !llvm.access.group !112
  %vecins = insertelement <4 x i32> %21, i32 %cond, i64 %20
  store <4 x i32> %vecins, ptr %r_, align 16, !llvm.access.group !112
  br label %omp.body.continue

omp.body.continue:                                ; preds = %cond.end
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %22 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !112
  %add7 = add i64 %22, 1
  store i64 %add7, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !112
  br label %omp.inner.for.cond, !llvm.loop !113

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 4, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  %23 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %24 = load double, ptr %23, align 16
  %25 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %26 = load double, ptr %25, align 8
  %call8 = call <2 x i64> @simde__m128i_from_private(double %24, double %26)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call8
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_minpos_epu16(<2 x i64> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %i = alloca i64, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  %call = call <2 x i64> @simde_mm_setzero_si128()
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %call)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %r_, i32 0, i32 0
  %0 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { double, double } %call1, 0
  store double %1, ptr %0, align 16
  %2 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { double, double } %call1, 1
  store double %3, ptr %2, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %4 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call2 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %4)
  %coerce.dive3 = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %5 = getelementptr inbounds { double, double }, ptr %coerce.dive3, i32 0, i32 0
  %6 = extractvalue { double, double } %call2, 0
  store double %6, ptr %5, align 16
  %7 = getelementptr inbounds { double, double }, ptr %coerce.dive3, i32 0, i32 1
  %8 = extractvalue { double, double } %call2, 1
  store double %8, ptr %7, align 8
  %9 = load <8 x i16>, ptr %r_, align 16
  %vecins = insertelement <8 x i16> %9, i16 -1, i32 0
  store <8 x i16> %vecins, ptr %r_, align 16
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %10, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  br label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load <8 x i16>, ptr %a_, align 16, !tbaa !16
  %12 = load i64, ptr %i, align 8, !tbaa !11
  %vecext = extractelement <8 x i16> %11, i64 %12
  %conv = zext i16 %vecext to i32
  %13 = load <8 x i16>, ptr %r_, align 16, !tbaa !16
  %vecext4 = extractelement <8 x i16> %13, i32 0
  %conv5 = zext i16 %vecext4 to i32
  %cmp6 = icmp slt i32 %conv, %conv5
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %14 = load <8 x i16>, ptr %a_, align 16, !tbaa !16
  %15 = load i64, ptr %i, align 8, !tbaa !11
  %vecext8 = extractelement <8 x i16> %14, i64 %15
  %16 = load <8 x i16>, ptr %r_, align 16
  %vecins9 = insertelement <8 x i16> %16, i16 %vecext8, i32 0
  store <8 x i16> %vecins9, ptr %r_, align 16
  %17 = load i64, ptr %i, align 8, !tbaa !11
  %conv10 = trunc i64 %17 to i16
  %18 = load <8 x i16>, ptr %r_, align 16
  %vecins11 = insertelement <8 x i16> %18, i16 %conv10, i32 1
  store <8 x i16> %vecins11, ptr %r_, align 16
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %19 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %19, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.end:                                          ; preds = %for.cond.cleanup
  %20 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %21 = load double, ptr %20, align 16
  %22 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %23 = load double, ptr %22, align 8
  %call12 = call <2 x i64> @simde__m128i_from_private(double %21, double %23)
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call12
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_setzero_si128() #4 {
entry:
  %r_ = alloca %union.simde__m128i_private, align 16
  %.compoundliteral = alloca <4 x i32>, align 16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  store <4 x i32> zeroinitializer, ptr %.compoundliteral, align 16, !tbaa !16
  %0 = load <4 x i32>, ptr %.compoundliteral, align 16, !tbaa !16
  store <4 x i32> %0, ptr %r_, align 16, !tbaa !16
  %1 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %2 = load double, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %4 = load double, ptr %3, align 8
  %call = call <2 x i64> @simde__m128i_from_private(double %2, double %4)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_mpsadbw_epu8(<2 x i64> noundef %a, <2 x i64> noundef %b, i32 noundef %imm8) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %imm8.addr = alloca i32, align 4
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %a_offset = alloca i32, align 4
  %b_offset = alloca i32, align 4
  %i = alloca i32, align 4
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  store i32 %imm8, ptr %imm8.addr, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr %a_offset) #10
  %10 = load i32, ptr %imm8.addr, align 4, !tbaa !5
  %and = and i32 %10, 4
  store i32 %and, ptr %a_offset, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 4, ptr %b_offset) #10
  %11 = load i32, ptr %imm8.addr, align 4, !tbaa !5
  %and3 = and i32 %11, 3
  %shl = shl i32 %and3, 2
  store i32 %shl, ptr %b_offset, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 4, ptr %i) #10
  store i32 0, ptr %i, align 4, !tbaa !5
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %12 = load i32, ptr %i, align 4, !tbaa !5
  %cmp = icmp slt i32 %12, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  call void @llvm.lifetime.end.p0(i64 4, ptr %i) #10
  br label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load <16 x i8>, ptr %a_, align 16, !tbaa !16
  %14 = load i32, ptr %a_offset, align 4, !tbaa !5
  %15 = load i32, ptr %i, align 4, !tbaa !5
  %add = add nsw i32 %14, %15
  %add4 = add nsw i32 %add, 0
  %vecext = extractelement <16 x i8> %13, i32 %add4
  %conv = zext i8 %vecext to i32
  %16 = load <16 x i8>, ptr %b_, align 16, !tbaa !16
  %17 = load i32, ptr %b_offset, align 4, !tbaa !5
  %add5 = add nsw i32 %17, 0
  %vecext6 = extractelement <16 x i8> %16, i32 %add5
  %conv7 = zext i8 %vecext6 to i32
  %sub = sub nsw i32 %conv, %conv7
  %neg = sub nsw i32 0, %sub
  %abscond = icmp slt i32 %sub, 0
  %abs = select i1 %abscond, i32 %neg, i32 %sub
  %conv8 = trunc i32 %abs to i16
  %conv9 = zext i16 %conv8 to i32
  %18 = load <16 x i8>, ptr %a_, align 16, !tbaa !16
  %19 = load i32, ptr %a_offset, align 4, !tbaa !5
  %20 = load i32, ptr %i, align 4, !tbaa !5
  %add10 = add nsw i32 %19, %20
  %add11 = add nsw i32 %add10, 1
  %vecext12 = extractelement <16 x i8> %18, i32 %add11
  %conv13 = zext i8 %vecext12 to i32
  %21 = load <16 x i8>, ptr %b_, align 16, !tbaa !16
  %22 = load i32, ptr %b_offset, align 4, !tbaa !5
  %add14 = add nsw i32 %22, 1
  %vecext15 = extractelement <16 x i8> %21, i32 %add14
  %conv16 = zext i8 %vecext15 to i32
  %sub17 = sub nsw i32 %conv13, %conv16
  %neg18 = sub nsw i32 0, %sub17
  %abscond19 = icmp slt i32 %sub17, 0
  %abs20 = select i1 %abscond19, i32 %neg18, i32 %sub17
  %conv21 = trunc i32 %abs20 to i16
  %conv22 = zext i16 %conv21 to i32
  %add23 = add nsw i32 %conv9, %conv22
  %23 = load <16 x i8>, ptr %a_, align 16, !tbaa !16
  %24 = load i32, ptr %a_offset, align 4, !tbaa !5
  %25 = load i32, ptr %i, align 4, !tbaa !5
  %add24 = add nsw i32 %24, %25
  %add25 = add nsw i32 %add24, 2
  %vecext26 = extractelement <16 x i8> %23, i32 %add25
  %conv27 = zext i8 %vecext26 to i32
  %26 = load <16 x i8>, ptr %b_, align 16, !tbaa !16
  %27 = load i32, ptr %b_offset, align 4, !tbaa !5
  %add28 = add nsw i32 %27, 2
  %vecext29 = extractelement <16 x i8> %26, i32 %add28
  %conv30 = zext i8 %vecext29 to i32
  %sub31 = sub nsw i32 %conv27, %conv30
  %neg32 = sub nsw i32 0, %sub31
  %abscond33 = icmp slt i32 %sub31, 0
  %abs34 = select i1 %abscond33, i32 %neg32, i32 %sub31
  %conv35 = trunc i32 %abs34 to i16
  %conv36 = zext i16 %conv35 to i32
  %add37 = add nsw i32 %add23, %conv36
  %28 = load <16 x i8>, ptr %a_, align 16, !tbaa !16
  %29 = load i32, ptr %a_offset, align 4, !tbaa !5
  %30 = load i32, ptr %i, align 4, !tbaa !5
  %add38 = add nsw i32 %29, %30
  %add39 = add nsw i32 %add38, 3
  %vecext40 = extractelement <16 x i8> %28, i32 %add39
  %conv41 = zext i8 %vecext40 to i32
  %31 = load <16 x i8>, ptr %b_, align 16, !tbaa !16
  %32 = load i32, ptr %b_offset, align 4, !tbaa !5
  %add42 = add nsw i32 %32, 3
  %vecext43 = extractelement <16 x i8> %31, i32 %add42
  %conv44 = zext i8 %vecext43 to i32
  %sub45 = sub nsw i32 %conv41, %conv44
  %neg46 = sub nsw i32 0, %sub45
  %abscond47 = icmp slt i32 %sub45, 0
  %abs48 = select i1 %abscond47, i32 %neg46, i32 %sub45
  %conv49 = trunc i32 %abs48 to i16
  %conv50 = zext i16 %conv49 to i32
  %add51 = add nsw i32 %add37, %conv50
  %conv52 = trunc i32 %add51 to i16
  %33 = load i32, ptr %i, align 4, !tbaa !5
  %34 = load <8 x i16>, ptr %r_, align 16
  %vecins = insertelement <8 x i16> %34, i16 %conv52, i32 %33
  store <8 x i16> %vecins, ptr %r_, align 16
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %35 = load i32, ptr %i, align 4, !tbaa !5
  %inc = add nsw i32 %35, 1
  store i32 %inc, ptr %i, align 4, !tbaa !5
  br label %for.cond

for.end:                                          ; preds = %for.cond.cleanup
  %36 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %37 = load double, ptr %36, align 16
  %38 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %39 = load double, ptr %38, align 8
  %call53 = call <2 x i64> @simde__m128i_from_private(double %37, double %39)
  call void @llvm.lifetime.end.p0(i64 4, ptr %b_offset) #10
  call void @llvm.lifetime.end.p0(i64 4, ptr %a_offset) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call53
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_mul_epi32(<2 x i64> noundef %a, <2 x i64> noundef %b) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %10 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !115
  %cmp = icmp ult i64 %10, 2
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !115
  %mul = mul i64 %11, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !115
  %12 = load <4 x i32>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !115
  %13 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !115
  %mul3 = mul i64 %13, 2
  %vecext = extractelement <4 x i32> %12, i64 %mul3
  %conv = sext i32 %vecext to i64
  %14 = load <4 x i32>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !115
  %15 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !115
  %mul4 = mul i64 %15, 2
  %vecext5 = extractelement <4 x i32> %14, i64 %mul4
  %conv6 = sext i32 %vecext5 to i64
  %mul7 = mul nsw i64 %conv, %conv6
  %16 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !115
  %17 = load <2 x i64>, ptr %r_, align 16, !llvm.access.group !115
  %vecins = insertelement <2 x i64> %17, i64 %mul7, i64 %16
  store <2 x i64> %vecins, ptr %r_, align 16, !llvm.access.group !115
  br label %omp.body.continue

omp.body.continue:                                ; preds = %omp.inner.for.body
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %18 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !115
  %add8 = add i64 %18, 1
  store i64 %add8, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !115
  br label %omp.inner.for.cond, !llvm.loop !116

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 2, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  %19 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %20 = load double, ptr %19, align 16
  %21 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %22 = load double, ptr %21, align 8
  %call9 = call <2 x i64> @simde__m128i_from_private(double %20, double %22)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call9
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_mullo_epi32(<2 x i64> noundef %a, <2 x i64> noundef %b) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %10 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !118
  %cmp = icmp ult i64 %10, 4
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !118
  %mul = mul i64 %11, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !118
  %12 = load <4 x i32>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !118
  %13 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !118
  %vecext = extractelement <4 x i32> %12, i64 %13
  %conv = sext i32 %vecext to i64
  %14 = load <4 x i32>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !118
  %15 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !118
  %vecext3 = extractelement <4 x i32> %14, i64 %15
  %conv4 = sext i32 %vecext3 to i64
  %mul5 = mul nsw i64 %conv, %conv4
  %and = and i64 %mul5, 4294967295
  %conv6 = trunc i64 %and to i32
  %16 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !118
  %17 = load <4 x i32>, ptr %r_, align 16, !llvm.access.group !118
  %vecins = insertelement <4 x i32> %17, i32 %conv6, i64 %16
  store <4 x i32> %vecins, ptr %r_, align 16, !llvm.access.group !118
  br label %omp.body.continue

omp.body.continue:                                ; preds = %omp.inner.for.body
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %18 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !118
  %add7 = add i64 %18, 1
  store i64 %add7, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !118
  br label %omp.inner.for.cond, !llvm.loop !119

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 4, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  %19 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %20 = load double, ptr %19, align 16
  %21 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %22 = load double, ptr %21, align 8
  %call8 = call <2 x i64> @simde__m128i_from_private(double %20, double %22)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call8
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_x_mm_mullo_epu32(<2 x i64> noundef %a, <2 x i64> noundef %b) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  %10 = load <4 x i32>, ptr %a_, align 16, !tbaa !16
  %11 = load <4 x i32>, ptr %b_, align 16, !tbaa !16
  %mul = mul <4 x i32> %10, %11
  store <4 x i32> %mul, ptr %r_, align 16, !tbaa !16
  %12 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %13 = load double, ptr %12, align 16
  %14 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %15 = load double, ptr %14, align 8
  %call3 = call <2 x i64> @simde__m128i_from_private(double %13, double %15)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call3
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_packus_epi32(<2 x i64> noundef %a, <2 x i64> noundef %b) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %v = alloca <8 x i32>, align 32
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 32, ptr %v) #10
  %10 = load <4 x i32>, ptr %a_, align 16, !tbaa !16
  %11 = load <4 x i32>, ptr %b_, align 16, !tbaa !16
  %shuffle = shufflevector <4 x i32> %10, <4 x i32> %11, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  store <8 x i32> %shuffle, ptr %v, align 32, !tbaa !16
  %12 = load <8 x i32>, ptr %v, align 32, !tbaa !16
  %shr = ashr <8 x i32> %12, <i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31, i32 31>
  %not = xor <8 x i32> %shr, <i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1, i32 -1>
  %13 = load <8 x i32>, ptr %v, align 32, !tbaa !16
  %and = and <8 x i32> %13, %not
  store <8 x i32> %and, ptr %v, align 32, !tbaa !16
  %14 = load <8 x i32>, ptr %v, align 32, !tbaa !16
  %cmp = icmp sgt <8 x i32> %14, <i32 65535, i32 65535, i32 65535, i32 65535, i32 65535, i32 65535, i32 65535, i32 65535>
  %sext = sext <8 x i1> %cmp to <8 x i32>
  %15 = load <8 x i32>, ptr %v, align 32, !tbaa !16
  %or = or <8 x i32> %15, %sext
  store <8 x i32> %or, ptr %v, align 32, !tbaa !16
  %16 = load <8 x i32>, ptr %v, align 32, !tbaa !16
  %conv = trunc <8 x i32> %16 to <8 x i16>
  store <8 x i16> %conv, ptr %r_, align 16, !tbaa !16
  %17 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %18 = load double, ptr %17, align 16
  %19 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %20 = load double, ptr %19, align 8
  %call3 = call <2 x i64> @simde__m128i_from_private(double %18, double %20)
  call void @llvm.lifetime.end.p0(i64 32, ptr %v) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  ret <2 x i64> %call3
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x double> @simde_mm_round_sd(<2 x double> noundef %a, <2 x double> noundef %b, i32 noundef %rounding) #4 {
entry:
  %a.addr = alloca <2 x double>, align 16
  %b.addr = alloca <2 x double>, align 16
  %rounding.addr = alloca i32, align 4
  %r_ = alloca %union.simde__m128d_private, align 16
  %b_ = alloca %union.simde__m128d_private, align 16
  store <2 x double> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x double> %b, ptr %b.addr, align 16, !tbaa !16
  store i32 %rounding, ptr %rounding.addr, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  %0 = load <2 x double>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128d_to_private(<2 x double> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128d_private, ptr %r_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x double>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128d_to_private(<2 x double> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128d_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  %10 = load i32, ptr %rounding.addr, align 4, !tbaa !5
  %and = and i32 %10, -9
  switch i32 %and, label %sw.default [
    i32 0, label %sw.bb
    i32 4, label %sw.bb
    i32 1, label %sw.bb3
    i32 2, label %sw.bb6
    i32 3, label %sw.bb9
  ]

sw.bb:                                            ; preds = %entry, %entry
  %11 = load <2 x double>, ptr %b_, align 16, !tbaa !16
  %vecext = extractelement <2 x double> %11, i32 0
  %12 = call double @llvm.nearbyint.f64(double %vecext)
  %13 = load <2 x double>, ptr %r_, align 16
  %vecins = insertelement <2 x double> %13, double %12, i32 0
  store <2 x double> %vecins, ptr %r_, align 16
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  %14 = load <2 x double>, ptr %b_, align 16, !tbaa !16
  %vecext4 = extractelement <2 x double> %14, i32 0
  %15 = call double @llvm.floor.f64(double %vecext4)
  %16 = load <2 x double>, ptr %r_, align 16
  %vecins5 = insertelement <2 x double> %16, double %15, i32 0
  store <2 x double> %vecins5, ptr %r_, align 16
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %17 = load <2 x double>, ptr %b_, align 16, !tbaa !16
  %vecext7 = extractelement <2 x double> %17, i32 0
  %18 = call double @llvm.ceil.f64(double %vecext7)
  %19 = load <2 x double>, ptr %r_, align 16
  %vecins8 = insertelement <2 x double> %19, double %18, i32 0
  store <2 x double> %vecins8, ptr %r_, align 16
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  %20 = load <2 x double>, ptr %b_, align 16, !tbaa !16
  %vecext10 = extractelement <2 x double> %20, i32 0
  %21 = call double @llvm.trunc.f64(double %vecext10)
  %22 = load <2 x double>, ptr %r_, align 16
  %vecins11 = insertelement <2 x double> %22, double %21, i32 0
  store <2 x double> %vecins11, ptr %r_, align 16
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  unreachable

sw.epilog:                                        ; preds = %sw.bb9, %sw.bb6, %sw.bb3, %sw.bb
  %23 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %24 = load double, ptr %23, align 16
  %25 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %26 = load double, ptr %25, align 8
  %call12 = call <2 x double> @simde__m128d_from_private(double %24, double %26)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x double> %call12
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x float> @simde_mm_round_ss(<4 x float> noundef %a, <4 x float> noundef %b, i32 noundef %rounding) #4 {
entry:
  %a.addr = alloca <4 x float>, align 16
  %b.addr = alloca <4 x float>, align 16
  %rounding.addr = alloca i32, align 4
  %r_ = alloca %union.simde__m128_private, align 16
  %b_ = alloca %union.simde__m128_private, align 16
  store <4 x float> %a, ptr %a.addr, align 16, !tbaa !16
  store <4 x float> %b, ptr %b.addr, align 16, !tbaa !16
  store i32 %rounding, ptr %rounding.addr, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  %0 = load <4 x float>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128_to_private(<4 x float> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128_private, ptr %r_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <4 x float>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128_to_private(<4 x float> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  %10 = load i32, ptr %rounding.addr, align 4, !tbaa !5
  %and = and i32 %10, -9
  switch i32 %and, label %sw.default [
    i32 0, label %sw.bb
    i32 4, label %sw.bb
    i32 1, label %sw.bb3
    i32 2, label %sw.bb6
    i32 3, label %sw.bb9
  ]

sw.bb:                                            ; preds = %entry, %entry
  %11 = load <4 x float>, ptr %b_, align 16, !tbaa !16
  %vecext = extractelement <4 x float> %11, i32 0
  %12 = call float @llvm.nearbyint.f32(float %vecext)
  %13 = load <4 x float>, ptr %r_, align 16
  %vecins = insertelement <4 x float> %13, float %12, i32 0
  store <4 x float> %vecins, ptr %r_, align 16
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  %14 = load <4 x float>, ptr %b_, align 16, !tbaa !16
  %vecext4 = extractelement <4 x float> %14, i32 0
  %15 = call float @llvm.floor.f32(float %vecext4)
  %16 = load <4 x float>, ptr %r_, align 16
  %vecins5 = insertelement <4 x float> %16, float %15, i32 0
  store <4 x float> %vecins5, ptr %r_, align 16
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %17 = load <4 x float>, ptr %b_, align 16, !tbaa !16
  %vecext7 = extractelement <4 x float> %17, i32 0
  %18 = call float @llvm.ceil.f32(float %vecext7)
  %19 = load <4 x float>, ptr %r_, align 16
  %vecins8 = insertelement <4 x float> %19, float %18, i32 0
  store <4 x float> %vecins8, ptr %r_, align 16
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  %20 = load <4 x float>, ptr %b_, align 16, !tbaa !16
  %vecext10 = extractelement <4 x float> %20, i32 0
  %21 = call float @llvm.trunc.f32(float %vecext10)
  %22 = load <4 x float>, ptr %r_, align 16
  %vecins11 = insertelement <4 x float> %22, float %21, i32 0
  store <4 x float> %vecins11, ptr %r_, align 16
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  unreachable

sw.epilog:                                        ; preds = %sw.bb9, %sw.bb6, %sw.bb3, %sw.bb
  %23 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %24 = load double, ptr %23, align 16
  %25 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %26 = load double, ptr %25, align 8
  %call12 = call <4 x float> @simde__m128_from_private(double %24, double %26)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <4 x float> %call12
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_stream_load_si128(ptr noundef %mem_addr) #4 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  %0 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  %1 = load <2 x i64>, ptr %0, align 16, !tbaa !16
  ret <2 x i64> %1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @simde_mm_test_all_ones(<2 x i64> noundef %a) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %r = alloca i32, align 4
  %r_ = alloca i64, align 8
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  %r_1 = alloca i64, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr %r) #10
  call void @llvm.lifetime.start.p0(i64 8, ptr %r_) #10
  store i64 -1, ptr %r_, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.start.p0(i64 8, ptr %r_1) #10
  store i64 -1, ptr %r_1, align 8, !tbaa !11
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %5 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !121
  %cmp = icmp ult i64 %5, 2
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %6 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !121
  %mul = mul i64 %6, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !121
  %7 = load <2 x i64>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !121
  %8 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !121
  %vecext = extractelement <2 x i64> %7, i64 %8
  %9 = load i64, ptr %r_1, align 8, !tbaa !11, !llvm.access.group !121
  %and = and i64 %9, %vecext
  store i64 %and, ptr %r_1, align 8, !tbaa !11, !llvm.access.group !121
  br label %omp.body.continue

omp.body.continue:                                ; preds = %omp.inner.for.body
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %10 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !121
  %add2 = add i64 %10, 1
  store i64 %add2, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !121
  br label %omp.inner.for.cond, !llvm.loop !122

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 2, ptr %i, align 8, !tbaa !11
  %11 = load i64, ptr %r_, align 8, !tbaa !11
  %12 = load i64, ptr %r_1, align 8, !tbaa !11
  %and3 = and i64 %11, %12
  store i64 %and3, ptr %r_, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %r_1) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  %13 = load i64, ptr %r_, align 8, !tbaa !11
  %cmp4 = icmp eq i64 %13, -1
  %conv = zext i1 %cmp4 to i32
  store i32 %conv, ptr %r, align 4, !tbaa !5
  %14 = load i32, ptr %r, align 4, !tbaa !5
  call void @llvm.lifetime.end.p0(i64 8, ptr %r_) #10
  call void @llvm.lifetime.end.p0(i64 4, ptr %r) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  ret i32 %14
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_i_(i32 noundef %a, i32 noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4, !tbaa !5
  store i32 %b, ptr %b.addr, align 4, !tbaa !5
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i32, ptr %a.addr, align 4, !tbaa !5
  %1 = load i32, ptr %b.addr, align 4, !tbaa !5
  %cmp = icmp ne i32 %0, %1
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %3 = load i32, ptr %line.addr, align 4, !tbaa !5
  %4 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %5 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %6 = load i32, ptr %a.addr, align 4, !tbaa !5
  %7 = load i32, ptr %b.addr, align 4, !tbaa !5
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.87, ptr noundef %2, i32 noundef %3, ptr noundef %4, ptr noundef %5, i32 noundef %6, i32 noundef %7)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @simde_mm_test_all_zeros(<2 x i64> noundef %a, <2 x i64> noundef %mask) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %mask.addr = alloca <2 x i64>, align 16
  %tmp_ = alloca %union.simde__m128i_private, align 16
  %r = alloca i32, align 4
  %r_ = alloca i64, align 8
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  %r_2 = alloca i64, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %mask, ptr %mask.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %tmp_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %1 = load <2 x i64>, ptr %mask.addr, align 16, !tbaa !16
  %call = call <2 x i64> @simde_mm_and_si128(<2 x i64> noundef %0, <2 x i64> noundef %1)
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %call)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %tmp_, i32 0, i32 0
  %2 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %3 = extractvalue { double, double } %call1, 0
  store double %3, ptr %2, align 16
  %4 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %5 = extractvalue { double, double } %call1, 1
  store double %5, ptr %4, align 8
  call void @llvm.lifetime.start.p0(i64 4, ptr %r) #10
  call void @llvm.lifetime.start.p0(i64 8, ptr %r_) #10
  store i64 0, ptr %r_, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.start.p0(i64 8, ptr %r_2) #10
  store i64 0, ptr %r_2, align 8, !tbaa !11
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %6 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !124
  %cmp = icmp ult i64 %6, 2
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %7 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !124
  %mul = mul i64 %7, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !124
  %8 = load <2 x i64>, ptr %tmp_, align 16, !tbaa !16, !llvm.access.group !124
  %9 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !124
  %vecext = extractelement <2 x i64> %8, i64 %9
  %10 = load i64, ptr %r_2, align 8, !tbaa !11, !llvm.access.group !124
  %or = or i64 %10, %vecext
  store i64 %or, ptr %r_2, align 8, !tbaa !11, !llvm.access.group !124
  br label %omp.body.continue

omp.body.continue:                                ; preds = %omp.inner.for.body
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !124
  %add3 = add i64 %11, 1
  store i64 %add3, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !124
  br label %omp.inner.for.cond, !llvm.loop !125

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 2, ptr %i, align 8, !tbaa !11
  %12 = load i64, ptr %r_, align 8, !tbaa !11
  %13 = load i64, ptr %r_2, align 8, !tbaa !11
  %or4 = or i64 %12, %13
  store i64 %or4, ptr %r_, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %r_2) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  %14 = load i64, ptr %r_, align 8, !tbaa !11
  %tobool = icmp ne i64 %14, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, ptr %r, align 4, !tbaa !5
  %15 = load i32, ptr %r, align 4, !tbaa !5
  call void @llvm.lifetime.end.p0(i64 8, ptr %r_) #10
  call void @llvm.lifetime.end.p0(i64 4, ptr %r) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %tmp_) #10
  ret i32 %15
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_and_si128(<2 x i64> noundef %a, <2 x i64> noundef %b) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #10
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  %10 = load <2 x i64>, ptr %a_, align 16, !tbaa !16
  %11 = load <2 x i64>, ptr %b_, align 16, !tbaa !16
  %and = and <2 x i64> %10, %11
  store <2 x i64> %and, ptr %r_, align 16, !tbaa !16
  %12 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %13 = load double, ptr %12, align 16
  %14 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %15 = load double, ptr %14, align 8
  %call3 = call <2 x i64> @simde__m128i_from_private(double %13, double %15)
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #10
  ret <2 x i64> %call3
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @simde_mm_test_mix_ones_zeros(<2 x i64> noundef %a, <2 x i64> noundef %mask) #4 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca <2 x i64>, align 16
  %mask.addr = alloca <2 x i64>, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %mask_ = alloca %union.simde__m128i_private, align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %mask, ptr %mask.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %mask_) #10
  %5 = load <2 x i64>, ptr %mask.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %mask_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %10, 2
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

for.body:                                         ; preds = %for.cond
  %11 = load <2 x i64>, ptr %a_, align 16, !tbaa !16
  %12 = load i64, ptr %i, align 8, !tbaa !11
  %vecext = extractelement <2 x i64> %11, i64 %12
  %13 = load <2 x i64>, ptr %mask_, align 16, !tbaa !16
  %14 = load i64, ptr %i, align 8, !tbaa !11
  %vecext3 = extractelement <2 x i64> %13, i64 %14
  %and = and i64 %vecext, %vecext3
  %cmp4 = icmp ne i64 %and, 0
  br i1 %cmp4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %15 = load <2 x i64>, ptr %a_, align 16, !tbaa !16
  %16 = load i64, ptr %i, align 8, !tbaa !11
  %vecext5 = extractelement <2 x i64> %15, i64 %16
  %not = xor i64 %vecext5, -1
  %17 = load <2 x i64>, ptr %mask_, align 16, !tbaa !16
  %18 = load i64, ptr %i, align 8, !tbaa !11
  %vecext6 = extractelement <2 x i64> %17, i64 %18
  %and7 = and i64 %not, %vecext6
  %cmp8 = icmp ne i64 %and7, 0
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %19 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %19, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup9 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup9

cleanup9:                                         ; preds = %for.end, %cleanup
  call void @llvm.lifetime.end.p0(i64 16, ptr %mask_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  %20 = load i32, ptr %retval, align 4
  ret i32 %20
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @simde_mm_testc_si128(<2 x i64> noundef %a, <2 x i64> noundef %b) #4 {
entry:
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %r = alloca i64, align 8
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  %r3 = alloca i64, align 8
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %r) #10
  store i64 0, ptr %r, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #10
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.start.p0(i64 8, ptr %r3) #10
  store i64 0, ptr %r3, align 8, !tbaa !11
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %10 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !127
  %cmp = icmp ult i64 %10, 2
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !127
  %mul = mul i64 %11, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !127
  %12 = load <2 x i64>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !127
  %13 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !127
  %vecext = extractelement <2 x i64> %12, i64 %13
  %not = xor i64 %vecext, -1
  %14 = load <2 x i64>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !127
  %15 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !127
  %vecext4 = extractelement <2 x i64> %14, i64 %15
  %and = and i64 %not, %vecext4
  %16 = load i64, ptr %r3, align 8, !tbaa !11, !llvm.access.group !127
  %or = or i64 %16, %and
  store i64 %or, ptr %r3, align 8, !tbaa !11, !llvm.access.group !127
  br label %omp.body.continue

omp.body.continue:                                ; preds = %omp.inner.for.body
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %17 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !127
  %add5 = add i64 %17, 1
  store i64 %add5, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !127
  br label %omp.inner.for.cond, !llvm.loop !128

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 2, ptr %i, align 8, !tbaa !11
  %18 = load i64, ptr %r, align 8, !tbaa !11
  %19 = load i64, ptr %r3, align 8, !tbaa !11
  %or6 = or i64 %18, %19
  store i64 %or6, ptr %r, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %r3) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #10
  %20 = load i64, ptr %r, align 8, !tbaa !11
  %tobool = icmp ne i64 %20, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  call void @llvm.lifetime.end.p0(i64 8, ptr %r) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  ret i32 %lnot.ext
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @simde_mm_testnzc_si128(<2 x i64> noundef %a, <2 x i64> noundef %b) #4 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %10, 2
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

for.body:                                         ; preds = %for.cond
  %11 = load <2 x i64>, ptr %a_, align 16, !tbaa !16
  %12 = load i64, ptr %i, align 8, !tbaa !11
  %vecext = extractelement <2 x i64> %11, i64 %12
  %13 = load <2 x i64>, ptr %b_, align 16, !tbaa !16
  %14 = load i64, ptr %i, align 8, !tbaa !11
  %vecext3 = extractelement <2 x i64> %13, i64 %14
  %and = and i64 %vecext, %vecext3
  %cmp4 = icmp ne i64 %and, 0
  br i1 %cmp4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %15 = load <2 x i64>, ptr %a_, align 16, !tbaa !16
  %16 = load i64, ptr %i, align 8, !tbaa !11
  %vecext5 = extractelement <2 x i64> %15, i64 %16
  %not = xor i64 %vecext5, -1
  %17 = load <2 x i64>, ptr %b_, align 16, !tbaa !16
  %18 = load i64, ptr %i, align 8, !tbaa !11
  %vecext6 = extractelement <2 x i64> %17, i64 %18
  %and7 = and i64 %not, %vecext6
  %cmp8 = icmp ne i64 %and7, 0
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %19 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %19, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup9 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup9

cleanup9:                                         ; preds = %for.end, %cleanup
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  %20 = load i32, ptr %retval, align 4
  ret i32 %20
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @simde_mm_testz_si128(<2 x i64> noundef %a, <2 x i64> noundef %b) #4 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca <2 x i64>, align 16
  %b.addr = alloca <2 x i64>, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %b_ = alloca %union.simde__m128i_private, align 16
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x i64> %b, ptr %b.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #10
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #10
  %5 = load <2 x i64>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #10
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %10, 2
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

for.body:                                         ; preds = %for.cond
  %11 = load <2 x i64>, ptr %a_, align 16, !tbaa !16
  %12 = load i64, ptr %i, align 8, !tbaa !11
  %vecext = extractelement <2 x i64> %11, i64 %12
  %13 = load <2 x i64>, ptr %b_, align 16, !tbaa !16
  %14 = load i64, ptr %i, align 8, !tbaa !11
  %vecext3 = extractelement <2 x i64> %13, i64 %14
  %and = and i64 %vecext, %vecext3
  %cmp4 = icmp eq i64 %and, 0
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %15 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %15, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #10
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup5 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup5

cleanup5:                                         ; preds = %for.end, %cleanup
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #10
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #10
  %16 = load i32, ptr %retval, align 4
  ret i32 %16
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_start.p0(ptr) #9

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_end.p0(ptr) #9

attributes #0 = { nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind uwtable "min-legal-vector-width"="128" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { alwaysinline nounwind uwtable "min-legal-vector-width"="128" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #6 = { nocallback nofree nosync nounwind willreturn memory(none) }
attributes #7 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #8 = { nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { nocallback nofree nosync nounwind willreturn }
attributes #10 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"clang version 18.0.0 (https://github.com/llvm-ml/llvm-project b452eb491a2ae09c12cc88b715f003377cec543b)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = !{!10, !10, i64 0}
!10 = !{!"any pointer", !7, i64 0}
!11 = !{!12, !12, i64 0}
!12 = !{!"long", !7, i64 0}
!13 = !{!14, !10, i64 0}
!14 = !{!"", !10, i64 0, !10, i64 8}
!15 = !{!14, !10, i64 8}
!16 = !{!7, !7, i64 0}
!17 = !{!18, !7, i64 16}
!18 = !{!"", !7, i64 0, !7, i64 16}
!19 = !{!20, !6, i64 16}
!20 = !{!"", !7, i64 0, !6, i64 16}
!21 = !{!22, !12, i64 16}
!22 = !{!"", !7, i64 0, !12, i64 16}
!23 = !{!24, !6, i64 16}
!24 = !{!"", !7, i64 0, !6, i64 16, !7, i64 32}
!25 = !{!26, !12, i64 16}
!26 = !{!"", !7, i64 0, !12, i64 16, !7, i64 32}
!27 = !{!28, !6, i64 32}
!28 = !{!"", !7, i64 0, !7, i64 16, !6, i64 32, !7, i64 48}
!29 = !{!30, !6, i64 32}
!30 = !{!"", !7, i64 0, !7, i64 16, !6, i64 32}
!31 = !{!32, !32, i64 0}
!32 = !{!"short", !7, i64 0}
!33 = !{!34, !34, i64 0}
!34 = !{!"double", !7, i64 0}
!35 = !{!36, !36, i64 0}
!36 = !{!"float", !7, i64 0}
!37 = distinct !{}
!38 = distinct !{!38, !39, !40}
!39 = !{!"llvm.loop.parallel_accesses", !37}
!40 = !{!"llvm.loop.vectorize.enable", i1 true}
!41 = distinct !{}
!42 = distinct !{!42, !43, !40}
!43 = !{!"llvm.loop.parallel_accesses", !41}
!44 = distinct !{}
!45 = distinct !{!45, !46, !40}
!46 = !{!"llvm.loop.parallel_accesses", !44}
!47 = distinct !{}
!48 = distinct !{!48, !49, !40}
!49 = !{!"llvm.loop.parallel_accesses", !47}
!50 = distinct !{}
!51 = distinct !{!51, !52, !40}
!52 = !{!"llvm.loop.parallel_accesses", !50}
!53 = distinct !{}
!54 = distinct !{!54, !55, !40}
!55 = !{!"llvm.loop.parallel_accesses", !53}
!56 = distinct !{}
!57 = distinct !{!57, !58, !40}
!58 = !{!"llvm.loop.parallel_accesses", !56}
!59 = distinct !{}
!60 = distinct !{!60, !61, !40}
!61 = !{!"llvm.loop.parallel_accesses", !59}
!62 = distinct !{}
!63 = distinct !{!63, !64, !40}
!64 = !{!"llvm.loop.parallel_accesses", !62}
!65 = distinct !{}
!66 = distinct !{!66, !67, !40}
!67 = !{!"llvm.loop.parallel_accesses", !65}
!68 = !{i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16}
!69 = !{i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16, i64 0, i64 16, !16}
!70 = distinct !{}
!71 = distinct !{!71, !72, !40}
!72 = !{!"llvm.loop.parallel_accesses", !70}
!73 = distinct !{}
!74 = distinct !{!74, !75, !40}
!75 = !{!"llvm.loop.parallel_accesses", !73}
!76 = distinct !{}
!77 = distinct !{!77, !78, !40}
!78 = !{!"llvm.loop.parallel_accesses", !76}
!79 = distinct !{}
!80 = distinct !{!80, !81, !40}
!81 = !{!"llvm.loop.parallel_accesses", !79}
!82 = distinct !{}
!83 = distinct !{!83, !84, !40}
!84 = !{!"llvm.loop.parallel_accesses", !82}
!85 = distinct !{}
!86 = distinct !{!86, !87, !40}
!87 = !{!"llvm.loop.parallel_accesses", !85}
!88 = distinct !{}
!89 = distinct !{!89, !90, !40}
!90 = !{!"llvm.loop.parallel_accesses", !88}
!91 = distinct !{}
!92 = distinct !{!92, !93, !40}
!93 = !{!"llvm.loop.parallel_accesses", !91}
!94 = distinct !{}
!95 = distinct !{!95, !96, !40}
!96 = !{!"llvm.loop.parallel_accesses", !94}
!97 = distinct !{}
!98 = distinct !{!98, !99, !40}
!99 = !{!"llvm.loop.parallel_accesses", !97}
!100 = distinct !{}
!101 = distinct !{!101, !102, !40}
!102 = !{!"llvm.loop.parallel_accesses", !100}
!103 = distinct !{}
!104 = distinct !{!104, !105, !40}
!105 = !{!"llvm.loop.parallel_accesses", !103}
!106 = distinct !{}
!107 = distinct !{!107, !108, !40}
!108 = !{!"llvm.loop.parallel_accesses", !106}
!109 = distinct !{}
!110 = distinct !{!110, !111, !40}
!111 = !{!"llvm.loop.parallel_accesses", !109}
!112 = distinct !{}
!113 = distinct !{!113, !114, !40}
!114 = !{!"llvm.loop.parallel_accesses", !112}
!115 = distinct !{}
!116 = distinct !{!116, !117, !40}
!117 = !{!"llvm.loop.parallel_accesses", !115}
!118 = distinct !{}
!119 = distinct !{!119, !120, !40}
!120 = !{!"llvm.loop.parallel_accesses", !118}
!121 = distinct !{}
!122 = distinct !{!122, !123, !40}
!123 = !{!"llvm.loop.parallel_accesses", !121}
!124 = distinct !{}
!125 = distinct !{!125, !126, !40}
!126 = !{!"llvm.loop.parallel_accesses", !124}
!127 = distinct !{}
!128 = distinct !{!128, !129, !40}
!129 = !{!"llvm.loop.parallel_accesses", !127}
