; ModuleID = 'samples/980.bc'
source_filename = "../spack-src/test/x86/avx512/test.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.anon = type { ptr, ptr }
%struct.anon.0 = type { [8 x i32], [8 x i32], i16 }
%struct.anon.1 = type { i8, [8 x i32], [8 x i32], i8 }
%struct.anon.2 = type { i32, [32 x i16], [32 x i16], i32 }
%struct.anon.5 = type { i64, [64 x i8], [64 x i8], i64 }
%struct.anon.6 = type { [32 x i16], [32 x i16], i32 }
%struct.anon.7 = type { [16 x i32], [16 x i32], i16 }
%struct.anon.8 = type { [8 x i64], [8 x i64], i8 }
%struct.anon.9 = type { [64 x i8], [64 x i8], i64 }
%struct.anon.3 = type { i16, <8 x i64>, <8 x i64>, i16, [62 x i8] }
%struct.anon.4 = type { i8, <8 x i64>, <8 x i64>, i8, [63 x i8] }
%union.simde__m256i_private = type { <32 x i8> }
%struct.__va_list_tag = type { i32, i32, ptr, ptr }
%struct.simde_mm512_loadu_si512_s = type { <8 x i64> }
%union.simde__m512i_private = type { <64 x i8> }

@stdout = external global ptr, align 8
@.str = private unnamed_addr constant [8 x i8] c"1..%zu\0A\00", align 1
@test_suite_tests = internal constant [10 x %struct.anon] [%struct.anon { ptr @test_simde_mm256_test_epi32_mask, ptr @.str.3 }, %struct.anon { ptr @test_simde_mm256_mask_test_epi32_mask, ptr @.str.4 }, %struct.anon { ptr @test_simde_mm512_mask_test_epi16_mask, ptr @.str.5 }, %struct.anon { ptr @test_simde_mm512_mask_test_epi32_mask, ptr @.str.6 }, %struct.anon { ptr @test_simde_mm512_mask_test_epi64_mask, ptr @.str.7 }, %struct.anon { ptr @test_simde_mm512_mask_test_epi8_mask, ptr @.str.8 }, %struct.anon { ptr @test_simde_mm512_test_epi16_mask, ptr @.str.9 }, %struct.anon { ptr @test_simde_mm512_test_epi32_mask, ptr @.str.10 }, %struct.anon { ptr @test_simde_mm512_test_epi64_mask, ptr @.str.11 }, %struct.anon { ptr @test_simde_mm512_test_epi8_mask, ptr @.str.12 }], align 16
@.str.1 = private unnamed_addr constant [20 x i8] c"not ok %zu test/%s\0A\00", align 1
@.str.2 = private unnamed_addr constant [16 x i8] c"ok %zu test/%s\0A\00", align 1
@.str.3 = private unnamed_addr constant [22 x i8] c"mm256_test_epi32_mask\00", align 1
@.str.4 = private unnamed_addr constant [27 x i8] c"mm256_mask_test_epi32_mask\00", align 1
@.str.5 = private unnamed_addr constant [27 x i8] c"mm512_mask_test_epi16_mask\00", align 1
@.str.6 = private unnamed_addr constant [27 x i8] c"mm512_mask_test_epi32_mask\00", align 1
@.str.7 = private unnamed_addr constant [27 x i8] c"mm512_mask_test_epi64_mask\00", align 1
@.str.8 = private unnamed_addr constant [26 x i8] c"mm512_mask_test_epi8_mask\00", align 1
@.str.9 = private unnamed_addr constant [22 x i8] c"mm512_test_epi16_mask\00", align 1
@.str.10 = private unnamed_addr constant [22 x i8] c"mm512_test_epi32_mask\00", align 1
@.str.11 = private unnamed_addr constant [22 x i8] c"mm512_test_epi64_mask\00", align 1
@.str.12 = private unnamed_addr constant [21 x i8] c"mm512_test_epi8_mask\00", align 1
@test_simde_mm256_test_epi32_mask.test_vec = internal constant [8 x %struct.anon.0] [%struct.anon.0 { [8 x i32] [i32 1576173070, i32 -1227665335, i32 -59825545, i32 1808402821, i32 -1055795563, i32 1242636844, i32 1083448238, i32 1669148756], [8 x i32] [i32 -910135378, i32 -1227665335, i32 -59825545, i32 946288939, i32 -1055795563, i32 -1509219336, i32 -1813602498, i32 2130076623], i16 255 }, %struct.anon.0 { [8 x i32] [i32 1502482515, i32 1742168106, i32 516903074, i32 -416387279, i32 -157941727, i32 -515281222, i32 1806101534, i32 -1606980531], [8 x i32] [i32 -1493580420, i32 -938618842, i32 1390861345, i32 1832457548, i32 -245051627, i32 -515281222, i32 1806101534, i32 -737419688], i16 255 }, %struct.anon.0 { [8 x i32] [i32 -627219232, i32 -1103432491, i32 1980801001, i32 1931030305, i32 -2050119686, i32 1420913802, i32 1535332521, i32 -1634268738], [8 x i32] [i32 -627219232, i32 -1103432491, i32 -1254864237, i32 724061561, i32 -2050119686, i32 316243475, i32 1535332521, i32 -1634268738], i16 255 }, %struct.anon.0 { [8 x i32] [i32 -425524547, i32 -1281186635, i32 1029697425, i32 -321205076, i32 -803313641, i32 -1699357683, i32 -988117364, i32 -153068999], [8 x i32] [i32 316441692, i32 46497320, i32 1029697425, i32 -165070149, i32 -803313641, i32 -1699357683, i32 -988117364, i32 1019018208], i16 255 }, %struct.anon.0 { [8 x i32] [i32 -1685150537, i32 -1182621014, i32 -1525995620, i32 -2119346167, i32 1199582608, i32 -1285189037, i32 1917372580, i32 575268558], [8 x i32] [i32 -1685150537, i32 -1182621014, i32 -1525995620, i32 -1473791873, i32 1199582608, i32 -1285189037, i32 1917372580, i32 1704235438], i16 255 }, %struct.anon.0 { [8 x i32] [i32 1968273329, i32 -1512641798, i32 -931040065, i32 1675206665, i32 249445735, i32 157184935, i32 2082877845, i32 -954928960], [8 x i32] [i32 17636102, i32 -1784225018, i32 -931040065, i32 120347157, i32 249445735, i32 -854115152, i32 2082877845, i32 -954928960], i16 255 }, %struct.anon.0 { [8 x i32] [i32 2074731646, i32 -534163715, i32 -107072631, i32 1726010991, i32 1015704662, i32 157484525, i32 -1867478357, i32 -153817992], [8 x i32] [i32 2074731646, i32 -1487154382, i32 -107072631, i32 -1117815287, i32 1015704662, i32 157484525, i32 -1867478357, i32 -153817992], i16 255 }, %struct.anon.0 { [8 x i32] [i32 889530340, i32 -71396860, i32 -1090526217, i32 -1673489020, i32 -1140162102, i32 946919153, i32 1308033563, i32 1297132648], [8 x i32] [i32 -914205228, i32 -71396860, i32 -1933918602, i32 -1673489020, i32 -1140162102, i32 1928624727, i32 -457118852, i32 1798377623], i16 255 }], align 16
@.str.13 = private unnamed_addr constant [36 x i8] c"../spack-src/test/x86/avx512/test.c\00", align 1
@.str.14 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.15 = private unnamed_addr constant [14 x i8] c"test_vec[i].r\00", align 1
@.str.16 = private unnamed_addr constant [46 x i8] c"%s:%d: assertion failed: %s == %s (%u == %u)\0A\00", align 1
@stderr = external global ptr, align 8
@test_simde_mm256_mask_test_epi32_mask.test_vec = internal constant [8 x %struct.anon.1] [%struct.anon.1 { i8 -121, [8 x i32] [i32 -522097702, i32 1591087810, i32 -472653921, i32 93736658, i32 291227707, i32 835924589, i32 -870150944, i32 695603791], [8 x i32] [i32 529445, i32 144629609, i32 271327264, i32 -100630528, i32 -1223888566, i32 36228354, i32 852296203, i32 -1696316132], i8 -126 }, %struct.anon.1 { i8 39, [8 x i32] [i32 -1904651137, i32 -58170400, i32 -1297218291, i32 1231245771, i32 -525405417, i32 -1535631634, i32 -784443989, i32 1322436302], [8 x i32] [i32 1887701760, i32 58065934, i32 88186976, i32 68976692, i32 -1309922109, i32 -162110389, i32 -2000186183, i32 1976998234], i8 32 }, %struct.anon.1 { i8 46, [8 x i32] [i32 -963756680, i32 1921030589, i32 -1515910247, i32 1469973848, i32 1353514159, i32 -1296525805, i32 -1826113062, i32 414928543], [8 x i32] [i32 156254851, i32 2092654307, i32 -1037999767, i32 354009190, i32 -1891565040, i32 914431324, i32 1992927447, i32 -2121366282], i8 46 }, %struct.anon.1 { i8 -120, [8 x i32] [i32 1670117685, i32 615674413, i32 557105599, i32 652806796, i32 -1539190980, i32 -1093335925, i32 -142570819, i32 1157410318], [8 x i32] [i32 -727218265, i32 -1740109360, i32 -1495651302, i32 1926021942, i32 504761746, i32 1074326288, i32 4543554, i32 -1325383680], i8 8 }, %struct.anon.1 { i8 -82, [8 x i32] [i32 1346589012, i32 -1138364877, i32 588299983, i32 864973546, i32 626648292, i32 2874544, i32 -1491471511, i32 1500291588], [8 x i32] [i32 648654835, i32 1826803357, i32 2005988237, i32 1235885669, i32 -1843003390, i32 1236441568, i32 -1846489972, i32 545414250], i8 46 }, %struct.anon.1 { i8 -46, [8 x i32] [i32 1404440382, i32 1677202430, i32 -529286187, i32 -145062016, i32 -1205834117, i32 1072043534, i32 1046114425, i32 1133119493], [8 x i32] [i32 67125249, i32 134319105, i32 151536648, i32 -272604300, i32 1200128384, i32 1075349745, i32 61765886, i32 -1756940160], i8 -64 }, %struct.anon.1 { i8 -8, [8 x i32] [i32 -1500561741, i32 1923261171, i32 -1632501464, i32 1086116401, i32 1919772906, i32 -1062727150, i32 -189524169, i32 -1302493441], [8 x i32] [i32 407945540, i32 -1221919857, i32 541383892, i32 -1720839505, i32 -1929210863, i32 642097644, i32 -904265013, i32 1293971712], i8 72 }, %struct.anon.1 { i8 113, [8 x i32] [i32 -311048382, i32 -1913749101, i32 -1862925764, i32 -1393608048, i32 -971636115, i32 -2026274337, i32 -1230363531, i32 -1241734541], [8 x i32] [i32 276967464, i32 805376096, i32 616595859, i32 17858603, i32 300541074, i32 1476405280, i32 -1063992499, i32 1241583620], i8 64 }], align 16
@test_simde_mm512_mask_test_epi16_mask.test_vec = internal constant [8 x %struct.anon.2] [%struct.anon.2 { i32 729589500, [32 x i16] [i16 -21039, i16 7594, i16 -26143, i16 -3584, i16 10710, i16 22134, i16 11147, i16 -19843, i16 21651, i16 20557, i16 25768, i16 18307, i16 -21839, i16 -13908, i16 9876, i16 -8232, i16 16084, i16 8140, i16 -13132, i16 2833, i16 -29249, i16 -5655, i16 -24960, i16 -10165, i16 11736, i16 -31959, i16 -21330, i16 21460, i16 -23722, i16 -23028, i16 -20057, i16 31534], [32 x i16] [i16 21038, i16 -7595, i16 26142, i16 -24339, i16 -10711, i16 -22135, i16 -11148, i16 19842, i16 -21652, i16 6864, i16 -25769, i16 -21127, i16 -31170, i16 13907, i16 -9877, i16 -26260, i16 -16085, i16 18812, i16 26919, i16 20969, i16 29248, i16 -19206, i16 31814, i16 -19711, i16 -11737, i16 32461, i16 18285, i16 -21461, i16 32717, i16 14562, i16 20056, i16 -31535], i32 577536520 }, %struct.anon.2 { i32 302971227, [32 x i16] [i16 -13115, i16 -19071, i16 12077, i16 8771, i16 27746, i16 13498, i16 -8099, i16 -27443, i16 -2264, i16 -16926, i16 -10784, i16 -22105, i16 -11549, i16 9016, i16 -28981, i16 -14112, i16 23332, i16 15189, i16 -15727, i16 13431, i16 -29429, i16 26707, i16 8302, i16 6606, i16 -27258, i16 26398, i16 -14997, i16 19984, i16 32041, i16 11498, i16 -13609, i16 17374], [32 x i16] [i16 13114, i16 19070, i16 -12078, i16 -8772, i16 3933, i16 -13499, i16 16687, i16 -18710, i16 2263, i16 16925, i16 11725, i16 25744, i16 7869, i16 -9017, i16 -22787, i16 14111, i16 -24871, i16 -21631, i16 15726, i16 -13432, i16 -12980, i16 31639, i16 -32497, i16 -6607, i16 20105, i16 22056, i16 -18309, i16 14778, i16 -32042, i16 -11499, i16 13608, i16 266], i32 33708112 }, %struct.anon.2 { i32 -517794280, [32 x i16] [i16 -627, i16 2271, i16 -31277, i16 -28867, i16 6684, i16 22437, i16 -31723, i16 20962, i16 -22682, i16 -23040, i16 32539, i16 -28658, i16 -1712, i16 10354, i16 -11131, i16 4868, i16 -60, i16 17436, i16 -30076, i16 -13425, i16 1908, i16 23586, i16 -28532, i16 17326, i16 -20820, i16 -16377, i16 27569, i16 620, i16 12144, i16 -5489, i16 -27410, i16 -16130], [32 x i16] [i16 626, i16 -2272, i16 -20595, i16 28866, i16 -6685, i16 -16435, i16 31722, i16 -27134, i16 -5079, i16 23491, i16 -32540, i16 21660, i16 1711, i16 29522, i16 11130, i16 -4869, i16 6958, i16 -17437, i16 -22838, i16 -21205, i16 -1909, i16 30061, i16 28531, i16 -25333, i16 -12709, i16 16376, i16 -27570, i16 -621, i16 -6501, i16 5488, i16 27409, i16 16129], i32 18940416 }, %struct.anon.2 { i32 -580699310, [32 x i16] [i16 25185, i16 12792, i16 10477, i16 -22254, i16 -21385, i16 30944, i16 22376, i16 -32250, i16 -9887, i16 -2295, i16 3391, i16 -24650, i16 -27822, i16 -23404, i16 -2097, i16 12417, i16 29785, i16 10160, i16 -15630, i16 1744, i16 -20221, i16 27518, i16 -22520, i16 27023, i16 10865, i16 31162, i16 7223, i16 16892, i16 -28512, i16 28645, i16 26503, i16 -8033], [32 x i16] [i16 20699, i16 -12793, i16 -10478, i16 5844, i16 21384, i16 -28543, i16 4347, i16 32249, i16 -19687, i16 2294, i16 -3392, i16 24649, i16 11906, i16 2511, i16 28309, i16 29161, i16 -3906, i16 -11969, i16 5064, i16 20711, i16 26726, i16 25313, i16 -9607, i16 -27937, i16 -10866, i16 20122, i16 -7224, i16 19118, i16 32018, i16 -22700, i16 15851, i16 -21992], i32 -664587968 }, %struct.anon.2 { i32 -391112323, [32 x i16] [i16 -2437, i16 -21731, i16 -4834, i16 8329, i16 11606, i16 3105, i16 -19486, i16 1449, i16 8891, i16 9098, i16 -26655, i16 27927, i16 22472, i16 -24819, i16 -10289, i16 8872, i16 -8755, i16 -5231, i16 6859, i16 12017, i16 5085, i16 19123, i16 -6969, i16 25454, i16 -1827, i16 -29521, i16 -28888, i16 19755, i16 -13338, i16 -28015, i16 -21719, i16 2485], [32 x i16] [i16 -119, i16 21730, i16 -4582, i16 -27617, i16 -11607, i16 -3106, i16 19485, i16 -1450, i16 -8892, i16 -11335, i16 -7045, i16 -12512, i16 -22473, i16 24818, i16 24916, i16 -8873, i16 14944, i16 31281, i16 20520, i16 -12018, i16 -5086, i16 16324, i16 6968, i16 31801, i16 -3336, i16 29520, i16 28887, i16 3650, i16 13337, i16 28014, i16 -14699, i16 -2486], i32 1218447373 }, %struct.anon.2 { i32 -140921300, [32 x i16] [i16 -17182, i16 -24092, i16 4177, i16 10821, i16 -30163, i16 -31643, i16 -29846, i16 -18436, i16 9984, i16 24019, i16 16234, i16 -26639, i16 5577, i16 9464, i16 25036, i16 492, i16 -12044, i16 17826, i16 -6176, i16 21871, i16 -10143, i16 -13115, i16 -9373, i16 25822, i16 -19965, i16 28097, i16 -19471, i16 -11259, i16 -701, i16 -30727, i16 19902, i16 -19808], [32 x i16] [i16 17181, i16 -520, i16 26410, i16 30546, i16 30162, i16 31642, i16 29845, i16 -4374, i16 -9985, i16 -24020, i16 -16235, i16 26638, i16 28445, i16 -9465, i16 -22340, i16 -9843, i16 -31253, i16 5590, i16 10733, i16 -16499, i16 10142, i16 13114, i16 9372, i16 -25823, i16 19964, i16 -28098, i16 19470, i16 11258, i16 700, i16 30726, i16 -27734, i16 -27310], i32 -1073115128 }, %struct.anon.2 { i32 562338000, [32 x i16] [i16 18896, i16 2168, i16 -14015, i16 27690, i16 30605, i16 4579, i16 13180, i16 -18771, i16 -22799, i16 -25709, i16 -6070, i16 -20492, i16 -4029, i16 -1922, i16 -8877, i16 19329, i16 -27654, i16 1068, i16 -23352, i16 17071, i16 15460, i16 -1714, i16 -1157, i16 -5392, i16 15077, i16 -27727, i16 -17384, i16 23399, i16 -6483, i16 340, i16 1988, i16 -30939], [32 x i16] [i16 6703, i16 -2169, i16 14014, i16 9017, i16 -30606, i16 -4580, i16 -13181, i16 -2218, i16 22798, i16 14773, i16 8785, i16 11508, i16 4028, i16 1921, i16 8876, i16 -9396, i16 -11204, i16 -1069, i16 3082, i16 32030, i16 14996, i16 6251, i16 -16122, i16 5391, i16 -15078, i16 27726, i16 17383, i16 -23400, i16 6482, i16 -341, i16 -1989, i16 30938], i32 297088 }, %struct.anon.2 { i32 168615504, [32 x i16] [i16 24431, i16 14936, i16 3341, i16 -25332, i16 -3277, i16 28215, i16 15657, i16 -24176, i16 -2560, i16 7101, i16 -3073, i16 12678, i16 29635, i16 10854, i16 29391, i16 -21077, i16 -29486, i16 3002, i16 -31414, i16 -25440, i16 -27411, i16 -24085, i16 31490, i16 17773, i16 -20527, i16 -26255, i16 -17121, i16 -7591, i16 -17871, i16 -18455, i16 7587, i16 30197], [32 x i16] [i16 28073, i16 -3227, i16 -3342, i16 27504, i16 23735, i16 -17908, i16 20439, i16 -22120, i16 2559, i16 -7102, i16 3072, i16 -5981, i16 -29636, i16 -8289, i16 -27479, i16 21076, i16 -18175, i16 -3003, i16 -18772, i16 25439, i16 27410, i16 -5859, i16 -19013, i16 -17774, i16 -11074, i16 -16738, i16 17120, i16 7590, i16 17870, i16 30972, i16 20953, i16 -9270], i32 33835088 }], align 16
@.str.17 = private unnamed_addr constant [29 x i8] c"((uint16_t) (test_vec[i].r))\00", align 1
@test_simde_mm512_mask_test_epi8_mask.test_vec = internal constant [8 x %struct.anon.5] [%struct.anon.5 { i64 -2737044065477924367, [64 x i8] c"6;,\C8^\F6,\85'E\F5cW\D2\07\D0\8D\98>}\0B\E8j\AC\9D\03\83\04\9C\87\97J(\FE\A2\A1t\DD&\9B\15\E3\E7q#\EE\22\B0\86|\D1o\1E_\8F\CAA\12\CF\DE\99\A2\B8\A4", [64 x i8] c"\C3\C4\D37\A1\F9\D3\99y\BA\0A\9C\A8-M/c\07\C1\82+PqSb\1E\8E\FBc\13-&\D7\01]x\FA0\11t\EA\1C\10\93I]\C2\ACd\83.\90\D3\A0\E35\BEq0!\84]G[", i64 1297055008672465313 }, %struct.anon.5 { i64 -2232813090795249457, [64 x i8] c"\EEg\ACB\C1\D1\A3\99\AF\B9\83\82<I\8B\FD\B3\C2\96t~\9E\D7D\C5?\13C\B4\C5h\A2\16\BA\1E@\E7\C1?\96\C3|\DE\00\F6a\C3\16?a\8BZ\AB\FB\9F\C6:\F5\E0\EE\EF\05fn", [64 x i8] c"\D6\AF\AE\BDp.Tf1F\C2}\C3\86|\02\E0\86\9C\8B\81a(\BB:\09\AA)\0E:\97\E5\E9E\A2Zs\F6\C0\A4<\83!\FF\09\9E\01\E9$\9Et\A5\FF\9D`9\A6\0Ac\B4E\FA\99.", i64 -9150962528094388217 }, %struct.anon.5 { i64 481084291829640640, [64 x i8] c"6\17\87\90\B7m\01\F0\E1\B3\E2\BF|I\E8Lh\A2\AF.\1B\DE\82\E0?\00-\DC\A8\AD\E2\E7\B9jw}\CC_x\DF>ZN\A9\A36M}\D9\C8\AC\F4\DC\8F\D0\BD7\FD\C79\AA? o", [64 x i8] c"\C1\E8\19oH\92\FE\86\ECL\84\90\83\CF\0D\\\97\B9P\F1\E8!\8A\1F\1E\FF\85\F6WR\88\18:\A1\88\823\86\08 \D3\8D\B0V\\\BD\B2\F4w\02\E5_#p~Bo\038\C6U\C0\DF\90", i64 147812851065728384 }, %struct.anon.5 { i64 -7905510224247357306, [64 x i8] c"\0C\83\F1\95\F1\EA\04:x\14$B\E7!+H\E0\DC\D31\87\B5\B0v'5\89\081\D2\11IUP\9EN\BE\A2\89S\CB\B7\99\0C6\A5\FC\1C\D7\DF\FA\8El\BD\04\94`\8E\\\9D`f\CD\B6", [64 x i8] c"\F3l\C1j\0E\92\BD\C5\87V\D2\BD\18\DE\D4\B7\BD\CEE\CExJ\91X\D8\\i8\C36\EE\B6\A2\AF \B1A\DDv\C94H\86L&Z\03\E3(I\B1\A1\93B\F9k\9Fb\A3b\98\92\18;", i64 -9076974262329016316 }, %struct.anon.5 { i64 -6024184955696673325, [64 x i8] c"\BA\BE\E8B\AF\E1\D1\12\C0@\BA!O\B6\D4\057<\EF\C5{\EA(\1F.\9AM\E2\17\7F\8E\07\07aa\EE1\19\06o\9D(\90\EC\CF\D4;\D4\D67/\8C\10\17\10\AF[]-\F7\8C\95\DF\CB", [64 x i8] c"\10A\17\BFP\1E.\ED\DE\BF\D9U$Y)\FA\C8\C3\04\D8\84\15\17\E0r8\A0\82\E8\80\98\F8\C1\B0\B8\11\CE\E6\FE\AC\A5\D7\02\C90+\C4\F8\EE\C8\D0s\DD\E8SP \F3\D2\08sj\014", i64 18447070327213313 }, %struct.anon.5 { i64 1677542360563664629, [64 x i8] c"\A4_\0E'\8Ahm\E0\81\EF15\BD\9Ep\16\83\FB\F6\E4\B1\82w\8EQ\CE\1F^\\\07v\15g\84H\F8_\AA}\BA\0CJ\B3\C9\E8\EE\B2\D6\EAF\FB\83\C8r\11F\D11\A4W\97\1A\9A.", [64 x i8] c"\9E\A0~\D8o\97\92{\E1\10E\CA\FF\E5\E1\E9|\DClGN}\8DI\AE1\A0FL\F8\8B\EA\98\09\C2\07\A0U\82\82e\C7Ld\AD-M)\09\B9pW7\FD\A1\E5.A+z9\B7e\D1", i64 1604710282972644501 }, %struct.anon.5 { i64 4529592901992082943, [64 x i8] c"\98\13Tnt[\8D0(3:\10Cd[7\96]I\A9\CF_uRG<\8F\05F\EEQ\E7`]J>\B8\D8y\10\0B\B3\BBx\F9q8\B5t\F99DY\AF\E9\F7|' \C3v|\93\18", [64 x i8] c"\D9\EC\AB\91\C4$\A1\CF\D7e\1E\EF\D7V\A4\C8i\A2\B6V0\A0\8A\ADa\C3p\D7?\11\AE\18\FDY\A9\C1}K\91T\B0\AFD\87\06\E8Po\8B\06\C6\BB\A6Ph\08\14\D8\DFS\EA\8Dl\E7", i64 4053310815464334417 }, %struct.anon.5 { i64 6137157573880594433, [64 x i8] c"\F8%BI}\9E\89|&_\EEA\D2R\C8\C2 \A5\BCE\9DV\83\E0\B6\8Ck\08\0BG(\BF)\98\F9\88j\83\AB\90\E2\99\D1\FC!\13\0E\C7F#.\FD\DA\0B\C40\BD\A0\F7\A3w\80c\E0", [64 x i8] c"L\1E\90\B6\A1;F\83\D4\177\D7\B0\AD\9F\EE\DF\CD\EB\BAb\A9|\1FIs\94\F7\F4\B8\D7@\D6g\F6w\A2<\FAvS1M\03\DE\EC\F1\BE\B9\DCx\1C\86\F4;\CFh\CF\C6\\\88\9D\9C^", i64 362680799549472769 }], align 16
@.str.18 = private unnamed_addr constant [48 x i8] c"%s:%d: assertion failed: %s == %s (%lu == %lu)\0A\00", align 1
@test_simde_mm512_test_epi16_mask.test_vec = internal constant [8 x %struct.anon.6] [%struct.anon.6 { [32 x i16] [i16 -10245, i16 18801, i16 31642, i16 -30834, i16 4021, i16 -24214, i16 3143, i16 21759, i16 5919, i16 28063, i16 -18558, i16 14004, i16 -15245, i16 -788, i16 -30313, i16 -3515, i16 13971, i16 19259, i16 -1420, i16 -29772, i16 -24822, i16 27851, i16 -21228, i16 13267, i16 6664, i16 -29948, i16 19325, i16 17857, i16 17484, i16 -6928, i16 12391, i16 -27800], [32 x i16] [i16 10244, i16 -18802, i16 17119, i16 5953, i16 -4022, i16 24213, i16 26781, i16 25233, i16 13018, i16 22512, i16 18557, i16 -14005, i16 15244, i16 23213, i16 -21495, i16 3514, i16 18644, i16 -19260, i16 1419, i16 -10805, i16 24821, i16 -27852, i16 -14903, i16 -23563, i16 -6665, i16 29947, i16 17966, i16 -17858, i16 -5247, i16 -30188, i16 -12392, i16 27799], i32 885613516 }, %struct.anon.6 { [32 x i16] [i16 4355, i16 22602, i16 -15849, i16 25519, i16 -26514, i16 -8328, i16 16186, i16 15176, i16 9956, i16 -8659, i16 -9919, i16 29603, i16 -27243, i16 -26945, i16 6837, i16 -3886, i16 9516, i16 18143, i16 -18121, i16 19610, i16 20839, i16 -23822, i16 -31087, i16 24898, i16 1812, i16 -9466, i16 24137, i16 -7388, i16 30497, i16 -19442, i16 20114, i16 7589], [32 x i16] [i16 -4356, i16 -9644, i16 -4378, i16 30246, i16 20736, i16 17534, i16 -16187, i16 24428, i16 29232, i16 31035, i16 24528, i16 -29604, i16 27242, i16 26944, i16 -6838, i16 18054, i16 -9517, i16 -18144, i16 18120, i16 -14032, i16 -20840, i16 23821, i16 31086, i16 -24899, i16 -1813, i16 -17641, i16 29783, i16 -16057, i16 -30498, i16 10538, i16 -20115, i16 16751], i32 -1375172674 }, %struct.anon.6 { [32 x i16] [i16 -15752, i16 -2825, i16 30044, i16 16469, i16 30696, i16 26898, i16 -3822, i16 3323, i16 5870, i16 -2908, i16 1191, i16 4091, i16 10184, i16 15686, i16 8528, i16 -30914, i16 -27952, i16 -17194, i16 -27468, i16 -24703, i16 -16373, i16 11998, i16 -21889, i16 14309, i16 -30159, i16 -7124, i16 10247, i16 -1753, i16 20718, i16 -19658, i16 29820, i16 -31607], [32 x i16] [i16 4103, i16 2824, i16 -30045, i16 -16470, i16 -30697, i16 -26899, i16 -20941, i16 -3324, i16 -11814, i16 2907, i16 -32179, i16 -4092, i16 15088, i16 27811, i16 -8529, i16 -18760, i16 -15890, i16 -27967, i16 27467, i16 25169, i16 16372, i16 10233, i16 -531, i16 -14310, i16 30158, i16 7123, i16 -10248, i16 -6133, i16 -20719, i16 -16299, i16 3469, i16 31606], i32 1751889216 }, %struct.anon.6 { [32 x i16] [i16 2253, i16 -9518, i16 -2678, i16 18558, i16 17914, i16 -9036, i16 -9487, i16 9521, i16 30510, i16 11234, i16 -8024, i16 -3270, i16 2708, i16 9621, i16 30858, i16 22534, i16 -10111, i16 -6861, i16 -20199, i16 23698, i16 3575, i16 -5696, i16 -3353, i16 -9457, i16 -6197, i16 9687, i16 -7689, i16 7395, i16 25863, i16 -27929, i16 -4642, i16 -15351], [32 x i16] [i16 -2254, i16 9517, i16 -16484, i16 -18559, i16 -17915, i16 21280, i16 9486, i16 -9522, i16 29964, i16 1155, i16 8023, i16 17039, i16 16464, i16 13694, i16 -30859, i16 -22535, i16 10110, i16 6860, i16 20198, i16 -4910, i16 -3576, i16 5695, i16 3352, i16 9456, i16 29571, i16 -9688, i16 -18286, i16 -7396, i16 -25864, i16 27928, i16 4641, i16 -24812], i32 -2063058140 }, %struct.anon.6 { [32 x i16] [i16 9041, i16 9642, i16 -19085, i16 -19117, i16 31931, i16 -15038, i16 17383, i16 -32600, i16 -6106, i16 24788, i16 1209, i16 2608, i16 27263, i16 6932, i16 -16763, i16 24863, i16 -29727, i16 9129, i16 -7553, i16 -18471, i16 -19573, i16 29655, i16 9555, i16 7436, i16 -5646, i16 -31998, i16 13549, i16 12497, i16 -31606, i16 -2619, i16 -6812, i16 17403], [32 x i16] [i16 -9042, i16 11621, i16 -28482, i16 19116, i16 -31932, i16 15037, i16 -13939, i16 32599, i16 14002, i16 -24789, i16 -917, i16 -2609, i16 -27264, i16 -6933, i16 16762, i16 10255, i16 29726, i16 -9130, i16 516, i16 18470, i16 -7290, i16 4995, i16 -9556, i16 24211, i16 -16879, i16 31997, i16 -12870, i16 14961, i16 23650, i16 -9186, i16 11678, i16 -17404], i32 2108982598 }, %struct.anon.6 { [32 x i16] [i16 -12657, i16 29389, i16 -32627, i16 -1451, i16 1129, i16 23456, i16 9124, i16 7380, i16 -7801, i16 -28013, i16 23030, i16 -17430, i16 -21837, i16 14817, i16 -22330, i16 22062, i16 31863, i16 -11285, i16 16617, i16 5581, i16 6028, i16 24972, i16 28107, i16 -20355, i16 25422, i16 29414, i16 -16651, i16 -14291, i16 7387, i16 -23851, i16 16996, i16 -8378], [32 x i16] [i16 12656, i16 22962, i16 32626, i16 -402, i16 -1130, i16 -23457, i16 -9125, i16 26708, i16 7800, i16 28012, i16 3292, i16 17429, i16 -2418, i16 -3567, i16 22329, i16 -22063, i16 -31864, i16 -1533, i16 28931, i16 -26120, i16 22380, i16 -14274, i16 -28108, i16 -21456, i16 -25423, i16 -29415, i16 11945, i16 14290, i16 -7388, i16 23850, i16 -1222, i16 -15865], i32 -994167670 }, %struct.anon.6 { [32 x i16] [i16 -26169, i16 17028, i16 30871, i16 -1688, i16 -24805, i16 13473, i16 4179, i16 23485, i16 -21361, i16 -15522, i16 -17495, i16 1419, i16 -10043, i16 -14686, i16 32399, i16 22216, i16 19479, i16 13283, i16 19662, i16 -5587, i16 23965, i16 22729, i16 19431, i16 30352, i16 -4360, i16 -29061, i16 1768, i16 -4823, i16 -7201, i16 -18509, i16 18213, i16 24589], [32 x i16] [i16 -23097, i16 -19770, i16 -30872, i16 1687, i16 24804, i16 -13474, i16 -4180, i16 -23486, i16 31965, i16 -30907, i16 28370, i16 -1420, i16 10042, i16 -31823, i16 -16734, i16 27108, i16 -21917, i16 -13284, i16 -19663, i16 5586, i16 12307, i16 -16415, i16 8991, i16 -669, i16 -22369, i16 29060, i16 -1769, i16 20843, i16 7200, i16 -15404, i16 -18214, i16 15660], i32 -1443764477 }, %struct.anon.6 { [32 x i16] [i16 16382, i16 -26259, i16 28224, i16 19465, i16 -10248, i16 -23176, i16 -10938, i16 -6927, i16 -20915, i16 -28118, i16 -26651, i16 6842, i16 17199, i16 27442, i16 -27399, i16 -12782, i16 32675, i16 14834, i16 -23193, i16 23942, i16 -302, i16 9883, i16 -2914, i16 1738, i16 -2694, i16 31199, i16 20364, i16 22633, i16 -25813, i16 -1085, i16 2912, i16 -23607], [32 x i16] [i16 -16383, i16 26258, i16 6331, i16 -28989, i16 -15082, i16 -19094, i16 10937, i16 23713, i16 -32577, i16 28117, i16 26650, i16 -2231, i16 9268, i16 -27443, i16 -25552, i16 12781, i16 -32676, i16 6295, i16 23192, i16 -20570, i16 4128, i16 -9884, i16 1338, i16 -1739, i16 2693, i16 -24730, i16 -20365, i16 -22634, i16 25812, i16 1084, i16 10496, i16 23606], i32 1113217468 }], align 16
@test_simde_mm512_test_epi32_mask.test_vec = internal constant [8 x %struct.anon.7] [%struct.anon.7 { [16 x i32] [i32 -1791876952, i32 1844499212, i32 -365199811, i32 -1866534401, i32 -232364997, i32 1453189598, i32 -461789425, i32 971959440, i32 -355524340, i32 -2146953968, i32 864052768, i32 199938932, i32 54748553, i32 1624897104, i32 776295070, i32 1281897535], [16 x i32] [i32 1791876951, i32 -491122398, i32 10679440, i32 1236071149, i32 -930854296, i32 709694853, i32 461789424, i32 -971959441, i32 355524339, i32 2146953967, i32 -864052769, i32 -199938933, i32 -54748554, i32 -1624897105, i32 -776295071, i32 -1281897536], i16 62 }, %struct.anon.7 { [16 x i32] [i32 356677238, i32 6053022, i32 -909044215, i32 -745850423, i32 -656871898, i32 1601452805, i32 634323680, i32 -206023555, i32 1343095986, i32 -1117669651, i32 1664295297, i32 -1158762358, i32 -73592075, i32 542773838, i32 699834084, i32 1123018103], [16 x i32] [i32 -356677239, i32 1968377588, i32 -1176992209, i32 745850422, i32 656871897, i32 122126627, i32 -634323681, i32 206023554, i32 703988789, i32 1117669650, i32 117143248, i32 355626812, i32 -1539548799, i32 -106134310, i32 80993409, i32 -1123018104], i16 32038 }, %struct.anon.7 { [16 x i32] [i32 -1256567730, i32 -1903775732, i32 -1021880878, i32 -2029233078, i32 646471133, i32 -1782033256, i32 -2056503897, i32 1206237333, i32 1562435178, i32 -258166754, i32 658140595, i32 -1212544241, i32 -22118461, i32 1800265398, i32 -506967100, i32 -733180567], [16 x i32] [i32 1256567729, i32 -1049575411, i32 1021880877, i32 2029233077, i32 -646471134, i32 1782033255, i32 -1560143285, i32 -1808014877, i32 -1562435179, i32 258166753, i32 -1370796807, i32 287784943, i32 1223335649, i32 -1800265399, i32 506967099, i32 733180566], i16 7362 }, %struct.anon.7 { [16 x i32] [i32 -1774688435, i32 1689956846, i32 1778816600, i32 1734383060, i32 -1672529762, i32 -798399687, i32 1044867632, i32 1731118106, i32 1744780664, i32 -277403568, i32 1655951952, i32 -1295906541, i32 2085491266, i32 854392578, i32 199072177, i32 602644472], [16 x i32] [i32 1440213253, i32 -1689956847, i32 -1778816601, i32 -1599422482, i32 1672529761, i32 798399686, i32 -927791152, i32 -1410621786, i32 -1744780665, i32 -1221311216, i32 -1655951953, i32 1295906540, i32 -2085491267, i32 1521698698, i32 -199072178, i32 -1952510716], i16 -23863 }, %struct.anon.7 { [16 x i32] [i32 4120059, i32 88068023, i32 972644661, i32 1069848687, i32 -1495964580, i32 -995051713, i32 2000019868, i32 -1425017777, i32 -1985099141, i32 -312115224, i32 608280808, i32 -371249999, i32 -1090510320, i32 1377285814, i32 -406238057, i32 -1517102783], [16 x i32] [i32 -4120060, i32 607052274, i32 -1396402181, i32 -678058813, i32 1495964579, i32 -391364271, i32 -808487538, i32 1400136014, i32 1985099140, i32 312115223, i32 -608280809, i32 -1498262525, i32 1090510319, i32 -1406620898, i32 1870395425, i32 -574427047], i16 -5906 }, %struct.anon.7 { [16 x i32] [i32 1995142522, i32 -1025328991, i32 1237123720, i32 1944581197, i32 -1632683255, i32 2001403434, i32 1825100299, i32 599571980, i32 1448627380, i32 503137172, i32 -440448360, i32 2115725344, i32 1859488131, i32 293810182, i32 1990734309, i32 -125731111], [16 x i32] [i32 -1995142523, i32 1547578820, i32 -1237123721, i32 -2030134620, i32 -1466768222, i32 398005525, i32 1797666401, i32 -198617233, i32 -1501675807, i32 -503137173, i32 1587102906, i32 -2115725345, i32 -1859488132, i32 -324476021, i32 -1990734310, i32 125731110], i16 9722 }, %struct.anon.7 { [16 x i32] [i32 -1236631766, i32 -726892159, i32 -418972991, i32 988710011, i32 1318750596, i32 -1543400492, i32 -213622153, i32 -1249473866, i32 1242584808, i32 164082504, i32 686869933, i32 -1827472114, i32 -955660677, i32 -1191058623, i32 1621039920, i32 1824172932], [16 x i32] [i32 1253559041, i32 726892158, i32 -1672264629, i32 -1636977373, i32 -1318750597, i32 1543400491, i32 213622152, i32 1249473865, i32 -1097584576, i32 -102111058, i32 1335180332, i32 1827472113, i32 -1558293896, i32 1191058622, i32 39041465, i32 1867369519], i16 -10483 }, %struct.anon.7 { [16 x i32] [i32 2003202614, i32 -475412712, i32 1141350272, i32 1446086632, i32 -1605510442, i32 1184231666, i32 1653332520, i32 -1518195858, i32 -103716083, i32 -845194817, i32 -603306187, i32 310425404, i32 1591703846, i32 -423016258, i32 759780642, i32 -1598267758], [16 x i32] [i32 -2003202615, i32 475412711, i32 -1141350273, i32 -1446086633, i32 70025286, i32 -353700152, i32 -585616565, i32 1518195857, i32 1239619426, i32 -815449777, i32 -1316332135, i32 475683030, i32 -1591703847, i32 -947123588, i32 -811228098, i32 -634772872], i16 -4240 }], align 16
@test_simde_mm512_test_epi64_mask.test_vec = internal constant [8 x %struct.anon.8] [%struct.anon.8 { [8 x i64] [i64 -1935719795857156052, i64 -6142336982440005382, i64 -3755735260302931735, i64 8565924432478488344, i64 -7625521580720828296, i64 3735482225277759375, i64 1389743071009894742, i64 4211258168981445345], [8 x i64] [i64 -118278527101448595, i64 530621773771449840, i64 3755735260302931734, i64 -8565924432478488345, i64 7625521580720828295, i64 -3735482225277759376, i64 -2277422861904188195, i64 -1416974286643090513], i8 -61 }, %struct.anon.8 { [8 x i64] [i64 3457588026753764434, i64 1717706511224668770, i64 5859823844452325122, i64 -136148487240149447, i64 -4072292484336041004, i64 7336384931628364992, i64 899403616361728444, i64 -4966276177273367448], [8 x i64] [i64 -3457588026753764435, i64 -1717706511224668771, i64 7682991252262311636, i64 136148487240149446, i64 7005422631704761958, i64 -7336384931628364993, i64 -899403616361728445, i64 4966276177273367447], i8 20 }, %struct.anon.8 { [8 x i64] [i64 8111300885188067376, i64 8433345625914411573, i64 -1415332508365564871, i64 -6383252409235804746, i64 5059076272894766680, i64 3611479204207783805, i64 -2146346760320498508, i64 3145857604965282112], [8 x i64] [i64 -5472754878176835303, i64 -8433345625914411574, i64 -8007106683827110144, i64 6383252409235804745, i64 -5059076272894766681, i64 -3611479204207783806, i64 659405438131680690, i64 -3145857604965282113], i8 69 }, %struct.anon.8 { [8 x i64] [i64 -3849252375540350663, i64 3904726803647939769, i64 -216416808084101174, i64 8434442409886415556, i64 4350871313423223305, i64 8504883711772806009, i64 -6152271255572725614, i64 -8271005281003021549], [8 x i64] [i64 3849252375540350662, i64 -3904726803647939770, i64 216416808084101173, i64 -5671441591776678087, i64 -4389237782810184900, i64 -8504883711772806010, i64 6152271255572725613, i64 7011924461457909682], i8 -104 }, %struct.anon.8 { [8 x i64] [i64 -7428643418601908980, i64 2294962712527383143, i64 -5612589600369147080, i64 -5974249584702473137, i64 6472844327359209748, i64 -2618330417723800803, i64 -4939930458487302337, i64 137830299006646676], [8 x i64] [i64 3349624863759605754, i64 467355425918448966, i64 5612589600369147079, i64 5974249584702473136, i64 -6472844327359209749, i64 908254077988168780, i64 4939930458487302336, i64 -137830299006646677], i8 35 }, %struct.anon.8 { [8 x i64] [i64 3748689352051745012, i64 3765597295249760617, i64 8461435782336917084, i64 -7396666994511550337, i64 -6102301345150566269, i64 5468756357428140262, i64 3501708573596139009, i64 -4673070998841589811], [8 x i64] [i64 -3748689352051745013, i64 2957844122011673298, i64 8976476619900634683, i64 6553670180077683509, i64 7755375136595222255, i64 -5333888708520436925, i64 -3501708573596139010, i64 4673070998841589810], i8 62 }, %struct.anon.8 { [8 x i64] [i64 3340205165359449056, i64 8961155326498102258, i64 5187257904649764459, i64 -7718806074294071207, i64 4351002021841475629, i64 2783331170132641387, i64 -6088879537201316956, i64 -8404271755238698236], [8 x i64] [i64 -3340205165359449057, i64 4010264786319470234, i64 -7508926013520240691, i64 1795458474933612802, i64 -8222122719232016645, i64 -2783331170132641388, i64 -4653973519871652290, i64 -8879680603371353420], i8 -34 }, %struct.anon.8 { [8 x i64] [i64 -7072750869937231124, i64 -1235259015713123945, i64 -4453778579372969693, i64 -6391677988780903072, i64 -5475290417517831931, i64 8023331291259204593, i64 -2934575014531591542, i64 -7984994343078542901], [8 x i64] [i64 7072750869937231123, i64 1235259015713123944, i64 -6953033857279573993, i64 6391677988780903071, i64 159581583610422626, i64 -37474756131855391, i64 -8338930464116371428, i64 7984994343078542900], i8 116 }], align 16
@test_simde_mm512_test_epi8_mask.test_vec = internal constant [8 x %struct.anon.9] [%struct.anon.9 { [64 x i8] c"\D7\1C\F6\B1W\12\9F\F84PCqz@9\C7$R\F4\BD\EE0\EF\F2\EA\8Bsn1%\\\09\DE\D5\FA\FD6\99.\F7\EE\F6i\99kna\90\E4\0A\02\8B\E3\87C\CE\A6\B0<\C2\DD\E7M\C6", [64 x i8] c"\EAG\B7N\E1\9FF\CF\CB\AF76TT\C68^\AD\0BB5\CF\10H\7FL\8C\AC\E4\DAs\CE!*\1C\02\C9b\D1\94\11\09\CBf]\91\9E\BB?\A9\FDty\0D\BC\F8YH\A5=\22\18\0BD", i64 -4272908323104146185 }, %struct.anon.9 { [64 x i8] c"*\A1\D6\AEd\0B=1\E9U\FE\E7\87\07=/\CC\7FX\01\1Dg\89\C3\A35P\B93\F3\17]k\ED \F9(\93\FC<\92\FAW6\02\94\07b\B6d\A6\BC\CB\EE\0Dx\CCy\DB\00Q@]\E7", [64 x i8] c"X^ Q\9B\1C\8D.\16\E4g\18x\CF\DA.3\80\A7\FE\E2\E3v\AF\\\CA\AFF5\0C\9B\8Dj\BB\DF\06\D7l4\EDQ\9B\06\C9j\E0\F8\9Da\9F\9BC\82\11\F2\DE\DB\A1$\10\AE\BF\9E\18", i64 4870422836182836961 }, %struct.anon.9 { [64 x i8] c"]\9Fm\C1d\AAC\90)\1D\E1\F0\EC\B8<JY\C0]\B5`\C4ot\145i\16\F9\14nJ\AA\B7\0B\0EbO\9F\8Bst}\C7]\9C\C0Z\\\EB\A8T\03\B7x}\EC2}\C5\FE\9C\1C\A8", [64 x i8] c"\A2`\B6$\AFU\AF\1C\D6\0Ft\0F\AB\17\A1\07\02\E8\A2\B2\9F\1A/\8B\EB\AD\96\E9\06\EB\91\A9KH\CD\FB\9D}\17s\8C\8B\828\A2#?\A5\0C\E2W\AB\FC\877\E84\CD\D1:\B8c\E3\03", i64 1577105314603005652 }, %struct.anon.9 { [64 x i8] c"\F8\1CT\E5\C0\7Fs\DB|\9DX!\FF0~\F9o??\9C\D5v\0F\93gW~r4\A2\96\CB%\13\CF\11\7F\C9V\B6\BB\8D\1D\C2\BD\97P\A2\DC\90?N\EEN\E1\ED\A5`\10\C3\A1\E0\8D\C6", [64 x i8] c"i\E3\AB\FB\ADk\B1\BB\83b\C9\DE\F9\CF\81r\90\C0\C0\C6\0E\A1d\B3\01t\D0\A3\CB]i4A\150\EE\80\E1\A9\04Dr\E2=Bc\AF\D2#o\981\11\FD\E4\12q\B4\B5<\12\1FqS", i64 -4078958740282764039 }, %struct.anon.9 { [64 x i8] c"]\CE\05O\8Atq\A9~v6EK\08/\D3y\DC\A9\08\05mk\12\12Y\8E^\99\D86k&\CC\BA\B0\B0\BC\C3]\85\\\FB\11v*R\EFx\FCl\BD\F5n\93\0D0\A0\8D\C9y\C34d", [64 x i8] c"\A2\EE\FA\D9\D1\8B\8EVS\89g\C9\B4\F7\B8,\01#V\F7\FA\92\FE*]d\F3\80:'\C9\DC\15\C3\B5\E6OC<\A2\CD\A3l\81\9A$\AD\9CH\03\93B\95\91l\F2\F5_r/\86<\0B\9B", i64 653511295613619482 }, %struct.anon.9 { [64 x i8] c"[\C9\EE\E1dd\10_7v\8B\09\C7\AA4\17\D5v\E2\C9\C6\94mP\EC\12Z\87\93\BD3\D9.k\C0\93\1E\F1;\B1\05\C6\BA\CC8\BB\E3\E41)\AD\1D\E2\AFI[v\A83\09e\B0\E2\0B", [64 x i8] c"\A46\11\1E\9BM\CF\A0\13\89l\84 O\CB\00T\89\1D69k\92\AF\13\ED\B8x|\9B\83 \D1\94?l\E1\0E\0C\F5\98xy\B8\C7D\B8\1B\CE\D6R\07A\E4\B6T\D1n\CCM\09On\DB", i64 -2614252995201653472 }, %struct.anon.9 { [64 x i8] c"\CE\0B\11-\B8\BE\16\89\A0\85\F1y\E2\AD\CA\D4{\87\BDj,?\B3\D8\00)\00\BE\D6\CF;\A4\DA^L\DF\E4\E2,\17\E9\1Dy\CC\AD\A3\84){\E6\93Ur\8E\22\8C\B8\D9\89\0B\A8\D6*U", [64 x i8] c"4\E1\15\D2\C3A\E9v_z\FA\0C\1DR5Gh\C8\9E\DA%\C0L'\99\D6\FFA\AC|\C4\E1]\D9\B3 \1B\9C\96z\16\90\863\E3\BC{K\84\19%\AA\D9q\D1sG\D1\B4\F4Mx\D5\AA", i64 3896936268564499479 }, %struct.anon.9 { [64 x i8] c"\A1\BCtD\A8\B3\03m\B5\C8&D\E9fR=LEy\87e\1A\F1\9CkB\F2\ED^\D0\E26\8CnWj]\00\D7\D8\C9\FE\02e\8B-.\D8^\1C\99\C3\83\8At\96\1F\AE\90\C6~#\FC,", [64 x i8] c"^(t\BBWLWlJ7k\D5d\99\AD\C2\F5\BA\86x\DF\E5\0EG\94k\0D\12\8E\09\1D\ED1\91\A8\88\DD\FF\F5'6`\FD\9A\F9\AA]\EEe\E3fD\C8u\8B\\\E0\98on\A2\8C[\D3", i64 6528515597080272070 }], align 16

; Function Attrs: nounwind uwtable
define dso_local i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %retval1 = alloca i32, align 4
  %i = alloca i64, align 8
  %res = alloca i32, align 4
  store i32 0, ptr %retval, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %retval1) #11
  store i32 0, ptr %retval1, align 4, !tbaa !5
  %0 = load ptr, ptr @stdout, align 8, !tbaa !9
  %call = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %0, ptr noundef @.str, i64 noundef 10)
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #11
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %1, 10
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #11
  br label %for.end

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 4, ptr %res) #11
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [10 x %struct.anon], ptr @test_suite_tests, i64 0, i64 %2
  %func = getelementptr inbounds %struct.anon, ptr %arrayidx, i32 0, i32 0
  %3 = load ptr, ptr %func, align 16, !tbaa !13
  %call2 = call i32 %3()
  store i32 %call2, ptr %res, align 4, !tbaa !5
  %4 = load i32, ptr %res, align 4, !tbaa !5
  %cmp3 = icmp ne i32 %4, 0
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  store i32 1, ptr %retval1, align 4, !tbaa !5
  %5 = load ptr, ptr @stdout, align 8, !tbaa !9
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %add = add i64 %6, 1
  %7 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx4 = getelementptr inbounds [10 x %struct.anon], ptr @test_suite_tests, i64 0, i64 %7
  %name = getelementptr inbounds %struct.anon, ptr %arrayidx4, i32 0, i32 1
  %8 = load ptr, ptr %name, align 8, !tbaa !15
  %call5 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %5, ptr noundef @.str.1, i64 noundef %add, ptr noundef %8)
  br label %if.end

if.else:                                          ; preds = %for.body
  %9 = load ptr, ptr @stdout, align 8, !tbaa !9
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %add6 = add i64 %10, 1
  %11 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx7 = getelementptr inbounds [10 x %struct.anon], ptr @test_suite_tests, i64 0, i64 %11
  %name8 = getelementptr inbounds %struct.anon, ptr %arrayidx7, i32 0, i32 1
  %12 = load ptr, ptr %name8, align 8, !tbaa !15
  %call9 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %9, ptr noundef @.str.2, i64 noundef %add6, ptr noundef %12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %res) #11
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %13 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %13, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.end:                                          ; preds = %for.cond.cleanup
  %14 = load i32, ptr %retval1, align 4, !tbaa !5
  call void @llvm.lifetime.end.p0(i64 4, ptr %retval1) #11
  ret i32 %14
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

declare i32 @fprintf(ptr noundef, ptr noundef, ...) #2

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm256_test_epi32_mask() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <4 x i64>, align 32
  %b = alloca <4 x i64>, align 32
  %r = alloca i16, align 2
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %indirect-arg-temp6 = alloca <4 x i64>, align 32
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #11
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup13

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 32, ptr %a) #11
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.0], ptr @test_simde_mm256_test_epi32_mask.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.0, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [8 x i32], ptr %a1, i64 0, i64 0
  %call = call <4 x i64> @simde_mm256_loadu_epi32(ptr noundef %arraydecay)
  store <4 x i64> %call, ptr %a, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %b) #11
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.0], ptr @test_simde_mm256_test_epi32_mask.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.0, ptr %arrayidx2, i32 0, i32 1
  %arraydecay4 = getelementptr inbounds [8 x i32], ptr %b3, i64 0, i64 0
  %call5 = call <4 x i64> @simde_mm256_loadu_epi32(ptr noundef %arraydecay4)
  store <4 x i64> %call5, ptr %b, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 2, ptr %r) #11
  %3 = load <4 x i64>, ptr %a, align 32, !tbaa !16
  %4 = load <4 x i64>, ptr %b, align 32, !tbaa !16
  store <4 x i64> %3, ptr %indirect-arg-temp, align 32, !tbaa !16
  store <4 x i64> %4, ptr %indirect-arg-temp6, align 32, !tbaa !16
  %call7 = call zeroext i8 @simde_mm256_test_epi32_mask(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp6)
  %conv = zext i8 %call7 to i16
  store i16 %conv, ptr %r, align 2, !tbaa !17
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load i16, ptr %r, align 2, !tbaa !17
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx8 = getelementptr inbounds [8 x %struct.anon.0], ptr @test_simde_mm256_test_epi32_mask.test_vec, i64 0, i64 %6
  %r9 = getelementptr inbounds %struct.anon.0, ptr %arrayidx8, i32 0, i32 2
  %7 = load i16, ptr %r9, align 4, !tbaa !19
  %call10 = call i32 @simde_assert_equal_u16_(i16 noundef zeroext %5, i16 noundef zeroext %7, ptr noundef @.str.13, i32 noundef 73, ptr noundef @.str.14, ptr noundef @.str.15)
  %tobool = icmp ne i32 %call10, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 2, ptr %r) #11
  call void @llvm.lifetime.end.p0(i64 32, ptr %b) #11
  call void @llvm.lifetime.end.p0(i64 32, ptr %a) #11
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup13 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup13:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #11
  %cleanup.dest14 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest14, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup13
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup13
  %9 = load i32, ptr %retval, align 4
  ret i32 %9

unreachable:                                      ; preds = %cleanup13
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm256_mask_test_epi32_mask() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <4 x i64>, align 32
  %b = alloca <4 x i64>, align 32
  %r = alloca i8, align 1
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %indirect-arg-temp7 = alloca <4 x i64>, align 32
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #11
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup15

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 32, ptr %a) #11
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.1], ptr @test_simde_mm256_mask_test_epi32_mask.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.1, ptr %arrayidx, i32 0, i32 1
  %arraydecay = getelementptr inbounds [8 x i32], ptr %a1, i64 0, i64 0
  %call = call <4 x i64> @simde_mm256_loadu_epi32(ptr noundef %arraydecay)
  store <4 x i64> %call, ptr %a, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %b) #11
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.1], ptr @test_simde_mm256_mask_test_epi32_mask.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.1, ptr %arrayidx2, i32 0, i32 2
  %arraydecay4 = getelementptr inbounds [8 x i32], ptr %b3, i64 0, i64 0
  %call5 = call <4 x i64> @simde_mm256_loadu_epi32(ptr noundef %arraydecay4)
  store <4 x i64> %call5, ptr %b, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 1, ptr %r) #11
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx6 = getelementptr inbounds [8 x %struct.anon.1], ptr @test_simde_mm256_mask_test_epi32_mask.test_vec, i64 0, i64 %3
  %k = getelementptr inbounds %struct.anon.1, ptr %arrayidx6, i32 0, i32 0
  %4 = load i8, ptr %k, align 8, !tbaa !21
  %5 = load <4 x i64>, ptr %a, align 32, !tbaa !16
  %6 = load <4 x i64>, ptr %b, align 32, !tbaa !16
  store <4 x i64> %5, ptr %indirect-arg-temp, align 32, !tbaa !16
  store <4 x i64> %6, ptr %indirect-arg-temp7, align 32, !tbaa !16
  %call8 = call zeroext i8 @simde_mm256_mask_test_epi32_mask(i8 noundef zeroext %4, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp7)
  store i8 %call8, ptr %r, align 1, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %7 = load i8, ptr %r, align 1, !tbaa !16
  %conv = zext i8 %7 to i16
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx9 = getelementptr inbounds [8 x %struct.anon.1], ptr @test_simde_mm256_mask_test_epi32_mask.test_vec, i64 0, i64 %8
  %r10 = getelementptr inbounds %struct.anon.1, ptr %arrayidx9, i32 0, i32 3
  %9 = load i8, ptr %r10, align 4, !tbaa !23
  %conv11 = zext i8 %9 to i16
  %call12 = call i32 @simde_assert_equal_u16_(i16 noundef zeroext %conv, i16 noundef zeroext %conv11, ptr noundef @.str.13, i32 noundef 148, ptr noundef @.str.14, ptr noundef @.str.15)
  %tobool = icmp ne i32 %call12, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 1, ptr %r) #11
  call void @llvm.lifetime.end.p0(i64 32, ptr %b) #11
  call void @llvm.lifetime.end.p0(i64 32, ptr %a) #11
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup15 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %10, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup15:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #11
  %cleanup.dest16 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest16, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup15
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup15
  %11 = load i32, ptr %retval, align 4
  ret i32 %11

unreachable:                                      ; preds = %cleanup15
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm512_mask_test_epi16_mask() #4 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <8 x i64>, align 64
  %b = alloca <8 x i64>, align 64
  %r = alloca i32, align 4
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp7 = alloca <8 x i64>, align 64
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #11
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup14

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 64, ptr %a) #11
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.2], ptr @test_simde_mm512_mask_test_epi16_mask.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.2, ptr %arrayidx, i32 0, i32 1
  %arraydecay = getelementptr inbounds [32 x i16], ptr %a1, i64 0, i64 0
  %call = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay)
  store <8 x i64> %call, ptr %a, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %b) #11
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.2], ptr @test_simde_mm512_mask_test_epi16_mask.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.2, ptr %arrayidx2, i32 0, i32 2
  %arraydecay4 = getelementptr inbounds [32 x i16], ptr %b3, i64 0, i64 0
  %call5 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay4)
  store <8 x i64> %call5, ptr %b, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 4, ptr %r) #11
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx6 = getelementptr inbounds [8 x %struct.anon.2], ptr @test_simde_mm512_mask_test_epi16_mask.test_vec, i64 0, i64 %3
  %k1 = getelementptr inbounds %struct.anon.2, ptr %arrayidx6, i32 0, i32 0
  %4 = load i32, ptr %k1, align 8, !tbaa !24
  %5 = load <8 x i64>, ptr %a, align 64, !tbaa !16
  %6 = load <8 x i64>, ptr %b, align 64, !tbaa !16
  store <8 x i64> %5, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %6, ptr %indirect-arg-temp7, align 64, !tbaa !16
  %call8 = call i32 @simde_mm512_mask_test_epi16_mask(i32 noundef %4, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp7)
  store i32 %call8, ptr %r, align 4, !tbaa !5
  br label %do.body

do.body:                                          ; preds = %for.body
  %7 = load i32, ptr %r, align 4, !tbaa !5
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx9 = getelementptr inbounds [8 x %struct.anon.2], ptr @test_simde_mm512_mask_test_epi16_mask.test_vec, i64 0, i64 %8
  %r10 = getelementptr inbounds %struct.anon.2, ptr %arrayidx9, i32 0, i32 3
  %9 = load i32, ptr %r10, align 4, !tbaa !26
  %call11 = call i32 @simde_assert_equal_u32_(i32 noundef %7, i32 noundef %9, ptr noundef @.str.13, i32 noundef 273, ptr noundef @.str.14, ptr noundef @.str.15)
  %tobool = icmp ne i32 %call11, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %r) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %b) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %a) #11
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup14 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %10, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup14:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #11
  %cleanup.dest15 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest15, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup14
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup14
  %11 = load i32, ptr %retval, align 4
  ret i32 %11

unreachable:                                      ; preds = %cleanup14
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm512_mask_test_epi32_mask() #4 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.3], align 64
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r50 = alloca i16, align 2
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp56 = alloca <8 x i64>, align 64
  call void @llvm.lifetime.start.p0(i64 2048, ptr %test_vec) #11
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.3], ptr %test_vec, i64 0, i64 0
  %k = getelementptr inbounds %struct.anon.3, ptr %arrayinit.begin, i32 0, i32 0
  store i16 13733, ptr %k, align 64, !tbaa !27
  %a = getelementptr inbounds %struct.anon.3, ptr %arrayinit.begin, i32 0, i32 1
  %call = call <8 x i64> @simde_mm512_set_epi32(i32 noundef -1058044212, i32 noundef 1745554146, i32 noundef -938028173, i32 noundef 1123843978, i32 noundef 0, i32 noundef 369104615, i32 noundef 288860030, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 1441724088, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0)
  store <8 x i64> %call, ptr %a, align 64, !tbaa !16
  %b = getelementptr inbounds %struct.anon.3, ptr %arrayinit.begin, i32 0, i32 2
  %call1 = call <8 x i64> @simde_mm512_set_epi32(i32 noundef -173456664, i32 noundef 0, i32 noundef 1847983972, i32 noundef 0, i32 noundef 1618889484, i32 noundef -1607295283, i32 noundef 0, i32 noundef 0, i32 noundef 1566474746, i32 noundef 0, i32 noundef 0, i32 noundef -427236235, i32 noundef 1934991438, i32 noundef -587656653, i32 noundef -72145550, i32 noundef 0)
  store <8 x i64> %call1, ptr %b, align 64, !tbaa !16
  %r = getelementptr inbounds %struct.anon.3, ptr %arrayinit.begin, i32 0, i32 3
  store i16 9216, ptr %r, align 64, !tbaa !29
  %arrayinit.element = getelementptr inbounds %struct.anon.3, ptr %arrayinit.begin, i64 1
  %k2 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element, i32 0, i32 0
  store i16 -1903, ptr %k2, align 64, !tbaa !27
  %a3 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element, i32 0, i32 1
  %call4 = call <8 x i64> @simde_mm512_set_epi32(i32 noundef -839841286, i32 noundef 0, i32 noundef -1528318158, i32 noundef -1752243244, i32 noundef 0, i32 noundef -1210241348, i32 noundef -1908519219, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 521483609, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0)
  store <8 x i64> %call4, ptr %a3, align 64, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element, i32 0, i32 2
  %call6 = call <8 x i64> @simde_mm512_set_epi32(i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 543914332, i32 noundef 2140721152, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0)
  store <8 x i64> %call6, ptr %b5, align 64, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element, i32 0, i32 3
  store i16 4096, ptr %r7, align 64, !tbaa !29
  %arrayinit.element8 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element, i64 1
  %k9 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element8, i32 0, i32 0
  store i16 -19504, ptr %k9, align 64, !tbaa !27
  %a10 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element8, i32 0, i32 1
  %call11 = call <8 x i64> @simde_mm512_set_epi32(i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 329000619, i32 noundef -1407469850, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef -102278232, i32 noundef 43450551, i32 noundef 0, i32 noundef 1603148048, i32 noundef 0, i32 noundef 306941628, i32 noundef 0, i32 noundef 1716086600)
  store <8 x i64> %call11, ptr %a10, align 64, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element8, i32 0, i32 2
  %call13 = call <8 x i64> @simde_mm512_set_epi32(i32 noundef 0, i32 noundef -262488052, i32 noundef 0, i32 noundef -979944078, i32 noundef 0, i32 noundef 0, i32 noundef -671140903, i32 noundef 2141932562, i32 noundef -937827627, i32 noundef -402281975, i32 noundef 1596901579, i32 noundef 735909604, i32 noundef 0, i32 noundef -1202496908, i32 noundef 0, i32 noundef 1187626051)
  store <8 x i64> %call13, ptr %b12, align 64, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element8, i32 0, i32 3
  store i16 4304, ptr %r14, align 64, !tbaa !29
  %arrayinit.element15 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element8, i64 1
  %k16 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element15, i32 0, i32 0
  store i16 22689, ptr %k16, align 64, !tbaa !27
  %a17 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element15, i32 0, i32 1
  %call18 = call <8 x i64> @simde_mm512_set_epi32(i32 noundef 0, i32 noundef 0, i32 noundef 1163951893, i32 noundef 0, i32 noundef 0, i32 noundef -972105386, i32 noundef 0, i32 noundef -189029459, i32 noundef -225058862, i32 noundef -1537122616, i32 noundef 0, i32 noundef -1756788873, i32 noundef 0, i32 noundef 0, i32 noundef -184793757, i32 noundef 1418114595)
  store <8 x i64> %call18, ptr %a17, align 64, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element15, i32 0, i32 2
  %call20 = call <8 x i64> @simde_mm512_set_epi32(i32 noundef -1354385088, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef -1841164366, i32 noundef -94325362, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 594617140, i32 noundef 0, i32 noundef 239227634, i32 noundef 0, i32 noundef 895132574, i32 noundef -123965580)
  store <8 x i64> %call20, ptr %b19, align 64, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element15, i32 0, i32 3
  store i16 1, ptr %r21, align 64, !tbaa !29
  %arrayinit.element22 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element15, i64 1
  %k23 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element22, i32 0, i32 0
  store i16 25521, ptr %k23, align 64, !tbaa !27
  %a24 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element22, i32 0, i32 1
  %call25 = call <8 x i64> @simde_mm512_set_epi32(i32 noundef 0, i32 noundef 1916556758, i32 noundef 729046451, i32 noundef 516587379, i32 noundef 1306886393, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 2010256146, i32 noundef -351991039, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0)
  store <8 x i64> %call25, ptr %a24, align 64, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element22, i32 0, i32 2
  %call27 = call <8 x i64> @simde_mm512_set_epi32(i32 noundef -1549799175, i32 noundef -926637576, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 1633420708, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef -1070649171, i32 noundef -629074644, i32 noundef -658686596, i32 noundef 1058031607, i32 noundef 0, i32 noundef 590507721)
  store <8 x i64> %call27, ptr %b26, align 64, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element22, i32 0, i32 3
  store i16 16416, ptr %r28, align 64, !tbaa !29
  %arrayinit.element29 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element22, i64 1
  %k30 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element29, i32 0, i32 0
  store i16 -3075, ptr %k30, align 64, !tbaa !27
  %a31 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element29, i32 0, i32 1
  %call32 = call <8 x i64> @simde_mm512_set_epi32(i32 noundef -1777930200, i32 noundef -2074304971, i32 noundef -1238248254, i32 noundef 0, i32 noundef 0, i32 noundef -2126101806, i32 noundef 1488735838, i32 noundef -1941730876, i32 noundef 0, i32 noundef 0, i32 noundef -1287988933, i32 noundef -234166092, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 1899039383)
  store <8 x i64> %call32, ptr %a31, align 64, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element29, i32 0, i32 2
  %call34 = call <8 x i64> @simde_mm512_set_epi32(i32 noundef -2019508611, i32 noundef 0, i32 noundef 630346390, i32 noundef 1865079685, i32 noundef -135665525, i32 noundef 0, i32 noundef 751170486, i32 noundef 580518147, i32 noundef 875750845, i32 noundef 263799439, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef -889468036, i32 noundef 606319308, i32 noundef 0)
  store <8 x i64> %call34, ptr %b33, align 64, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element29, i32 0, i32 3
  store i16 -23808, ptr %r35, align 64, !tbaa !29
  %arrayinit.element36 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element29, i64 1
  %k37 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element36, i32 0, i32 0
  store i16 -642, ptr %k37, align 64, !tbaa !27
  %a38 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element36, i32 0, i32 1
  %call39 = call <8 x i64> @simde_mm512_set_epi32(i32 noundef 1983606396, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 1668321234, i32 noundef 1230207891, i32 noundef -1334904081, i32 noundef -1369460101, i32 noundef 0, i32 noundef 0, i32 noundef 556969985, i32 noundef 844640930, i32 noundef -1447169687, i32 noundef -621740127, i32 noundef 1847803343, i32 noundef 0)
  store <8 x i64> %call39, ptr %a38, align 64, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element36, i32 0, i32 2
  %call41 = call <8 x i64> @simde_mm512_set_epi32(i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef -578157153, i32 noundef 0, i32 noundef -1740019927, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 136767631, i32 noundef 0, i32 noundef -1994887012, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef -1203448248)
  store <8 x i64> %call41, ptr %b40, align 64, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element36, i32 0, i32 3
  store i16 1040, ptr %r42, align 64, !tbaa !29
  %arrayinit.element43 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element36, i64 1
  %k44 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element43, i32 0, i32 0
  store i16 72, ptr %k44, align 64, !tbaa !27
  %a45 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element43, i32 0, i32 1
  %call46 = call <8 x i64> @simde_mm512_set_epi32(i32 noundef 0, i32 noundef -302271050, i32 noundef 0, i32 noundef 0, i32 noundef 1073370549, i32 noundef 911478852, i32 noundef 2032788905, i32 noundef 0, i32 noundef 398076492, i32 noundef 901163928, i32 noundef 0, i32 noundef -1022133203, i32 noundef -345543230, i32 noundef 0, i32 noundef 2110415254, i32 noundef 0)
  store <8 x i64> %call46, ptr %a45, align 64, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element43, i32 0, i32 2
  %call48 = call <8 x i64> @simde_mm512_set_epi32(i32 noundef 0, i32 noundef 1062395075, i32 noundef -125220770, i32 noundef 0, i32 noundef 0, i32 noundef -1603705335, i32 noundef -1563808089, i32 noundef 0, i32 noundef 0, i32 noundef 1591467282, i32 noundef -57010818, i32 noundef 0, i32 noundef 0, i32 noundef 1904594022, i32 noundef 0, i32 noundef -170170916)
  store <8 x i64> %call48, ptr %b47, align 64, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.3, ptr %arrayinit.element43, i32 0, i32 3
  store i16 64, ptr %r49, align 64, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #11
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup61

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 2, ptr %r50) #11
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.3], ptr %test_vec, i64 0, i64 %1
  %k51 = getelementptr inbounds %struct.anon.3, ptr %arrayidx, i32 0, i32 0
  %2 = load i16, ptr %k51, align 64, !tbaa !27
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx52 = getelementptr inbounds [8 x %struct.anon.3], ptr %test_vec, i64 0, i64 %3
  %a53 = getelementptr inbounds %struct.anon.3, ptr %arrayidx52, i32 0, i32 1
  %4 = load <8 x i64>, ptr %a53, align 64, !tbaa !16
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx54 = getelementptr inbounds [8 x %struct.anon.3], ptr %test_vec, i64 0, i64 %5
  %b55 = getelementptr inbounds %struct.anon.3, ptr %arrayidx54, i32 0, i32 2
  %6 = load <8 x i64>, ptr %b55, align 64, !tbaa !16
  store <8 x i64> %4, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %6, ptr %indirect-arg-temp56, align 64, !tbaa !16
  %call57 = call zeroext i16 @simde_mm512_mask_test_epi32_mask(i16 noundef zeroext %2, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp56)
  store i16 %call57, ptr %r50, align 2, !tbaa !17
  br label %do.body

do.body:                                          ; preds = %for.body
  %7 = load i16, ptr %r50, align 2, !tbaa !17
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx58 = getelementptr inbounds [8 x %struct.anon.3], ptr %test_vec, i64 0, i64 %8
  %r59 = getelementptr inbounds %struct.anon.3, ptr %arrayidx58, i32 0, i32 3
  %9 = load i16, ptr %r59, align 64, !tbaa !29
  %call60 = call i32 @simde_assert_equal_u16_(i16 noundef zeroext %7, i16 noundef zeroext %9, ptr noundef @.str.13, i32 noundef 393, ptr noundef @.str.14, ptr noundef @.str.17)
  %tobool = icmp ne i32 %call60, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 2, ptr %r50) #11
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup61 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %10, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup61:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #11
  %cleanup.dest62 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest62, label %cleanup63 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup61
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup63

cleanup63:                                        ; preds = %for.end, %cleanup61
  call void @llvm.lifetime.end.p0(i64 2048, ptr %test_vec) #11
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm512_mask_test_epi64_mask() #4 {
entry:
  %retval = alloca i32, align 4
  %test_vec = alloca [8 x %struct.anon.4], align 64
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %r50 = alloca i8, align 1
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp56 = alloca <8 x i64>, align 64
  call void @llvm.lifetime.start.p0(i64 2048, ptr %test_vec) #11
  %arrayinit.begin = getelementptr inbounds [8 x %struct.anon.4], ptr %test_vec, i64 0, i64 0
  %k = getelementptr inbounds %struct.anon.4, ptr %arrayinit.begin, i32 0, i32 0
  store i8 51, ptr %k, align 64, !tbaa !30
  %a = getelementptr inbounds %struct.anon.4, ptr %arrayinit.begin, i32 0, i32 1
  %call = call <8 x i64> @simde_mm512_set_epi64(i64 noundef -1021777151925940720, i64 noundef -8606874489654438743, i64 noundef 2982642907250026668, i64 noundef 1121557266302837638, i64 noundef 2431134246593116065, i64 noundef 613583019816833791, i64 noundef 1064733599562411669, i64 noundef 2423175833785490495)
  store <8 x i64> %call, ptr %a, align 64, !tbaa !16
  %b = getelementptr inbounds %struct.anon.4, ptr %arrayinit.begin, i32 0, i32 2
  %call1 = call <8 x i64> @simde_mm512_set_epi64(i64 noundef 1320056489604494378, i64 noundef 8016850443050245285, i64 noundef -1985397303830803362, i64 noundef 3490054501014041612, i64 noundef -5459290507928993205, i64 noundef 7649116850053105819, i64 noundef 2306883418990405350, i64 noundef -533675138939657219)
  store <8 x i64> %call1, ptr %b, align 64, !tbaa !16
  %r = getelementptr inbounds %struct.anon.4, ptr %arrayinit.begin, i32 0, i32 3
  store i8 51, ptr %r, align 64, !tbaa !32
  %arrayinit.element = getelementptr inbounds %struct.anon.4, ptr %arrayinit.begin, i64 1
  %k2 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element, i32 0, i32 0
  store i8 107, ptr %k2, align 64, !tbaa !30
  %a3 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element, i32 0, i32 1
  %call4 = call <8 x i64> @simde_mm512_set_epi64(i64 noundef -5107242476853461048, i64 noundef 8011490560794608442, i64 noundef 6781928010904462143, i64 noundef -2849262341734469560, i64 noundef -680409599063304510, i64 noundef -5566534159487294326, i64 noundef 1845249206901740837, i64 noundef -995351966812894672)
  store <8 x i64> %call4, ptr %a3, align 64, !tbaa !16
  %b5 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element, i32 0, i32 2
  %call6 = call <8 x i64> @simde_mm512_set_epi64(i64 noundef 5576021829988608395, i64 noundef 6950975376569962720, i64 noundef -6894298607029431267, i64 noundef 627810606408873629, i64 noundef 5554191263207946561, i64 noundef -8076655846804767103, i64 noundef 298038848695084217, i64 noundef 984575648746107146)
  store <8 x i64> %call6, ptr %b5, align 64, !tbaa !16
  %r7 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element, i32 0, i32 3
  store i8 107, ptr %r7, align 64, !tbaa !32
  %arrayinit.element8 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element, i64 1
  %k9 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element8, i32 0, i32 0
  store i8 37, ptr %k9, align 64, !tbaa !30
  %a10 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element8, i32 0, i32 1
  %call11 = call <8 x i64> @simde_mm512_set_epi64(i64 noundef 7893528652770105648, i64 noundef 6530680127391412513, i64 noundef 8552423929938430730, i64 noundef -2756847038438887047, i64 noundef -4669427049793346259, i64 noundef -1241821792536551210, i64 noundef -3299061013747874632, i64 noundef -6836802816564857048)
  store <8 x i64> %call11, ptr %a10, align 64, !tbaa !16
  %b12 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element8, i32 0, i32 2
  %call13 = call <8 x i64> @simde_mm512_set_epi64(i64 noundef -6002777026216974201, i64 noundef -4636334703117125394, i64 noundef 1607894826575669284, i64 noundef 4780984352817723804, i64 noundef 6091782245426739371, i64 noundef 678622961946838177, i64 noundef -5016020090857558708, i64 noundef 6626170086889501267)
  store <8 x i64> %call13, ptr %b12, align 64, !tbaa !16
  %r14 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element8, i32 0, i32 3
  store i8 37, ptr %r14, align 64, !tbaa !32
  %arrayinit.element15 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element8, i64 1
  %k16 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element15, i32 0, i32 0
  store i8 -37, ptr %k16, align 64, !tbaa !30
  %a17 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element15, i32 0, i32 1
  %call18 = call <8 x i64> @simde_mm512_set_epi64(i64 noundef -2186517171747754940, i64 noundef -7709006576096545178, i64 noundef -4148769136791016488, i64 noundef -1135438727484114896, i64 noundef 8260953320246547916, i64 noundef -1100980776979386438, i64 noundef -5918460005278991975, i64 noundef -9003997367625569086)
  store <8 x i64> %call18, ptr %a17, align 64, !tbaa !16
  %b19 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element15, i32 0, i32 2
  %call20 = call <8 x i64> @simde_mm512_set_epi64(i64 noundef 4216784995205036162, i64 noundef -610629877628633270, i64 noundef 8989369503655563805, i64 noundef 7802074548335401303, i64 noundef -8877282827036376912, i64 noundef 503689220758847744, i64 noundef -1271186344370845002, i64 noundef -7863377575460447119)
  store <8 x i64> %call20, ptr %b19, align 64, !tbaa !16
  %r21 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element15, i32 0, i32 3
  store i8 -37, ptr %r21, align 64, !tbaa !32
  %arrayinit.element22 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element15, i64 1
  %k23 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element22, i32 0, i32 0
  store i8 -25, ptr %k23, align 64, !tbaa !30
  %a24 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element22, i32 0, i32 1
  %call25 = call <8 x i64> @simde_mm512_set_epi64(i64 noundef -1315792135193853217, i64 noundef 645488177526442731, i64 noundef -9165154544452808856, i64 noundef 6660247336280542891, i64 noundef 6275701276122863077, i64 noundef 6727198969638040444, i64 noundef -7884988216343642316, i64 noundef -2772157409458686119)
  store <8 x i64> %call25, ptr %a24, align 64, !tbaa !16
  %b26 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element22, i32 0, i32 2
  %call27 = call <8 x i64> @simde_mm512_set_epi64(i64 noundef -3947691112861846019, i64 noundef -6027683744476655452, i64 noundef 7878786769508596925, i64 noundef 898779895364838727, i64 noundef 1691913248175202869, i64 noundef 925600519637433490, i64 noundef -7786666185996880531, i64 noundef 83985053119720048)
  store <8 x i64> %call27, ptr %b26, align 64, !tbaa !16
  %r28 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element22, i32 0, i32 3
  store i8 -25, ptr %r28, align 64, !tbaa !32
  %arrayinit.element29 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element22, i64 1
  %k30 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element29, i32 0, i32 0
  store i8 -71, ptr %k30, align 64, !tbaa !30
  %a31 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element29, i32 0, i32 1
  %call32 = call <8 x i64> @simde_mm512_set_epi64(i64 noundef -1840026123275896761, i64 noundef 2958979742732699034, i64 noundef 8087751231081622093, i64 noundef -8600769129449664089, i64 noundef 4437078864330373252, i64 noundef -7780807660685149956, i64 noundef -2075154109213332653, i64 noundef 4181892367727099352)
  store <8 x i64> %call32, ptr %a31, align 64, !tbaa !16
  %b33 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element29, i32 0, i32 2
  %call34 = call <8 x i64> @simde_mm512_set_epi64(i64 noundef 774147715399030450, i64 noundef -164954981177608742, i64 noundef 2704996814905355295, i64 noundef -8428935692581869552, i64 noundef 9058580247051597222, i64 noundef -5265103403663862315, i64 noundef -26456365246944797, i64 noundef -2390663458830548776)
  store <8 x i64> %call34, ptr %b33, align 64, !tbaa !16
  %r35 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element29, i32 0, i32 3
  store i8 -71, ptr %r35, align 64, !tbaa !32
  %arrayinit.element36 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element29, i64 1
  %k37 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element36, i32 0, i32 0
  store i8 101, ptr %k37, align 64, !tbaa !30
  %a38 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element36, i32 0, i32 1
  %call39 = call <8 x i64> @simde_mm512_set_epi64(i64 noundef -500144007601202828, i64 noundef 1632600048776630049, i64 noundef -841897496147484648, i64 noundef -9027608573250153699, i64 noundef 5145549241007852287, i64 noundef 3253065934430492129, i64 noundef -7159974623801904746, i64 noundef -5093282550607071469)
  store <8 x i64> %call39, ptr %a38, align 64, !tbaa !16
  %b40 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element36, i32 0, i32 2
  %call41 = call <8 x i64> @simde_mm512_set_epi64(i64 noundef -5525231520825547752, i64 noundef -8701772324698157173, i64 noundef -8951932473020511764, i64 noundef 3775424668993203418, i64 noundef 6848385375992501495, i64 noundef 530028931531319450, i64 noundef -2966939250988120843, i64 noundef 8223727294178057916)
  store <8 x i64> %call41, ptr %b40, align 64, !tbaa !16
  %r42 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element36, i32 0, i32 3
  store i8 101, ptr %r42, align 64, !tbaa !32
  %arrayinit.element43 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element36, i64 1
  %k44 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element43, i32 0, i32 0
  store i8 49, ptr %k44, align 64, !tbaa !30
  %a45 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element43, i32 0, i32 1
  %call46 = call <8 x i64> @simde_mm512_set_epi64(i64 noundef -6089529524580685715, i64 noundef -7930651770137634148, i64 noundef 5513049874271089607, i64 noundef -418315818469941774, i64 noundef 5583867531021541749, i64 noundef 3646229040969122240, i64 noundef 298432255739992787, i64 noundef 8383322056459699927)
  store <8 x i64> %call46, ptr %a45, align 64, !tbaa !16
  %b47 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element43, i32 0, i32 2
  %call48 = call <8 x i64> @simde_mm512_set_epi64(i64 noundef 6173222450906561792, i64 noundef -2639921841557235108, i64 noundef 1632309106004579853, i64 noundef -5099037996367773534, i64 noundef -4229050909659913228, i64 noundef -6254506698641899913, i64 noundef 1797655404582044593, i64 noundef 7065183211262770455)
  store <8 x i64> %call48, ptr %b47, align 64, !tbaa !16
  %r49 = getelementptr inbounds %struct.anon.4, ptr %arrayinit.element43, i32 0, i32 3
  store i8 49, ptr %r49, align 64, !tbaa !32
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #11
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup61

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %r50) #11
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.4], ptr %test_vec, i64 0, i64 %1
  %k51 = getelementptr inbounds %struct.anon.4, ptr %arrayidx, i32 0, i32 0
  %2 = load i8, ptr %k51, align 64, !tbaa !30
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx52 = getelementptr inbounds [8 x %struct.anon.4], ptr %test_vec, i64 0, i64 %3
  %a53 = getelementptr inbounds %struct.anon.4, ptr %arrayidx52, i32 0, i32 1
  %4 = load <8 x i64>, ptr %a53, align 64, !tbaa !16
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx54 = getelementptr inbounds [8 x %struct.anon.4], ptr %test_vec, i64 0, i64 %5
  %b55 = getelementptr inbounds %struct.anon.4, ptr %arrayidx54, i32 0, i32 2
  %6 = load <8 x i64>, ptr %b55, align 64, !tbaa !16
  store <8 x i64> %4, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %6, ptr %indirect-arg-temp56, align 64, !tbaa !16
  %call57 = call zeroext i8 @simde_mm512_mask_test_epi64_mask(i8 noundef zeroext %2, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp56)
  store i8 %call57, ptr %r50, align 1, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %7 = load i8, ptr %r50, align 1, !tbaa !16
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx58 = getelementptr inbounds [8 x %struct.anon.4], ptr %test_vec, i64 0, i64 %8
  %r59 = getelementptr inbounds %struct.anon.4, ptr %arrayidx58, i32 0, i32 3
  %9 = load i8, ptr %r59, align 64, !tbaa !32
  %call60 = call i32 @simde_assert_equal_u8_(i8 noundef zeroext %7, i8 noundef zeroext %9, ptr noundef @.str.13, i32 noundef 491, ptr noundef @.str.14, ptr noundef @.str.15)
  %tobool = icmp ne i32 %call60, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 1, ptr %r50) #11
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup61 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %10, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup61:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #11
  %cleanup.dest62 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest62, label %cleanup63 [
    i32 2, label %for.end
  ]

for.end:                                          ; preds = %cleanup61
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup63

cleanup63:                                        ; preds = %for.end, %cleanup61
  call void @llvm.lifetime.end.p0(i64 2048, ptr %test_vec) #11
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm512_mask_test_epi8_mask() #4 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <8 x i64>, align 64
  %b = alloca <8 x i64>, align 64
  %r = alloca i64, align 8
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp7 = alloca <8 x i64>, align 64
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #11
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup14

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 64, ptr %a) #11
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.5], ptr @test_simde_mm512_mask_test_epi8_mask.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.5, ptr %arrayidx, i32 0, i32 1
  %arraydecay = getelementptr inbounds [64 x i8], ptr %a1, i64 0, i64 0
  %call = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay)
  store <8 x i64> %call, ptr %a, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %b) #11
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.5], ptr @test_simde_mm512_mask_test_epi8_mask.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.5, ptr %arrayidx2, i32 0, i32 2
  %arraydecay4 = getelementptr inbounds [64 x i8], ptr %b3, i64 0, i64 0
  %call5 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay4)
  store <8 x i64> %call5, ptr %b, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %r) #11
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx6 = getelementptr inbounds [8 x %struct.anon.5], ptr @test_simde_mm512_mask_test_epi8_mask.test_vec, i64 0, i64 %3
  %k1 = getelementptr inbounds %struct.anon.5, ptr %arrayidx6, i32 0, i32 0
  %4 = load i64, ptr %k1, align 16, !tbaa !33
  %5 = load <8 x i64>, ptr %a, align 64, !tbaa !16
  %6 = load <8 x i64>, ptr %b, align 64, !tbaa !16
  store <8 x i64> %5, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %6, ptr %indirect-arg-temp7, align 64, !tbaa !16
  %call8 = call i64 @simde_mm512_mask_test_epi8_mask(i64 noundef %4, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp7)
  store i64 %call8, ptr %r, align 8, !tbaa !11
  br label %do.body

do.body:                                          ; preds = %for.body
  %7 = load i64, ptr %r, align 8, !tbaa !11
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx9 = getelementptr inbounds [8 x %struct.anon.5], ptr @test_simde_mm512_mask_test_epi8_mask.test_vec, i64 0, i64 %8
  %r10 = getelementptr inbounds %struct.anon.5, ptr %arrayidx9, i32 0, i32 3
  %9 = load i64, ptr %r10, align 8, !tbaa !35
  %call11 = call i32 @simde_assert_equal_u64_(i64 noundef %7, i64 noundef %9, ptr noundef @.str.13, i32 noundef 656, ptr noundef @.str.14, ptr noundef @.str.15)
  %tobool = icmp ne i32 %call11, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 8, ptr %r) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %b) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %a) #11
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup14 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %10, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup14:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #11
  %cleanup.dest15 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest15, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup14
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup14
  %11 = load i32, ptr %retval, align 4
  ret i32 %11

unreachable:                                      ; preds = %cleanup14
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm512_test_epi16_mask() #4 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <8 x i64>, align 64
  %b = alloca <8 x i64>, align 64
  %r = alloca i32, align 4
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp6 = alloca <8 x i64>, align 64
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #11
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup13

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 64, ptr %a) #11
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.6], ptr @test_simde_mm512_test_epi16_mask.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.6, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [32 x i16], ptr %a1, i64 0, i64 0
  %call = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay)
  store <8 x i64> %call, ptr %a, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %b) #11
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.6], ptr @test_simde_mm512_test_epi16_mask.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.6, ptr %arrayidx2, i32 0, i32 1
  %arraydecay4 = getelementptr inbounds [32 x i16], ptr %b3, i64 0, i64 0
  %call5 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay4)
  store <8 x i64> %call5, ptr %b, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 4, ptr %r) #11
  %3 = load <8 x i64>, ptr %a, align 64, !tbaa !16
  %4 = load <8 x i64>, ptr %b, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %4, ptr %indirect-arg-temp6, align 64, !tbaa !16
  %call7 = call i32 @simde_mm512_test_epi16_mask(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp6)
  store i32 %call7, ptr %r, align 4, !tbaa !5
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load i32, ptr %r, align 4, !tbaa !5
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx8 = getelementptr inbounds [8 x %struct.anon.6], ptr @test_simde_mm512_test_epi16_mask.test_vec, i64 0, i64 %6
  %r9 = getelementptr inbounds %struct.anon.6, ptr %arrayidx8, i32 0, i32 2
  %7 = load i32, ptr %r9, align 4, !tbaa !36
  %call10 = call i32 @simde_assert_equal_u32_(i32 noundef %5, i32 noundef %7, ptr noundef @.str.13, i32 noundef 770, ptr noundef @.str.14, ptr noundef @.str.15)
  %tobool = icmp ne i32 %call10, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %r) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %b) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %a) #11
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup13 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup13:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #11
  %cleanup.dest14 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest14, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup13
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup13
  %9 = load i32, ptr %retval, align 4
  ret i32 %9

unreachable:                                      ; preds = %cleanup13
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm512_test_epi32_mask() #4 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <8 x i64>, align 64
  %b = alloca <8 x i64>, align 64
  %r = alloca i16, align 2
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp6 = alloca <8 x i64>, align 64
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #11
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup13

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 64, ptr %a) #11
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.7], ptr @test_simde_mm512_test_epi32_mask.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.7, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i32], ptr %a1, i64 0, i64 0
  %call = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay)
  store <8 x i64> %call, ptr %a, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %b) #11
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.7], ptr @test_simde_mm512_test_epi32_mask.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.7, ptr %arrayidx2, i32 0, i32 1
  %arraydecay4 = getelementptr inbounds [16 x i32], ptr %b3, i64 0, i64 0
  %call5 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay4)
  store <8 x i64> %call5, ptr %b, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 2, ptr %r) #11
  %3 = load <8 x i64>, ptr %a, align 64, !tbaa !16
  %4 = load <8 x i64>, ptr %b, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %4, ptr %indirect-arg-temp6, align 64, !tbaa !16
  %call7 = call zeroext i16 @simde_mm512_test_epi32_mask(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp6)
  store i16 %call7, ptr %r, align 2, !tbaa !17
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load i16, ptr %r, align 2, !tbaa !17
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx8 = getelementptr inbounds [8 x %struct.anon.7], ptr @test_simde_mm512_test_epi32_mask.test_vec, i64 0, i64 %6
  %r9 = getelementptr inbounds %struct.anon.7, ptr %arrayidx8, i32 0, i32 2
  %7 = load i16, ptr %r9, align 4, !tbaa !38
  %call10 = call i32 @simde_assert_equal_u16_(i16 noundef zeroext %5, i16 noundef zeroext %7, ptr noundef @.str.13, i32 noundef 850, ptr noundef @.str.14, ptr noundef @.str.15)
  %tobool = icmp ne i32 %call10, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 2, ptr %r) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %b) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %a) #11
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup13 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup13:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #11
  %cleanup.dest14 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest14, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup13
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup13
  %9 = load i32, ptr %retval, align 4
  ret i32 %9

unreachable:                                      ; preds = %cleanup13
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm512_test_epi64_mask() #4 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <8 x i64>, align 64
  %b = alloca <8 x i64>, align 64
  %r = alloca i8, align 1
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp6 = alloca <8 x i64>, align 64
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #11
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup13

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 64, ptr %a) #11
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.8], ptr @test_simde_mm512_test_epi64_mask.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.8, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [8 x i64], ptr %a1, i64 0, i64 0
  %call = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay)
  store <8 x i64> %call, ptr %a, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %b) #11
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.8], ptr @test_simde_mm512_test_epi64_mask.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.8, ptr %arrayidx2, i32 0, i32 1
  %arraydecay4 = getelementptr inbounds [8 x i64], ptr %b3, i64 0, i64 0
  %call5 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay4)
  store <8 x i64> %call5, ptr %b, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 1, ptr %r) #11
  %3 = load <8 x i64>, ptr %a, align 64, !tbaa !16
  %4 = load <8 x i64>, ptr %b, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %4, ptr %indirect-arg-temp6, align 64, !tbaa !16
  %call7 = call zeroext i8 @simde_mm512_test_epi64_mask(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp6)
  store i8 %call7, ptr %r, align 1, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load i8, ptr %r, align 1, !tbaa !16
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx8 = getelementptr inbounds [8 x %struct.anon.8], ptr @test_simde_mm512_test_epi64_mask.test_vec, i64 0, i64 %6
  %r9 = getelementptr inbounds %struct.anon.8, ptr %arrayidx8, i32 0, i32 2
  %7 = load i8, ptr %r9, align 8, !tbaa !40
  %call10 = call i32 @simde_assert_equal_u8_(i8 noundef zeroext %5, i8 noundef zeroext %7, ptr noundef @.str.13, i32 noundef 930, ptr noundef @.str.14, ptr noundef @.str.15)
  %tobool = icmp ne i32 %call10, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 1, ptr %r) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %b) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %a) #11
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup13 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup13:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #11
  %cleanup.dest14 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest14, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup13
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup13
  %9 = load i32, ptr %retval, align 4
  ret i32 %9

unreachable:                                      ; preds = %cleanup13
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm512_test_epi8_mask() #4 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <8 x i64>, align 64
  %b = alloca <8 x i64>, align 64
  %r = alloca i64, align 8
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp6 = alloca <8 x i64>, align 64
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #11
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup13

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 64, ptr %a) #11
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.9], ptr @test_simde_mm512_test_epi8_mask.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.9, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [64 x i8], ptr %a1, i64 0, i64 0
  %call = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay)
  store <8 x i64> %call, ptr %a, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %b) #11
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.9], ptr @test_simde_mm512_test_epi8_mask.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.9, ptr %arrayidx2, i32 0, i32 1
  %arraydecay4 = getelementptr inbounds [64 x i8], ptr %b3, i64 0, i64 0
  %call5 = call <8 x i64> @simde_mm512_loadu_si512(ptr noundef %arraydecay4)
  store <8 x i64> %call5, ptr %b, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %r) #11
  %3 = load <8 x i64>, ptr %a, align 64, !tbaa !16
  %4 = load <8 x i64>, ptr %b, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %4, ptr %indirect-arg-temp6, align 64, !tbaa !16
  %call7 = call i64 @simde_mm512_test_epi8_mask(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp6)
  store i64 %call7, ptr %r, align 8, !tbaa !11
  br label %do.body

do.body:                                          ; preds = %for.body
  %5 = load i64, ptr %r, align 8, !tbaa !11
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx8 = getelementptr inbounds [8 x %struct.anon.9], ptr @test_simde_mm512_test_epi8_mask.test_vec, i64 0, i64 %6
  %r9 = getelementptr inbounds %struct.anon.9, ptr %arrayidx8, i32 0, i32 2
  %7 = load i64, ptr %r9, align 8, !tbaa !42
  %call10 = call i32 @simde_assert_equal_u64_(i64 noundef %5, i64 noundef %7, ptr noundef @.str.13, i32 noundef 1106, ptr noundef @.str.14, ptr noundef @.str.15)
  %tobool = icmp ne i32 %call10, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 8, ptr %r) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %b) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %a) #11
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup13 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup13:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #11
  %cleanup.dest14 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest14, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup13
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup13
  %9 = load i32, ptr %retval, align 4
  ret i32 %9

unreachable:                                      ; preds = %cleanup13
  unreachable
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x i64> @simde_mm256_loadu_epi32(ptr noundef %mem_addr) #5 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %r = alloca <4 x i64>, align 32
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 32, ptr %r) #11
  %0 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.memcpy.p0.p0.i64(ptr align 32 %r, ptr align 1 %0, i64 32, i1 false)
  %1 = load <4 x i64>, ptr %r, align 32, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 32, ptr %r) #11
  ret <4 x i64> %1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i8 @simde_mm256_test_epi32_mask(ptr noundef byval(<4 x i64>) align 32 %0, ptr noundef byval(<4 x i64>) align 32 %1) #6 {
entry:
  %a.addr = alloca <4 x i64>, align 32
  %b.addr = alloca <4 x i64>, align 32
  %a_ = alloca %union.simde__m256i_private, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %b_ = alloca %union.simde__m256i_private, align 32
  %indirect-arg-temp1 = alloca <4 x i64>, align 32
  %r = alloca i8, align 1
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  %r2 = alloca i8, align 1
  %a = load <4 x i64>, ptr %0, align 32, !tbaa !16
  %b = load <4 x i64>, ptr %1, align 32, !tbaa !16
  store <4 x i64> %a, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %b, ptr %b.addr, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %a_) #11
  %2 = load <4 x i64>, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %2, ptr %indirect-arg-temp, align 32, !tbaa !16
  call void @simde__m256i_to_private(ptr sret(%union.simde__m256i_private) align 32 %a_, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 32, ptr %b_) #11
  %3 = load <4 x i64>, ptr %b.addr, align 32, !tbaa !16
  store <4 x i64> %3, ptr %indirect-arg-temp1, align 32, !tbaa !16
  call void @simde__m256i_to_private(ptr sret(%union.simde__m256i_private) align 32 %b_, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp1)
  call void @llvm.lifetime.start.p0(i64 1, ptr %r) #11
  store i8 0, ptr %r, align 1, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #11
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #11
  call void @llvm.lifetime.start.p0(i64 1, ptr %r2) #11
  store i8 0, ptr %r2, align 1, !tbaa !16
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %4 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !44
  %cmp = icmp ult i64 %4, 8
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %5 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !44
  %mul = mul i64 %5, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !44
  %6 = load <8 x i32>, ptr %a_, align 32, !tbaa !16, !llvm.access.group !44
  %7 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !44
  %vecext = extractelement <8 x i32> %6, i64 %7
  %8 = load <8 x i32>, ptr %b_, align 32, !tbaa !16, !llvm.access.group !44
  %9 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !44
  %vecext3 = extractelement <8 x i32> %8, i64 %9
  %and = and i32 %vecext, %vecext3
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %10 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !44
  %sh_prom = trunc i64 %10 to i32
  %shl = shl i32 %lnot.ext, %sh_prom
  %conv = trunc i32 %shl to i16
  %conv5 = zext i16 %conv to i32
  %11 = load i8, ptr %r2, align 1, !tbaa !16, !llvm.access.group !44
  %conv6 = zext i8 %11 to i32
  %or = or i32 %conv6, %conv5
  %conv7 = trunc i32 %or to i8
  store i8 %conv7, ptr %r2, align 1, !tbaa !16, !llvm.access.group !44
  br label %omp.body.continue

omp.body.continue:                                ; preds = %omp.inner.for.body
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %12 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !44
  %add8 = add i64 %12, 1
  store i64 %add8, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !44
  br label %omp.inner.for.cond, !llvm.loop !45

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 8, ptr %i, align 8, !tbaa !11
  %13 = load i8, ptr %r, align 1, !tbaa !16
  %conv9 = zext i8 %13 to i32
  %14 = load i8, ptr %r2, align 1, !tbaa !16
  %conv10 = zext i8 %14 to i32
  %or11 = or i32 %conv9, %conv10
  %conv12 = trunc i32 %or11 to i8
  store i8 %conv12, ptr %r, align 1, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 1, ptr %r2) #11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #11
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #11
  %15 = load i8, ptr %r, align 1, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 1, ptr %r) #11
  call void @llvm.lifetime.end.p0(i64 32, ptr %b_) #11
  call void @llvm.lifetime.end.p0(i64 32, ptr %a_) #11
  ret i8 %15
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_u16_(i16 noundef zeroext %a, i16 noundef zeroext %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i16, align 2
  %b.addr = alloca i16, align 2
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  store i16 %a, ptr %a.addr, align 2, !tbaa !17
  store i16 %b, ptr %b.addr, align 2, !tbaa !17
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i16, ptr %a.addr, align 2, !tbaa !17
  %conv = zext i16 %0 to i32
  %1 = load i16, ptr %b.addr, align 2, !tbaa !17
  %conv1 = zext i16 %1 to i32
  %cmp = icmp ne i32 %conv, %conv1
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %3 = load i32, ptr %line.addr, align 4, !tbaa !5
  %4 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %5 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %6 = load i16, ptr %a.addr, align 2, !tbaa !17
  %conv5 = zext i16 %6 to i32
  %7 = load i16, ptr %b.addr, align 2, !tbaa !17
  %conv6 = zext i16 %7 to i32
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.16, ptr noundef %2, i32 noundef %3, ptr noundef %4, ptr noundef %5, i32 noundef %conv5, i32 noundef %conv6)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #7

; Function Attrs: alwaysinline nounwind uwtable
define internal void @simde__m256i_to_private(ptr noalias sret(%union.simde__m256i_private) align 32 %agg.result, ptr noundef byval(<4 x i64>) align 32 %0) #6 {
entry:
  %v.addr = alloca <4 x i64>, align 32
  %v = load <4 x i64>, ptr %0, align 32, !tbaa !16
  store <4 x i64> %v, ptr %v.addr, align 32, !tbaa !16
  call void @llvm.memcpy.p0.p0.i64(ptr align 32 %agg.result, ptr align 32 %v.addr, i64 32, i1 false)
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(none)
declare i64 @llvm.expect.i64(i64, i64) #8

; Function Attrs: nounwind uwtable
define internal void @simde_test_debug_printf_(ptr noundef %format, ...) #0 {
entry:
  %format.addr = alloca ptr, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  store ptr %format, ptr %format.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 24, ptr %ap) #11
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_start.p0(ptr %arraydecay)
  %0 = load ptr, ptr @stderr, align 8, !tbaa !9
  %1 = load ptr, ptr %format.addr, align 8, !tbaa !9
  %arraydecay1 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %call = call i32 @vfprintf(ptr noundef %0, ptr noundef %1, ptr noundef %arraydecay1)
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_end.p0(ptr %arraydecay2)
  %2 = load ptr, ptr @stderr, align 8, !tbaa !9
  %call3 = call i32 @fflush(ptr noundef %2)
  call void @llvm.lifetime.end.p0(i64 24, ptr %ap) #11
  ret void
}

declare i32 @vfprintf(ptr noundef, ptr noundef, ptr noundef) #2

declare i32 @fflush(ptr noundef) #2

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i8 @simde_mm256_mask_test_epi32_mask(i8 noundef zeroext %k1, ptr noundef byval(<4 x i64>) align 32 %0, ptr noundef byval(<4 x i64>) align 32 %1) #6 {
entry:
  %k1.addr = alloca i8, align 1
  %a.addr = alloca <4 x i64>, align 32
  %b.addr = alloca <4 x i64>, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %indirect-arg-temp1 = alloca <4 x i64>, align 32
  %a = load <4 x i64>, ptr %0, align 32, !tbaa !16
  %b = load <4 x i64>, ptr %1, align 32, !tbaa !16
  store i8 %k1, ptr %k1.addr, align 1, !tbaa !16
  store <4 x i64> %a, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %b, ptr %b.addr, align 32, !tbaa !16
  %2 = load <4 x i64>, ptr %a.addr, align 32, !tbaa !16
  %3 = load <4 x i64>, ptr %b.addr, align 32, !tbaa !16
  store <4 x i64> %2, ptr %indirect-arg-temp, align 32, !tbaa !16
  store <4 x i64> %3, ptr %indirect-arg-temp1, align 32, !tbaa !16
  %call = call zeroext i8 @simde_mm256_test_epi32_mask(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp1)
  %conv = zext i8 %call to i32
  %4 = load i8, ptr %k1.addr, align 1, !tbaa !16
  %conv2 = zext i8 %4 to i32
  %and = and i32 %conv, %conv2
  %conv3 = trunc i32 %and to i8
  ret i8 %conv3
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde_mm512_loadu_si512(ptr noundef %mem_addr) #9 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %r = alloca <8 x i64>, align 64
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #11
  %0 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  %v = getelementptr inbounds %struct.simde_mm512_loadu_si512_s, ptr %0, i32 0, i32 0
  %1 = load <8 x i64>, ptr %v, align 1, !tbaa !16
  store <8 x i64> %1, ptr %r, align 64, !tbaa !16
  %2 = load <8 x i64>, ptr %r, align 64, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #11
  ret <8 x i64> %2
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @simde_mm512_mask_test_epi16_mask(i32 noundef %k1, ptr noundef byval(<8 x i64>) align 64 %0, ptr noundef byval(<8 x i64>) align 64 %1) #6 {
entry:
  %k1.addr = alloca i32, align 4
  %a.addr = alloca <8 x i64>, align 64
  %b.addr = alloca <8 x i64>, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp1 = alloca <8 x i64>, align 64
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %b = load <8 x i64>, ptr %1, align 64, !tbaa !16
  store i32 %k1, ptr %k1.addr, align 4, !tbaa !5
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %b, ptr %b.addr, align 64, !tbaa !16
  %2 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  %3 = load <8 x i64>, ptr %b.addr, align 64, !tbaa !16
  store <8 x i64> %2, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp1, align 64, !tbaa !16
  %call = call i32 @simde_mm512_test_epi16_mask(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp1)
  %4 = load i32, ptr %k1.addr, align 4, !tbaa !5
  %and = and i32 %call, %4
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_u32_(i32 noundef %a, i32 noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  store i32 %a, ptr %a.addr, align 4, !tbaa !5
  store i32 %b, ptr %b.addr, align 4, !tbaa !5
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i32, ptr %a.addr, align 4, !tbaa !5
  %1 = load i32, ptr %b.addr, align 4, !tbaa !5
  %cmp = icmp ne i32 %0, %1
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %3 = load i32, ptr %line.addr, align 4, !tbaa !5
  %4 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %5 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %6 = load i32, ptr %a.addr, align 4, !tbaa !5
  %7 = load i32, ptr %b.addr, align 4, !tbaa !5
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.16, ptr noundef %2, i32 noundef %3, ptr noundef %4, ptr noundef %5, i32 noundef %6, i32 noundef %7)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @simde_mm512_test_epi16_mask(ptr noundef byval(<8 x i64>) align 64 %0, ptr noundef byval(<8 x i64>) align 64 %1) #6 {
entry:
  %a.addr = alloca <8 x i64>, align 64
  %b.addr = alloca <8 x i64>, align 64
  %a_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %b_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp1 = alloca <8 x i64>, align 64
  %r = alloca i32, align 4
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  %r2 = alloca i32, align 4
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %b = load <8 x i64>, ptr %1, align 64, !tbaa !16
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %b, ptr %b.addr, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %a_) #11
  %2 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %2, ptr %indirect-arg-temp, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %a_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 64, ptr %b_) #11
  %3 = load <8 x i64>, ptr %b.addr, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp1, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %b_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp1)
  call void @llvm.lifetime.start.p0(i64 4, ptr %r) #11
  store i32 0, ptr %r, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #11
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #11
  call void @llvm.lifetime.start.p0(i64 4, ptr %r2) #11
  store i32 0, ptr %r2, align 4, !tbaa !5
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %4 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !48
  %cmp = icmp ult i64 %4, 32
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %5 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !48
  %mul = mul i64 %5, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !48
  %6 = load <32 x i16>, ptr %a_, align 64, !tbaa !16, !llvm.access.group !48
  %7 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !48
  %vecext = extractelement <32 x i16> %6, i64 %7
  %conv = sext i16 %vecext to i32
  %8 = load <32 x i16>, ptr %b_, align 64, !tbaa !16, !llvm.access.group !48
  %9 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !48
  %vecext3 = extractelement <32 x i16> %8, i64 %9
  %conv4 = sext i16 %vecext3 to i32
  %and = and i32 %conv, %conv4
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %10 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !48
  %sh_prom = trunc i64 %10 to i32
  %shl = shl i32 %lnot.ext, %sh_prom
  %11 = load i32, ptr %r2, align 4, !tbaa !5, !llvm.access.group !48
  %or = or i32 %11, %shl
  store i32 %or, ptr %r2, align 4, !tbaa !5, !llvm.access.group !48
  br label %omp.body.continue

omp.body.continue:                                ; preds = %omp.inner.for.body
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %12 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !48
  %add6 = add i64 %12, 1
  store i64 %add6, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !48
  br label %omp.inner.for.cond, !llvm.loop !49

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 32, ptr %i, align 8, !tbaa !11
  %13 = load i32, ptr %r, align 4, !tbaa !5
  %14 = load i32, ptr %r2, align 4, !tbaa !5
  %or7 = or i32 %13, %14
  store i32 %or7, ptr %r, align 4, !tbaa !5
  call void @llvm.lifetime.end.p0(i64 4, ptr %r2) #11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #11
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #11
  %15 = load i32, ptr %r, align 4, !tbaa !5
  call void @llvm.lifetime.end.p0(i64 4, ptr %r) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %b_) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %a_) #11
  ret i32 %15
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @simde__m512i_to_private(ptr noalias sret(%union.simde__m512i_private) align 64 %agg.result, ptr noundef byval(<8 x i64>) align 64 %0) #6 {
entry:
  %v.addr = alloca <8 x i64>, align 64
  %v = load <8 x i64>, ptr %0, align 64, !tbaa !16
  store <8 x i64> %v, ptr %v.addr, align 64, !tbaa !16
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %agg.result, ptr align 64 %v.addr, i64 64, i1 false)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde_mm512_set_epi32(i32 noundef %e15, i32 noundef %e14, i32 noundef %e13, i32 noundef %e12, i32 noundef %e11, i32 noundef %e10, i32 noundef %e9, i32 noundef %e8, i32 noundef %e7, i32 noundef %e6, i32 noundef %e5, i32 noundef %e4, i32 noundef %e3, i32 noundef %e2, i32 noundef %e1, i32 noundef %e0) #9 {
entry:
  %e15.addr = alloca i32, align 4
  %e14.addr = alloca i32, align 4
  %e13.addr = alloca i32, align 4
  %e12.addr = alloca i32, align 4
  %e11.addr = alloca i32, align 4
  %e10.addr = alloca i32, align 4
  %e9.addr = alloca i32, align 4
  %e8.addr = alloca i32, align 4
  %e7.addr = alloca i32, align 4
  %e6.addr = alloca i32, align 4
  %e5.addr = alloca i32, align 4
  %e4.addr = alloca i32, align 4
  %e3.addr = alloca i32, align 4
  %e2.addr = alloca i32, align 4
  %e1.addr = alloca i32, align 4
  %e0.addr = alloca i32, align 4
  %r_ = alloca %union.simde__m512i_private, align 64
  store i32 %e15, ptr %e15.addr, align 4, !tbaa !5
  store i32 %e14, ptr %e14.addr, align 4, !tbaa !5
  store i32 %e13, ptr %e13.addr, align 4, !tbaa !5
  store i32 %e12, ptr %e12.addr, align 4, !tbaa !5
  store i32 %e11, ptr %e11.addr, align 4, !tbaa !5
  store i32 %e10, ptr %e10.addr, align 4, !tbaa !5
  store i32 %e9, ptr %e9.addr, align 4, !tbaa !5
  store i32 %e8, ptr %e8.addr, align 4, !tbaa !5
  store i32 %e7, ptr %e7.addr, align 4, !tbaa !5
  store i32 %e6, ptr %e6.addr, align 4, !tbaa !5
  store i32 %e5, ptr %e5.addr, align 4, !tbaa !5
  store i32 %e4, ptr %e4.addr, align 4, !tbaa !5
  store i32 %e3, ptr %e3.addr, align 4, !tbaa !5
  store i32 %e2, ptr %e2.addr, align 4, !tbaa !5
  store i32 %e1, ptr %e1.addr, align 4, !tbaa !5
  store i32 %e0, ptr %e0.addr, align 4, !tbaa !5
  call void @llvm.lifetime.start.p0(i64 64, ptr %r_) #11
  %0 = load i32, ptr %e0.addr, align 4, !tbaa !5
  %1 = load <16 x i32>, ptr %r_, align 64
  %vecins = insertelement <16 x i32> %1, i32 %0, i32 0
  store <16 x i32> %vecins, ptr %r_, align 64
  %2 = load i32, ptr %e1.addr, align 4, !tbaa !5
  %3 = load <16 x i32>, ptr %r_, align 64
  %vecins1 = insertelement <16 x i32> %3, i32 %2, i32 1
  store <16 x i32> %vecins1, ptr %r_, align 64
  %4 = load i32, ptr %e2.addr, align 4, !tbaa !5
  %5 = load <16 x i32>, ptr %r_, align 64
  %vecins2 = insertelement <16 x i32> %5, i32 %4, i32 2
  store <16 x i32> %vecins2, ptr %r_, align 64
  %6 = load i32, ptr %e3.addr, align 4, !tbaa !5
  %7 = load <16 x i32>, ptr %r_, align 64
  %vecins3 = insertelement <16 x i32> %7, i32 %6, i32 3
  store <16 x i32> %vecins3, ptr %r_, align 64
  %8 = load i32, ptr %e4.addr, align 4, !tbaa !5
  %9 = load <16 x i32>, ptr %r_, align 64
  %vecins4 = insertelement <16 x i32> %9, i32 %8, i32 4
  store <16 x i32> %vecins4, ptr %r_, align 64
  %10 = load i32, ptr %e5.addr, align 4, !tbaa !5
  %11 = load <16 x i32>, ptr %r_, align 64
  %vecins5 = insertelement <16 x i32> %11, i32 %10, i32 5
  store <16 x i32> %vecins5, ptr %r_, align 64
  %12 = load i32, ptr %e6.addr, align 4, !tbaa !5
  %13 = load <16 x i32>, ptr %r_, align 64
  %vecins6 = insertelement <16 x i32> %13, i32 %12, i32 6
  store <16 x i32> %vecins6, ptr %r_, align 64
  %14 = load i32, ptr %e7.addr, align 4, !tbaa !5
  %15 = load <16 x i32>, ptr %r_, align 64
  %vecins7 = insertelement <16 x i32> %15, i32 %14, i32 7
  store <16 x i32> %vecins7, ptr %r_, align 64
  %16 = load i32, ptr %e8.addr, align 4, !tbaa !5
  %17 = load <16 x i32>, ptr %r_, align 64
  %vecins8 = insertelement <16 x i32> %17, i32 %16, i32 8
  store <16 x i32> %vecins8, ptr %r_, align 64
  %18 = load i32, ptr %e9.addr, align 4, !tbaa !5
  %19 = load <16 x i32>, ptr %r_, align 64
  %vecins9 = insertelement <16 x i32> %19, i32 %18, i32 9
  store <16 x i32> %vecins9, ptr %r_, align 64
  %20 = load i32, ptr %e10.addr, align 4, !tbaa !5
  %21 = load <16 x i32>, ptr %r_, align 64
  %vecins10 = insertelement <16 x i32> %21, i32 %20, i32 10
  store <16 x i32> %vecins10, ptr %r_, align 64
  %22 = load i32, ptr %e11.addr, align 4, !tbaa !5
  %23 = load <16 x i32>, ptr %r_, align 64
  %vecins11 = insertelement <16 x i32> %23, i32 %22, i32 11
  store <16 x i32> %vecins11, ptr %r_, align 64
  %24 = load i32, ptr %e12.addr, align 4, !tbaa !5
  %25 = load <16 x i32>, ptr %r_, align 64
  %vecins12 = insertelement <16 x i32> %25, i32 %24, i32 12
  store <16 x i32> %vecins12, ptr %r_, align 64
  %26 = load i32, ptr %e13.addr, align 4, !tbaa !5
  %27 = load <16 x i32>, ptr %r_, align 64
  %vecins13 = insertelement <16 x i32> %27, i32 %26, i32 13
  store <16 x i32> %vecins13, ptr %r_, align 64
  %28 = load i32, ptr %e14.addr, align 4, !tbaa !5
  %29 = load <16 x i32>, ptr %r_, align 64
  %vecins14 = insertelement <16 x i32> %29, i32 %28, i32 14
  store <16 x i32> %vecins14, ptr %r_, align 64
  %30 = load i32, ptr %e15.addr, align 4, !tbaa !5
  %31 = load <16 x i32>, ptr %r_, align 64
  %vecins15 = insertelement <16 x i32> %31, i32 %30, i32 15
  store <16 x i32> %vecins15, ptr %r_, align 64
  %call = call <8 x i64> @simde__m512i_from_private(ptr noundef byval(%union.simde__m512i_private) align 64 %r_)
  call void @llvm.lifetime.end.p0(i64 64, ptr %r_) #11
  ret <8 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i16 @simde_mm512_mask_test_epi32_mask(i16 noundef zeroext %k1, ptr noundef byval(<8 x i64>) align 64 %0, ptr noundef byval(<8 x i64>) align 64 %1) #6 {
entry:
  %k1.addr = alloca i16, align 2
  %a.addr = alloca <8 x i64>, align 64
  %b.addr = alloca <8 x i64>, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp1 = alloca <8 x i64>, align 64
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %b = load <8 x i64>, ptr %1, align 64, !tbaa !16
  store i16 %k1, ptr %k1.addr, align 2, !tbaa !17
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %b, ptr %b.addr, align 64, !tbaa !16
  %2 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  %3 = load <8 x i64>, ptr %b.addr, align 64, !tbaa !16
  store <8 x i64> %2, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp1, align 64, !tbaa !16
  %call = call zeroext i16 @simde_mm512_test_epi32_mask(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp1)
  %conv = zext i16 %call to i32
  %4 = load i16, ptr %k1.addr, align 2, !tbaa !17
  %conv2 = zext i16 %4 to i32
  %and = and i32 %conv, %conv2
  %conv3 = trunc i32 %and to i16
  ret i16 %conv3
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde__m512i_from_private(ptr noundef byval(%union.simde__m512i_private) align 64 %v) #9 {
entry:
  %r = alloca <8 x i64>, align 64
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #11
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %r, ptr align 64 %v, i64 64, i1 false)
  %0 = load <8 x i64>, ptr %r, align 64, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #11
  ret <8 x i64> %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i16 @simde_mm512_test_epi32_mask(ptr noundef byval(<8 x i64>) align 64 %0, ptr noundef byval(<8 x i64>) align 64 %1) #6 {
entry:
  %a.addr = alloca <8 x i64>, align 64
  %b.addr = alloca <8 x i64>, align 64
  %a_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %b_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp1 = alloca <8 x i64>, align 64
  %r = alloca i16, align 2
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  %r2 = alloca i16, align 2
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %b = load <8 x i64>, ptr %1, align 64, !tbaa !16
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %b, ptr %b.addr, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %a_) #11
  %2 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %2, ptr %indirect-arg-temp, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %a_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 64, ptr %b_) #11
  %3 = load <8 x i64>, ptr %b.addr, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp1, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %b_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp1)
  call void @llvm.lifetime.start.p0(i64 2, ptr %r) #11
  store i16 0, ptr %r, align 2, !tbaa !17
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #11
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #11
  call void @llvm.lifetime.start.p0(i64 2, ptr %r2) #11
  store i16 0, ptr %r2, align 2, !tbaa !17
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %4 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !51
  %cmp = icmp ult i64 %4, 16
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %5 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !51
  %mul = mul i64 %5, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !51
  %6 = load <16 x i32>, ptr %a_, align 64, !tbaa !16, !llvm.access.group !51
  %7 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !51
  %vecext = extractelement <16 x i32> %6, i64 %7
  %8 = load <16 x i32>, ptr %b_, align 64, !tbaa !16, !llvm.access.group !51
  %9 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !51
  %vecext3 = extractelement <16 x i32> %8, i64 %9
  %and = and i32 %vecext, %vecext3
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %10 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !51
  %sh_prom = trunc i64 %10 to i32
  %shl = shl i32 %lnot.ext, %sh_prom
  %conv = trunc i32 %shl to i16
  %conv5 = zext i16 %conv to i32
  %11 = load i16, ptr %r2, align 2, !tbaa !17, !llvm.access.group !51
  %conv6 = zext i16 %11 to i32
  %or = or i32 %conv6, %conv5
  %conv7 = trunc i32 %or to i16
  store i16 %conv7, ptr %r2, align 2, !tbaa !17, !llvm.access.group !51
  br label %omp.body.continue

omp.body.continue:                                ; preds = %omp.inner.for.body
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %12 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !51
  %add8 = add i64 %12, 1
  store i64 %add8, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !51
  br label %omp.inner.for.cond, !llvm.loop !52

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 16, ptr %i, align 8, !tbaa !11
  %13 = load i16, ptr %r, align 2, !tbaa !17
  %conv9 = zext i16 %13 to i32
  %14 = load i16, ptr %r2, align 2, !tbaa !17
  %conv10 = zext i16 %14 to i32
  %or11 = or i32 %conv9, %conv10
  %conv12 = trunc i32 %or11 to i16
  store i16 %conv12, ptr %r, align 2, !tbaa !17
  call void @llvm.lifetime.end.p0(i64 2, ptr %r2) #11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #11
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #11
  %15 = load i16, ptr %r, align 2, !tbaa !17
  call void @llvm.lifetime.end.p0(i64 2, ptr %r) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %b_) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %a_) #11
  ret i16 %15
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde_mm512_set_epi64(i64 noundef %e7, i64 noundef %e6, i64 noundef %e5, i64 noundef %e4, i64 noundef %e3, i64 noundef %e2, i64 noundef %e1, i64 noundef %e0) #9 {
entry:
  %e7.addr = alloca i64, align 8
  %e6.addr = alloca i64, align 8
  %e5.addr = alloca i64, align 8
  %e4.addr = alloca i64, align 8
  %e3.addr = alloca i64, align 8
  %e2.addr = alloca i64, align 8
  %e1.addr = alloca i64, align 8
  %e0.addr = alloca i64, align 8
  %r_ = alloca %union.simde__m512i_private, align 64
  store i64 %e7, ptr %e7.addr, align 8, !tbaa !11
  store i64 %e6, ptr %e6.addr, align 8, !tbaa !11
  store i64 %e5, ptr %e5.addr, align 8, !tbaa !11
  store i64 %e4, ptr %e4.addr, align 8, !tbaa !11
  store i64 %e3, ptr %e3.addr, align 8, !tbaa !11
  store i64 %e2, ptr %e2.addr, align 8, !tbaa !11
  store i64 %e1, ptr %e1.addr, align 8, !tbaa !11
  store i64 %e0, ptr %e0.addr, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 64, ptr %r_) #11
  %0 = load i64, ptr %e0.addr, align 8, !tbaa !11
  %1 = load <8 x i64>, ptr %r_, align 64
  %vecins = insertelement <8 x i64> %1, i64 %0, i32 0
  store <8 x i64> %vecins, ptr %r_, align 64
  %2 = load i64, ptr %e1.addr, align 8, !tbaa !11
  %3 = load <8 x i64>, ptr %r_, align 64
  %vecins1 = insertelement <8 x i64> %3, i64 %2, i32 1
  store <8 x i64> %vecins1, ptr %r_, align 64
  %4 = load i64, ptr %e2.addr, align 8, !tbaa !11
  %5 = load <8 x i64>, ptr %r_, align 64
  %vecins2 = insertelement <8 x i64> %5, i64 %4, i32 2
  store <8 x i64> %vecins2, ptr %r_, align 64
  %6 = load i64, ptr %e3.addr, align 8, !tbaa !11
  %7 = load <8 x i64>, ptr %r_, align 64
  %vecins3 = insertelement <8 x i64> %7, i64 %6, i32 3
  store <8 x i64> %vecins3, ptr %r_, align 64
  %8 = load i64, ptr %e4.addr, align 8, !tbaa !11
  %9 = load <8 x i64>, ptr %r_, align 64
  %vecins4 = insertelement <8 x i64> %9, i64 %8, i32 4
  store <8 x i64> %vecins4, ptr %r_, align 64
  %10 = load i64, ptr %e5.addr, align 8, !tbaa !11
  %11 = load <8 x i64>, ptr %r_, align 64
  %vecins5 = insertelement <8 x i64> %11, i64 %10, i32 5
  store <8 x i64> %vecins5, ptr %r_, align 64
  %12 = load i64, ptr %e6.addr, align 8, !tbaa !11
  %13 = load <8 x i64>, ptr %r_, align 64
  %vecins6 = insertelement <8 x i64> %13, i64 %12, i32 6
  store <8 x i64> %vecins6, ptr %r_, align 64
  %14 = load i64, ptr %e7.addr, align 8, !tbaa !11
  %15 = load <8 x i64>, ptr %r_, align 64
  %vecins7 = insertelement <8 x i64> %15, i64 %14, i32 7
  store <8 x i64> %vecins7, ptr %r_, align 64
  %call = call <8 x i64> @simde__m512i_from_private(ptr noundef byval(%union.simde__m512i_private) align 64 %r_)
  call void @llvm.lifetime.end.p0(i64 64, ptr %r_) #11
  ret <8 x i64> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i8 @simde_mm512_mask_test_epi64_mask(i8 noundef zeroext %k1, ptr noundef byval(<8 x i64>) align 64 %0, ptr noundef byval(<8 x i64>) align 64 %1) #6 {
entry:
  %k1.addr = alloca i8, align 1
  %a.addr = alloca <8 x i64>, align 64
  %b.addr = alloca <8 x i64>, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp1 = alloca <8 x i64>, align 64
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %b = load <8 x i64>, ptr %1, align 64, !tbaa !16
  store i8 %k1, ptr %k1.addr, align 1, !tbaa !16
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %b, ptr %b.addr, align 64, !tbaa !16
  %2 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  %3 = load <8 x i64>, ptr %b.addr, align 64, !tbaa !16
  store <8 x i64> %2, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp1, align 64, !tbaa !16
  %call = call zeroext i8 @simde_mm512_test_epi64_mask(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp1)
  %conv = zext i8 %call to i32
  %4 = load i8, ptr %k1.addr, align 1, !tbaa !16
  %conv2 = zext i8 %4 to i32
  %and = and i32 %conv, %conv2
  %conv3 = trunc i32 %and to i8
  ret i8 %conv3
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_u8_(i8 noundef zeroext %a, i8 noundef zeroext %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8, align 1
  %b.addr = alloca i8, align 1
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  store i8 %a, ptr %a.addr, align 1, !tbaa !16
  store i8 %b, ptr %b.addr, align 1, !tbaa !16
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i8, ptr %a.addr, align 1, !tbaa !16
  %conv = zext i8 %0 to i32
  %1 = load i8, ptr %b.addr, align 1, !tbaa !16
  %conv1 = zext i8 %1 to i32
  %cmp = icmp ne i32 %conv, %conv1
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %3 = load i32, ptr %line.addr, align 4, !tbaa !5
  %4 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %5 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %6 = load i8, ptr %a.addr, align 1, !tbaa !16
  %conv5 = zext i8 %6 to i32
  %7 = load i8, ptr %b.addr, align 1, !tbaa !16
  %conv6 = zext i8 %7 to i32
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.16, ptr noundef %2, i32 noundef %3, ptr noundef %4, ptr noundef %5, i32 noundef %conv5, i32 noundef %conv6)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i8 @simde_mm512_test_epi64_mask(ptr noundef byval(<8 x i64>) align 64 %0, ptr noundef byval(<8 x i64>) align 64 %1) #6 {
entry:
  %a.addr = alloca <8 x i64>, align 64
  %b.addr = alloca <8 x i64>, align 64
  %a_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %b_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp1 = alloca <8 x i64>, align 64
  %r = alloca i8, align 1
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  %r2 = alloca i8, align 1
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %b = load <8 x i64>, ptr %1, align 64, !tbaa !16
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %b, ptr %b.addr, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %a_) #11
  %2 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %2, ptr %indirect-arg-temp, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %a_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 64, ptr %b_) #11
  %3 = load <8 x i64>, ptr %b.addr, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp1, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %b_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp1)
  call void @llvm.lifetime.start.p0(i64 1, ptr %r) #11
  store i8 0, ptr %r, align 1, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #11
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #11
  call void @llvm.lifetime.start.p0(i64 1, ptr %r2) #11
  store i8 0, ptr %r2, align 1, !tbaa !16
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %4 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !54
  %cmp = icmp ult i64 %4, 8
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %5 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !54
  %mul = mul i64 %5, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !54
  %6 = load <8 x i64>, ptr %a_, align 64, !tbaa !16, !llvm.access.group !54
  %7 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !54
  %vecext = extractelement <8 x i64> %6, i64 %7
  %8 = load <8 x i64>, ptr %b_, align 64, !tbaa !16, !llvm.access.group !54
  %9 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !54
  %vecext3 = extractelement <8 x i64> %8, i64 %9
  %and = and i64 %vecext, %vecext3
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %10 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !54
  %sh_prom = trunc i64 %10 to i32
  %shl = shl i32 %lnot.ext, %sh_prom
  %conv = trunc i32 %shl to i8
  %conv5 = zext i8 %conv to i32
  %11 = load i8, ptr %r2, align 1, !tbaa !16, !llvm.access.group !54
  %conv6 = zext i8 %11 to i32
  %or = or i32 %conv6, %conv5
  %conv7 = trunc i32 %or to i8
  store i8 %conv7, ptr %r2, align 1, !tbaa !16, !llvm.access.group !54
  br label %omp.body.continue

omp.body.continue:                                ; preds = %omp.inner.for.body
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %12 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !54
  %add8 = add i64 %12, 1
  store i64 %add8, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !54
  br label %omp.inner.for.cond, !llvm.loop !55

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 8, ptr %i, align 8, !tbaa !11
  %13 = load i8, ptr %r, align 1, !tbaa !16
  %conv9 = zext i8 %13 to i32
  %14 = load i8, ptr %r2, align 1, !tbaa !16
  %conv10 = zext i8 %14 to i32
  %or11 = or i32 %conv9, %conv10
  %conv12 = trunc i32 %or11 to i8
  store i8 %conv12, ptr %r, align 1, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 1, ptr %r2) #11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #11
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #11
  %15 = load i8, ptr %r, align 1, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 1, ptr %r) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %b_) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %a_) #11
  ret i8 %15
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i64 @simde_mm512_mask_test_epi8_mask(i64 noundef %k1, ptr noundef byval(<8 x i64>) align 64 %0, ptr noundef byval(<8 x i64>) align 64 %1) #6 {
entry:
  %k1.addr = alloca i64, align 8
  %a.addr = alloca <8 x i64>, align 64
  %b.addr = alloca <8 x i64>, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %indirect-arg-temp1 = alloca <8 x i64>, align 64
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %b = load <8 x i64>, ptr %1, align 64, !tbaa !16
  store i64 %k1, ptr %k1.addr, align 8, !tbaa !11
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %b, ptr %b.addr, align 64, !tbaa !16
  %2 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  %3 = load <8 x i64>, ptr %b.addr, align 64, !tbaa !16
  store <8 x i64> %2, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp1, align 64, !tbaa !16
  %call = call i64 @simde_mm512_test_epi8_mask(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp1)
  %4 = load i64, ptr %k1.addr, align 8, !tbaa !11
  %and = and i64 %call, %4
  ret i64 %and
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_u64_(i64 noundef %a, i64 noundef %b, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8, !tbaa !11
  store i64 %b, ptr %b.addr, align 8, !tbaa !11
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i64, ptr %a.addr, align 8, !tbaa !11
  %1 = load i64, ptr %b.addr, align 8, !tbaa !11
  %cmp = icmp ne i64 %0, %1
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %3 = load i32, ptr %line.addr, align 4, !tbaa !5
  %4 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %5 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %6 = load i64, ptr %a.addr, align 8, !tbaa !11
  %7 = load i64, ptr %b.addr, align 8, !tbaa !11
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.18, ptr noundef %2, i32 noundef %3, ptr noundef %4, ptr noundef %5, i64 noundef %6, i64 noundef %7)
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i64 @simde_mm512_test_epi8_mask(ptr noundef byval(<8 x i64>) align 64 %0, ptr noundef byval(<8 x i64>) align 64 %1) #6 {
entry:
  %a.addr = alloca <8 x i64>, align 64
  %b.addr = alloca <8 x i64>, align 64
  %a_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %b_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp1 = alloca <8 x i64>, align 64
  %r = alloca i64, align 8
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  %r2 = alloca i64, align 8
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %b = load <8 x i64>, ptr %1, align 64, !tbaa !16
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %b, ptr %b.addr, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %a_) #11
  %2 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %2, ptr %indirect-arg-temp, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %a_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 64, ptr %b_) #11
  %3 = load <8 x i64>, ptr %b.addr, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp1, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %b_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp1)
  call void @llvm.lifetime.start.p0(i64 8, ptr %r) #11
  store i64 0, ptr %r, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #11
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #11
  call void @llvm.lifetime.start.p0(i64 8, ptr %r2) #11
  store i64 0, ptr %r2, align 8, !tbaa !11
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %4 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !57
  %cmp = icmp ult i64 %4, 64
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %5 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !57
  %mul = mul i64 %5, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !57
  %6 = load <64 x i8>, ptr %a_, align 64, !tbaa !16, !llvm.access.group !57
  %7 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !57
  %vecext = extractelement <64 x i8> %6, i64 %7
  %conv = sext i8 %vecext to i32
  %8 = load <64 x i8>, ptr %b_, align 64, !tbaa !16, !llvm.access.group !57
  %9 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !57
  %vecext3 = extractelement <64 x i8> %8, i64 %9
  %conv4 = sext i8 %vecext3 to i32
  %and = and i32 %conv, %conv4
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %10 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !57
  %shl = shl i64 %conv6, %10
  %11 = load i64, ptr %r2, align 8, !tbaa !11, !llvm.access.group !57
  %or = or i64 %11, %shl
  store i64 %or, ptr %r2, align 8, !tbaa !11, !llvm.access.group !57
  br label %omp.body.continue

omp.body.continue:                                ; preds = %omp.inner.for.body
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %12 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !57
  %add7 = add i64 %12, 1
  store i64 %add7, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !57
  br label %omp.inner.for.cond, !llvm.loop !58

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 64, ptr %i, align 8, !tbaa !11
  %13 = load i64, ptr %r, align 8, !tbaa !11
  %14 = load i64, ptr %r2, align 8, !tbaa !11
  %or8 = or i64 %13, %14
  store i64 %or8, ptr %r, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %r2) #11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #11
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #11
  %15 = load i64, ptr %r, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %r) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %b_) #11
  call void @llvm.lifetime.end.p0(i64 64, ptr %a_) #11
  ret i64 %15
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_start.p0(ptr) #10

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_end.p0(ptr) #10

attributes #0 = { nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind uwtable "min-legal-vector-width"="256" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { nounwind uwtable "min-legal-vector-width"="512" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { alwaysinline nounwind uwtable "min-legal-vector-width"="256" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { alwaysinline nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #8 = { nocallback nofree nosync nounwind willreturn memory(none) }
attributes #9 = { alwaysinline nounwind uwtable "min-legal-vector-width"="512" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { nocallback nofree nosync nounwind willreturn }
attributes #11 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"clang version 18.0.0 (https://github.com/llvm-ml/llvm-project b452eb491a2ae09c12cc88b715f003377cec543b)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = !{!10, !10, i64 0}
!10 = !{!"any pointer", !7, i64 0}
!11 = !{!12, !12, i64 0}
!12 = !{!"long", !7, i64 0}
!13 = !{!14, !10, i64 0}
!14 = !{!"", !10, i64 0, !10, i64 8}
!15 = !{!14, !10, i64 8}
!16 = !{!7, !7, i64 0}
!17 = !{!18, !18, i64 0}
!18 = !{!"short", !7, i64 0}
!19 = !{!20, !18, i64 64}
!20 = !{!"", !7, i64 0, !7, i64 32, !18, i64 64}
!21 = !{!22, !7, i64 0}
!22 = !{!"", !7, i64 0, !7, i64 4, !7, i64 36, !7, i64 68}
!23 = !{!22, !7, i64 68}
!24 = !{!25, !6, i64 0}
!25 = !{!"", !6, i64 0, !7, i64 4, !7, i64 68, !6, i64 132}
!26 = !{!25, !6, i64 132}
!27 = !{!28, !18, i64 0}
!28 = !{!"", !18, i64 0, !7, i64 64, !7, i64 128, !18, i64 192}
!29 = !{!28, !18, i64 192}
!30 = !{!31, !7, i64 0}
!31 = !{!"", !7, i64 0, !7, i64 64, !7, i64 128, !7, i64 192}
!32 = !{!31, !7, i64 192}
!33 = !{!34, !12, i64 0}
!34 = !{!"", !12, i64 0, !7, i64 8, !7, i64 72, !12, i64 136}
!35 = !{!34, !12, i64 136}
!36 = !{!37, !6, i64 128}
!37 = !{!"", !7, i64 0, !7, i64 64, !6, i64 128}
!38 = !{!39, !18, i64 128}
!39 = !{!"", !7, i64 0, !7, i64 64, !18, i64 128}
!40 = !{!41, !7, i64 128}
!41 = !{!"", !7, i64 0, !7, i64 64, !7, i64 128}
!42 = !{!43, !12, i64 128}
!43 = !{!"", !7, i64 0, !7, i64 64, !12, i64 128}
!44 = distinct !{}
!45 = distinct !{!45, !46, !47}
!46 = !{!"llvm.loop.parallel_accesses", !44}
!47 = !{!"llvm.loop.vectorize.enable", i1 true}
!48 = distinct !{}
!49 = distinct !{!49, !50, !47}
!50 = !{!"llvm.loop.parallel_accesses", !48}
!51 = distinct !{}
!52 = distinct !{!52, !53, !47}
!53 = !{!"llvm.loop.parallel_accesses", !51}
!54 = distinct !{}
!55 = distinct !{!55, !56, !47}
!56 = !{!"llvm.loop.parallel_accesses", !54}
!57 = distinct !{}
!58 = distinct !{!58, !59, !47}
!59 = !{!"llvm.loop.parallel_accesses", !57}
