; ModuleID = 'samples/935.bc'
source_filename = "../spack-src/test/x86/avx512/fmadd.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.anon = type { ptr, ptr }
%struct.anon.0 = type { [16 x float], [16 x float], [16 x float], [16 x float] }
%struct.anon.1 = type { [16 x float], i8, [16 x float], [16 x float], [16 x float] }
%struct.anon.2 = type { i16, [16 x float], [16 x float], [16 x float], [16 x float] }
%struct.anon.3 = type { [8 x double], [8 x double], [8 x double], [8 x double] }
%union.simde__m512_private = type { <64 x i8> }
%union.simde__m256_private = type { <32 x i8> }
%union.simde__m128_private = type { <16 x i8> }
%struct.__va_list_tag = type { i32, i32, ptr, ptr }
%union.simde__m512i_private = type { <64 x i8> }
%union.simde__m256i_private = type { <32 x i8> }
%union.simde__m128i_private = type { <16 x i8> }
%union.simde__m512d_private = type { <64 x i8> }
%union.simde__m256d_private = type { <32 x i8> }

@stdout = external global ptr, align 8
@.str = private unnamed_addr constant [8 x i8] c"1..%zu\0A\00", align 1
@test_suite_tests = internal constant [4 x %struct.anon] [%struct.anon { ptr @test_simde_mm512_fmadd_ps, ptr @.str.3 }, %struct.anon { ptr @test_simde_mm512_mask_fmadd_ps, ptr @.str.4 }, %struct.anon { ptr @test_simde_mm512_maskz_fmadd_ps, ptr @.str.5 }, %struct.anon { ptr @test_simde_mm512_fmadd_pd, ptr @.str.6 }], align 16
@.str.1 = private unnamed_addr constant [21 x i8] c"not ok %zu fmadd/%s\0A\00", align 1
@.str.2 = private unnamed_addr constant [17 x i8] c"ok %zu fmadd/%s\0A\00", align 1
@.str.3 = private unnamed_addr constant [15 x i8] c"mm512_fmadd_ps\00", align 1
@.str.4 = private unnamed_addr constant [20 x i8] c"mm512_mask_fmadd_ps\00", align 1
@.str.5 = private unnamed_addr constant [21 x i8] c"mm512_maskz_fmadd_ps\00", align 1
@.str.6 = private unnamed_addr constant [15 x i8] c"mm512_fmadd_pd\00", align 1
@test_simde_mm512_fmadd_ps.test_vec = internal constant [8 x %struct.anon.0] [%struct.anon.0 { [16 x float] [float 0x4055BA3D80000000, float 0xC055ACCCC0000000, float 0xC058E5C280000000, float 0xC05823D700000000, float 0x403A6B8520000000, float 0xC04D3D70A0000000, float 0x4055DF5C20000000, float 0xC0451EB860000000, float 0xC03D0CCCC0000000, float 0xC056A28F60000000, float 0xC00947AE20000000, float 0xBFE051EB80000000, float 0xC055466660000000, float 0x4036DC2900000000, float 0xC03D3AE140000000, float 0x40512851E0000000], [16 x float] [float 0xC021BD70A0000000, float 0x40432E1480000000, float 0xC044EB8520000000, float -4.250000e+01, float 0xC0444A3D80000000, float 0xC03F4F5C20000000, float 0x401BEB8520000000, float 0x4054F3D700000000, float 0xC02123D700000000, float 0xC02EAE1480000000, float 0xC037C7AE20000000, float 0xC0537CCCC0000000, float 0xC047947AE0000000, float 0x4053D47AE0000000, float 0x4040F5C280000000, float -6.025000e+01], [16 x float] [float 9.262500e+02, float 0x40757547A0000000, float 0xC081C0F5C0000000, float 0x4067CD70A0000000, float 0x4087B3D700000000, float 0xC085AA1480000000, float 0x4088007AE0000000, float 0xC080A03D80000000, float 0xC082B570A0000000, float 0xC070787AE0000000, float 0x407CEDEB80000000, float 0xC07C1A3D80000000, float 0x408E28CCC0000000, float 0xC089EB70A0000000, float 0xC087DAB860000000, float 0xC05EE7AE20000000], [16 x float] [float 0x40636B8520000000, float 0xC0A74CF5C0000000, float 0x40AC1D75C0000000, float 0x40B0C63860000000, float 0xC0739A3D80000000, float 1.137750e+03, float 0x40958AF5C0000000, float 0xC0AFD051E0000000, float 0xC075DB8520000000, float 0x4091956660000000, float 0x4080D01480000000, float 0xC0799E3D80000000, float 0x40B3726B80000000, float 0x408EBEA3E0000000, float 0xC09B6B47A0000000, float 0xC0B0A29480000000] }, %struct.anon.0 { [16 x float] [float 0x404BB5C280000000, float 0xC0322B8520000000, float 0x404691EB80000000, float 0xC0554A3D80000000, float 0x4049428F60000000, float 0xC047F0A3E0000000, float 0x4058A999A0000000, float 0xC04D066660000000, float 0x404263D700000000, float 0xC0392147A0000000, float 0xC0420147A0000000, float 0x40566851E0000000, float 0xC046E7AE20000000, float 0x40587A3D80000000, float 0xC051A7AE20000000, float 0xC04A970A40000000], [16 x float] [float 0x40401EB860000000, float 0xC03B70A3E0000000, float 0x4050770A40000000, float 0x40202E1480000000, float 0x4009EB8520000000, float 0x4045547AE0000000, float 0x404B71EB80000000, float 0x4045AF5C20000000, float 0xC054EC2900000000, float 0x3FF2B851E0000000, float 0x40589A3D80000000, float 0xC055CB8520000000, float 0x40323AE140000000, float 0xC0537B8520000000, float 0x3FDD70A3E0000000, float 0xC03A5999A0000000], [16 x float] [float 0x40438147A0000000, float 0xC081003D80000000, float 0xC05CC851E0000000, float 0xC07C7D1EC0000000, float 0xC036D70A40000000, float 0xC060147AE0000000, float 0xC0422E1480000000, float 0xC084781480000000, float 0x4083606660000000, float 0x4082DC6660000000, float 0xC087B61480000000, float 0xC08A3051E0000000, float 0x40823547A0000000, float 0xC07D0FAE20000000, float 0xC0771E1480000000, float 0xC057BA3D80000000], [16 x float] [float 1.825750e+03, float 0xC046B999A0000000, float 0x40A6539480000000, float 0xC091E30A40000000, float 0x40619AE140000000, float 0xC0A0F66660000000, float 0x40B5028A40000000, float 0xC0A8C947A0000000, float 0xC0A33423E0000000, float 0x4081F13340000000, float -4.302500e+03, float 0xC0C0E5FD80000000, float 0xC06F8EB860000000, float 0xC0BF9F1C20000000, float 0xC07925EB80000000, float 0x4094698520000000] }, %struct.anon.0 { [16 x float] [float 0x403A11EB80000000, float 0xC051C851E0000000, float 0x4058A66660000000, float 0xC051ACCCC0000000, float 0x4051E1EB80000000, float 0x404ABEB860000000, float 0x40522B8520000000, float 0x4055F5C280000000, float 0xC046AB8520000000, float 0x4051C51EC0000000, float 0xC058D51EC0000000, float 0x405238F5C0000000, float 0x40574999A0000000, float 0x3FF1EB8520000000, float 0xC04ABAE140000000, float 0xC0079999A0000000], [16 x float] [float 0x40475C2900000000, float 0x404183D700000000, float 0x4049BC2900000000, float 0xC04BC7AE20000000, float 0xC053751EC0000000, float 0xC04A147AE0000000, float 0xC0350F5C20000000, float 0x40550AE140000000, float 0xC056F3D700000000, float 0x40087AE140000000, float 0xC058E851E0000000, float 0x40509D70A0000000, float 0x404C47AE20000000, float 0xC0424F5C20000000, float 0xC04583D700000000, float 0xC0315EB860000000], [16 x float] [float 0xC0536147A0000000, float 0xC07BC547A0000000, float 0x405DD5C280000000, float 0xC076A2E140000000, float 0xC08C6B99A0000000, float 0xC0633D1EC0000000, float 0xC07E3BAE20000000, float 0xC076AD47A0000000, float 0xC07BB199A0000000, float 0xC07DD11EC0000000, float 0xC083CF0A40000000, float 0xC07FF8F5C0000000, float 0x4080B15C20000000, float 0xC0650EB860000000, float 0x407CAFD700000000, float 0x3FF63D70A0000000], [16 x float] [float 0x4091D1E140000000, float 0xC0A6F00520000000, float 0x40B44A47A0000000, float 0x40ABDBD1E0000000, float 0xC0B94CA140000000, float 0xC0A6FFE660000000, float 0xC09F797AE0000000, float 0x40BB76A900000000, float 0x40AD0F23E0000000, float 0xC070391EC0000000, float 0x40C2172F60000000, float 0x40B0ECB5C0000000, float 0x40B6AABAE0000000, float 0xC06A2F0A40000000, float 0x40A58EBD80000000, float 0x404A50A3E0000000] }, %struct.anon.0 { [16 x float] [float 0xC054747AE0000000, float 0xC0050A3D80000000, float 0x40464A3D80000000, float 0xC04DD33340000000, float 0x40469AE140000000, float 0xC0531F5C20000000, float 0xC052DEB860000000, float 0x404AB33340000000, float 0x403A91EB80000000, float 0xC052C70A40000000, float 0x4033DC2900000000, float 0xC030DC2900000000, float 0xC02775C280000000, float 0x4053351EC0000000, float 0x40507147A0000000, float 0x405420A3E0000000], [16 x float] [float 0xC050E70A40000000, float 0xC0364CCCC0000000, float 0xC04BD999A0000000, float 0xC04D466660000000, float 0x404F27AE20000000, float 0xC01051EB80000000, float 0x4014AE1480000000, float -8.200000e+01, float 0x40481C2900000000, float 0x4044E3D700000000, float 0xC040947AE0000000, float 0x3FFA147AE0000000, float 0xC052C47AE0000000, float 0xC055D0A3E0000000, float 0xC0588EB860000000, float 0xC04C70A3E0000000], [16 x float] [float 0x405948F5C0000000, float 0x407CF7D700000000, float 0xC064AB8520000000, float 0xC07BEC51E0000000, float 0x4085D4F5C0000000, float 0x4053F5C280000000, float -9.127500e+02, float 0xC041D0A3E0000000, float 0x40748B3340000000, float 0x4071DDC280000000, float 0x4088DDD700000000, float 0xC088A51EC0000000, float 0x404B10A3E0000000, float 0x407C563D80000000, float 0xC08EBC1480000000, float 0x4077A147A0000000], [16 x float] [float 0x40B600FD80000000, float 0x4080511EC0000000, float 0xC0A4B0F0A0000000, float 0x40A7CB7AE0000000, float 0x40AB7751E0000000, float 0x40787EB860000000, float 0xC0945BEB80000000, float 0xC0B13E6E20000000, float 0x409927A3E0000000, float 0xC0A6487AE0000000, float 0x40612570A0000000, float 0xC08980F5C0000000, float 0x408D3599A0000000, float 0xC0B86ACCC0000000, float 0xC0BD1419A0000000, float 0xC0B0695480000000] }, %struct.anon.0 { [16 x float] [float 0xC0533D70A0000000, float 0xC04B07AE20000000, float 0x4053D0A3E0000000, float 0x4055566660000000, float 0x4044EF5C20000000, float 0xC02F28F5C0000000, float 0xC0582A3D80000000, float 0xC023D70A40000000, float 0xC052733340000000, float 0xC03DCF5C20000000, float 0x4056EE1480000000, float 0xC0486F5C20000000, float 0xC03111EB80000000, float 0x40575F5C20000000, float -5.750000e+00, float 0x4057428F60000000], [16 x float] [float 0x4043EB8520000000, float 0x40536D70A0000000, float 0xC049D0A3E0000000, float 0x4023666660000000, float 0xC02C9999A0000000, float 0xC045747AE0000000, float 0xC05777AE20000000, float 0xC0545B8520000000, float 0x40556B8520000000, float 0x40556D70A0000000, float 0xC04E266660000000, float 0xC021D1EB80000000, float 0x403F0CCCC0000000, float 0xC04D533340000000, float 0xC051C66660000000, float 0x404B0A3D80000000], [16 x float] [float 0xC05FC147A0000000, float 0xC08CB38520000000, float 0x4078A4CCC0000000, float 0xC08622B860000000, float 0xC0528CCCC0000000, float 4.277500e+02, float 0x40680FAE20000000, float 0x40677A3D80000000, float 0xC08B330A40000000, float 0x405B68F5C0000000, float 0x4085D947A0000000, float 0xC0448B8520000000, float 0x40464147A0000000, float 0xC0766547A0000000, float 0xC05BAA3D80000000, float 0xC081690A40000000], [16 x float] [float 0xC0A8F23860000000, float 0xC0B3FF70A0000000, float 0xC0ACE3C7A0000000, float 0x405DE33340000000, float 0xC085078520000000, float 0x4091212900000000, float 0x40C218FAE0000000, float 0x408F1CE140000000, float 0xC0BC198F60000000, float 0xC0A31AC280000000, float 0xC0B2DF8F60000000, float 0x4078A570A0000000, float 0xC07E582900000000, float 0xC0B6D18520000000, float 0x4072A28F60000000, float 0x40B17A7860000000] }, %struct.anon.0 { [16 x float] [float 0xC04D0F5C20000000, float 0x4042A66660000000, float 0x404AFD70A0000000, float 0x403B947AE0000000, float 0x405798F5C0000000, float 0x404E0F5C20000000, float 0x4047133340000000, float 0x4054047AE0000000, float 0x4046EA3D80000000, float 0x4055766660000000, float 0xC03CD70A40000000, float 0xC0372147A0000000, float 0xC052328F60000000, float 0x3FAEB851E0000000, float 0xC051428F60000000, float 1.450000e+01], [16 x float] [float 0x40206B8520000000, float 0x405198F5C0000000, float 0x4045D5C280000000, float 0xC058CD70A0000000, float 0x402A51EB80000000, float 0xC0428A3D80000000, float 0x403391EB80000000, float 0x403A2147A0000000, float 0x40527851E0000000, float 0xC025051EC0000000, float 0xC0537EB860000000, float 0xC035AB8520000000, float 0x404AD47AE0000000, float 0x4025E66660000000, float 0x40369EB860000000, float 0x4057E28F60000000], [16 x float] [float -5.175000e+02, float 0xC06D3E6660000000, float 0x406CE5C280000000, float 0xC081ECB860000000, float 0xC083C61480000000, float 0xC0733570A0000000, float 0xC0882747A0000000, float 0x4089CC2900000000, float 0xC07C0CF5C0000000, float 0xC04EA8F5C0000000, float 0xC0795BD700000000, float -1.767500e+02, float 0x408D5A1480000000, float 0xC0580999A0000000, float 0x408E4251E0000000, float 0x403563D700000000], [16 x float] [float 0xC08F155C20000000, float 0x40A2AF3340000000, float 0x40A438FAE0000000, float 0xC0A9DB99A0000000, float 0x40830B47A0000000, float 0xC0A3D12E20000000, float 1.302500e+02, float 2.917750e+03, float 0x40A6F23860000000, float 0xC08E1CCCC0000000, float 0x409CCCCCC0000000, float 0x407447AE20000000, float 0xC0A72D4CC0000000, float 0xC057DF5C20000000, float 0xC0828B1EC0000000, float 0x4095FAE140000000] }, %struct.anon.0 { [16 x float] [float 0xC0439D70A0000000, float 4.050000e+01, float 0x400770A3E0000000, float 0x40527C2900000000, float 0xC058251EC0000000, float 0xC0535F5C20000000, float 0x3FAEB851E0000000, float 0x4053533340000000, float 1.200000e+01, float 0x4036147AE0000000, float 0xC0462E1480000000, float 0xC0412CCCC0000000, float 0xC050BE1480000000, float 0x405390A3E0000000, float 0xC04367AE20000000, float 0xC032B851E0000000], [16 x float] [float 0xC04691EB80000000, float 0x405513D700000000, float 0x4037EB8520000000, float 0xC020D1EB80000000, float 0xC04735C280000000, float 0x404750A3E0000000, float 0xC039DC2900000000, float 0x4021666660000000, float -5.950000e+01, float 0x4040C7AE20000000, float 0x4056C147A0000000, float 0xC050651EC0000000, float 0xC053033340000000, float 0x4055F66660000000, float 0x404247AE20000000, float 0xC02E8F5C20000000], [16 x float] [float 0x4071B82900000000, float 0xC082E87AE0000000, float 0xC079D66660000000, float 0x4073DB3340000000, float 0xC077BFD700000000, float 0x408259EB80000000, float 0x4056AE1480000000, float 0x40871FD700000000, float 0xC067FEB860000000, float 0x4084388F60000000, float 0xC082DBC280000000, float 0x40614AE140000000, float 0x407AD9EB80000000, float 0x4020EB8520000000, float 0x408DB90A40000000, float 0x408E91D700000000], [16 x float] [float 0x40A00CB340000000, float 0x40A5F2FAE0000000, float 0xC07574F5C0000000, float 0xC073023D80000000, float 4.103250e+03, float 0xC0A7A43D80000000, float 0x40564AE140000000, float 0x409611F5C0000000, float 0xC08C4FAE20000000, float 0x4095B047A0000000, float 0xC0B2211EC0000000, float 0x40A2AE0520000000, float 0x40B592B0A0000000, float 0x40BAE399A0000000, float 0xC07D3C2900000000, float 0x4093C11480000000] }, %struct.anon.0 { [16 x float] [float 0xC02DAE1480000000, float 0x403307AE20000000, float 0xC0252E1480000000, float 0x40435EB860000000, float 0xC0412B8520000000, float 0x404FC66660000000, float 0xC04A48F5C0000000, float 0x4018A3D700000000, float 0xC0071EB860000000, float 0xC04EC66660000000, float 0x40444A3D80000000, float 0x40350F5C20000000, float 0xC0526C2900000000, float 0xC036D999A0000000, float 0xC0578E1480000000, float 0x404B547AE0000000], [16 x float] [float 0x4030A3D700000000, float 0xC041C7AE20000000, float 0xC02B23D700000000, float 0x4053A8F5C0000000, float 0xC05335C280000000, float 9.550000e+01, float 0x404A51EB80000000, float 0x400FC28F60000000, float 0x404E1999A0000000, float 0x4057128F60000000, float 0xC0548CCCC0000000, float 0x40095C2900000000, float 0xC01B70A3E0000000, float 0xC055C5C280000000, float 0x3FEFAE1480000000, float 0x4053928F60000000], [16 x float] [float 0x4073F78520000000, float 0x408C3FD700000000, float 0x40654999A0000000, float 0x408E80CCC0000000, float 0x4080DB8520000000, float 0x408424F5C0000000, float 0x4042D999A0000000, float 0xC07E97AE20000000, float 0xC08E56B860000000, float 0xC08163C280000000, float 0x408688B860000000, float 0xC0861E3D80000000, float 0x406ADFAE20000000, float 0x4088570A40000000, float 0x408A363D80000000, float 0xC08354E140000000], [16 x float] [float 0x405221EB80000000, float 0x406C68A3E0000000, float 0x4073A02900000000, float 0x40AF6D3860000000, float 0x40A8D44280000000, float 0x40BA39A660000000, float 0xC0A5532900000000, float 0xC07D1051E0000000, float 0xC091E347A0000000, float 0xC0B85CEB80000000, float 0xC0A46D2E20000000, float 0xC084082900000000, float 7.205000e+02, float 0x40A5A1C7A0000000, float 7.455000e+02, float 0x40AC9970A0000000] }], align 16
@.str.7 = private unnamed_addr constant [37 x i8] c"../spack-src/test/x86/avx512/fmadd.c\00", align 1
@.str.8 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.9 = private unnamed_addr constant [36 x i8] c"simde_mm512_loadu_ps(test_vec[i].r)\00", align 1
@.str.10 = private unnamed_addr constant [56 x i8] c"%s:%d: assertion failed: %s[%zu] ~= %s[%zu] (%f ~= %f)\0A\00", align 1
@stderr = external global ptr, align 8
@test_simde_mm512_mask_fmadd_ps.test_vec = internal constant [8 x %struct.anon.1] [%struct.anon.1 { [16 x float] [float 0x407B628F60000000, float 0x406C67AE20000000, float 0x4088FAE140000000, float 0x407AAA8F60000000, float 0x407F49EB80000000, float 0x408303C280000000, float 0xC064361480000000, float 0x4079B5C280000000, float 0xC08AE5C280000000, float -3.350000e+01, float 0x403F91EB80000000, float 0xC086D70A40000000, float 0xC0866CCCC0000000, float 0x40639570A0000000, float 0x408BD63D80000000, float 0x405B933340000000], i8 -43, [16 x float] [float 0xC03D70A3E0000000, float 0xC023C28F60000000, float 0xC045F47AE0000000, float 0x4041428F60000000, float 0xC04C70A3E0000000, float 0x3FB47AE140000000, float 0xC0428CCCC0000000, float 0x402C51EB80000000, float 0xC0348F5C20000000, float 0xC01FC28F60000000, float 0x4025CCCCC0000000, float 0x405265C280000000, float -3.100000e+01, float -7.300000e+01, float 0x403168F5C0000000, float 0x4056EE1480000000], [16 x float] [float 0xC08D155C20000000, float 0xC078F3D700000000, float 0x407A1D99A0000000, float 0x40852E6660000000, float 0x407B711EC0000000, float 0xC0655947A0000000, float 0x408988A3E0000000, float 0xC0829370A0000000, float 0x408AE62900000000, float 0xC08C8E6660000000, float 0xC073807AE0000000, float 0x403170A3E0000000, float 0x408E87D700000000, float 0x4088F22900000000, float 0x4058033340000000, float 0xC073D75C20000000], [16 x float] [float 0xC0CB030CC0000000, float 0x406C67AE20000000, float 0xC0E0EF41A0000000, float 0x407AAA8F60000000, float 0xC0DB610CC0000000, float 0x408303C280000000, float 0x40BA9FC7A0000000, float 0x40B46E6E20000000, float 0xC08AE5C280000000, float -3.350000e+01, float 0x403F91EB80000000, float 0xC086D70A40000000, float 0xC0866CCCC0000000, float 0x40639570A0000000, float 0x408BD63D80000000, float 0x405B933340000000] }, %struct.anon.1 { [16 x float] [float 0xC072C87AE0000000, float 0x408487EB80000000, float 0xC08E61EB80000000, float 0x4060542900000000, float -3.422500e+02, float 0xC075747AE0000000, float 0xC086BE7AE0000000, float 0x407C41C280000000, float 0x40820A2900000000, float 0x4077D35C20000000, float 0x406781EB80000000, float 0xC086E5EB80000000, float 0x4084595C20000000, float 0xC083EEA3E0000000, float 0xC0897C1480000000, float 7.205000e+02], i8 -52, [16 x float] [float 0x404E1D70A0000000, float 0x4043EA3D80000000, float 0xC04DE66660000000, float 0xC04C6CCCC0000000, float 0x40358A3D80000000, float 0xC0333D70A0000000, float 0xC051B147A0000000, float 0x403E28F5C0000000, float 0x4048C66660000000, float 0x403EFAE140000000, float 0x403BDC2900000000, float 0x403D6147A0000000, float 0xC04DB5C280000000, float 0x4058070A40000000, float 0x4058D51EC0000000, float 0xC0576E1480000000], [16 x float] [float 0x408EE6F5C0000000, float 0x405EFAE140000000, float 0xC071773340000000, float 0xC07626B860000000, float 0x4078C199A0000000, float 0xC089DAB860000000, float 0xC088491EC0000000, float 0xC06BD61480000000, float 0x40768B8520000000, float 0xC07FDE1480000000, float 0xC081DC2900000000, float 0x4086971EC0000000, float 0xC074563D80000000, float 0xC08A981480000000, float 0xC073A2B860000000, float 0xC086986660000000], [16 x float] [float 0xC072C87AE0000000, float 0x408487EB80000000, float 5.786050e+04, float 0xC0BE64BD80000000, float -3.422500e+02, float 0xC075747AE0000000, float 0x40E8C53F00000000, float 0x40CA3279A0000000, float 0x40820A2900000000, float 0x4077D35C20000000, float 0x406781EB80000000, float 0xC086E5EB80000000, float 0x4084595C20000000, float 0xC083EEA3E0000000, float 0xC0897C1480000000, float 7.205000e+02] }, %struct.anon.1 { [16 x float] [float 0x40811A51E0000000, float 0x4055F5C280000000, float 0xC072382900000000, float 0xC06DAA3D80000000, float 0x408BFB5C20000000, float 0x3FE9EB8520000000, float 0xC08D3DEB80000000, float 0x40786F8520000000, float 0xC0858B70A0000000, float 0x40756D47A0000000, float 0xC073B38520000000, float 0xC071B9EB80000000, float 0x4072FF0A40000000, float 0xC0741EE140000000, float 0xC06B9A8F60000000, float 0x40724CF5C0000000], i8 14, [16 x float] [float 0x4048FC2900000000, float 0x405775C280000000, float 0x4033CF5C20000000, float 0x4050CF5C20000000, float 0xC054F851E0000000, float 0x4058628F60000000, float 0x400A7AE140000000, float 0xC0416E1480000000, float 0xC04DCE1480000000, float 0xC038666660000000, float 0x40404CCCC0000000, float 0xC0465AE140000000, float 0x4046170A40000000, float 0x404E251EC0000000, float 0xC0567EB860000000, float 0xC04783D700000000], [16 x float] [float 0xC08584A3E0000000, float 0xC0612570A0000000, float 0xC081F747A0000000, float 0x407383AE20000000, float 0xC0523999A0000000, float 0x4089807AE0000000, float 0x4083766660000000, float 0xC086D08F60000000, float 0xC07F328F60000000, float 0xC084A6A3E0000000, float 0x4081EEF5C0000000, float 0x40665CCCC0000000, float 0x405D966660000000, float 0xC060AA3D80000000, float 0xC0331C2900000000, float 0xC077DEE140000000], [16 x float] [float 0x40811A51E0000000, float 0x40BFA9BAE0000000, float 0xC0B8CDB860000000, float 0xC0CE8E95C0000000, float 0x408BFB5C20000000, float 0x3FE9EB8520000000, float 0xC08D3DEB80000000, float 0x40786F8520000000, float 0xC0858B70A0000000, float 0x40756D47A0000000, float 0xC073B38520000000, float 0xC071B9EB80000000, float 0x4072FF0A40000000, float 0xC0741EE140000000, float 0xC06B9A8F60000000, float 0x40724CF5C0000000] }, %struct.anon.1 { [16 x float] [float 0xC0685DC280000000, float 0xC089A83D80000000, float 0xC0862C6660000000, float 0xC040D70A40000000, float 0xC08A6D0A40000000, float 0x407438CCC0000000, float 0x40834D70A0000000, float -4.417500e+02, float 0xC08CC399A0000000, float 0xC04C2B8520000000, float 0x405BC70A40000000, float 0x40804AF5C0000000, float 0xC07C56B860000000, float 0x406A68A3E0000000, float 0xC08DA7AE20000000, float 0xC061C051E0000000], i8 -8, [16 x float] [float 0xC04A31EB80000000, float 0xC054BEB860000000, float 0x3FBEB851E0000000, float 0xC051B1EB80000000, float 0x4053D33340000000, float 0x403B1C2900000000, float 0xC034B33340000000, float 0xC055B1EB80000000, float -1.550000e+01, float 0x40584C2900000000, float 0x40390CCCC0000000, float 0x4051CAE140000000, float 0xC012E147A0000000, float 0x4055B70A40000000, float 0xC0482A3D80000000, float 0x402A5C2900000000], [16 x float] [float 0xC08A4799A0000000, float 0x407E30F5C0000000, float 0x4071E26660000000, float 0x407E2999A0000000, float 0x40592F5C20000000, float 0x408A633340000000, float 0x4081913340000000, float 0xC08DDCCCC0000000, float 0xC0463EB860000000, float 0x4054E147A0000000, float 0xC0799051E0000000, float 0xC08A09AE20000000, float 0x4060D1EB80000000, float 0x407C0F8520000000, float 0xC087B8E140000000, float 0x4083158520000000], [16 x float] [float 0xC0685DC280000000, float 0xC089A83D80000000, float 0xC0862C6660000000, float 0x40A664F0A0000000, float 0xC0F058DB80000000, float 0x40C2C7EB80000000, float 0xC0C7DFEA40000000, float 0x40E2406EC0000000, float 0xC08CC399A0000000, float 0xC04C2B8520000000, float 0x405BC70A40000000, float 0x40804AF5C0000000, float 0xC07C56B860000000, float 0x406A68A3E0000000, float 0xC08DA7AE20000000, float 0xC061C051E0000000] }, %struct.anon.1 { [16 x float] [float 0x4083598520000000, float 0x406E433340000000, float 0x408C370A40000000, float 0x4079C35C20000000, float 0xC07E6C51E0000000, float 0xC0730199A0000000, float 0x4081033340000000, float 0x407663AE20000000, float 0xC074C2E140000000, float 0xC069A1EB80000000, float 0x40517A3D80000000, float 0x4083650A40000000, float 0xC075075C20000000, float 0x40825547A0000000, float 0xC06EF2E140000000, float 0xC0662CCCC0000000], i8 4, [16 x float] [float 0xC05808F5C0000000, float 0xC0515EB860000000, float 0xC054BCCCC0000000, float 0x4056133340000000, float 0x4055AEB860000000, float 0xC053A0A3E0000000, float 0xC030266660000000, float 0xC013A3D700000000, float 0xC0336B8520000000, float 0x3FE0F5C280000000, float 0xC056DD70A0000000, float 0xC052A147A0000000, float 0x40389EB860000000, float 0x4051670A40000000, float 0x4055D999A0000000, float 0xC04995C280000000], [16 x float] [float 0x4082B7EB80000000, float 0x4071E35C20000000, float 0x3FF7D70A40000000, float 0xC08608E140000000, float 0xC0652C7AE0000000, float 0xC084023D80000000, float 0xC042A51EC0000000, float 0x40838C6660000000, float 0x407ADA1480000000, float 0xC07A0A8F60000000, float 0xC086373340000000, float 0x40304A3D80000000, float 0x4074FC2900000000, float 0x405BEC2900000000, float 0xC08C8FEB80000000, float 0x4077651EC0000000], [16 x float] [float 0x4083598520000000, float 0x406E433340000000, float 0xC0F248C680000000, float 0x4079C35C20000000, float 0xC07E6C51E0000000, float 0xC0730199A0000000, float 0x4081033340000000, float 0x407663AE20000000, float 0xC074C2E140000000, float 0xC069A1EB80000000, float 0x40517A3D80000000, float 0x4083650A40000000, float 0xC075075C20000000, float 0x40825547A0000000, float 0xC06EF2E140000000, float 0xC0662CCCC0000000] }, %struct.anon.1 { [16 x float] [float 0x407A0E3D80000000, float 0xC0873C3D80000000, float 0x407014A3E0000000, float 0x4071C3AE20000000, float 0xC0808547A0000000, float 0xC08C41D700000000, float 0xC087E73340000000, float 0x407152E140000000, float 0x4059428F60000000, float 0xC0853BD700000000, float 0x40809FEB80000000, float 0xC084666660000000, float 0xC08EBAE140000000, float 0x40795FD700000000, float 0xC0649199A0000000, float 0x40833D0A40000000], i8 -22, [16 x float] [float 0x4054EC2900000000, float 0x4056C33340000000, float 0x404A23D700000000, float 0xC054151EC0000000, float 0xC0295C2900000000, float 0x402DAE1480000000, float 0x404F50A3E0000000, float 0x4046D47AE0000000, float 4.375000e+01, float 0xC041DEB860000000, float 0xC034C51EC0000000, float 0xC0468A3D80000000, float 0xC03B23D700000000, float 0xC054D51EC0000000, float 0x4058270A40000000, float 0xBFF7D70A40000000], [16 x float] [float 0x407A7F3340000000, float 0x406F4947A0000000, float 0x407C866660000000, float 0x40803DAE20000000, float 0x407E563D80000000, float 0xC070A6B860000000, float -3.792500e+02, float 0x40892F5C20000000, float 0xC086F370A0000000, float 0xC040066660000000, float 0x4089B47AE0000000, float 0x4084FC7AE0000000, float 0x40891B3340000000, float 0x407B630A40000000, float 0xC083E1D700000000, float 0x408402B860000000], [16 x float] [float 0x407A0E3D80000000, float 0xC0F07781E0000000, float 0x407014A3E0000000, float 0xC0D5CA1F60000000, float 0xC0808547A0000000, float 0xC0CABA9860000000, float 0xC0E7939E20000000, float 0x40CA4AFAE0000000, float 0x4059428F60000000, float 0xC0853BD700000000, float 0x40809FEB80000000, float 0xC084666660000000, float 0xC08EBAE140000000, float 0x40795FD700000000, float 0xC0649199A0000000, float 0x40833D0A40000000] }, %struct.anon.1 { [16 x float] [float 0x4075CB5C20000000, float 0x408BB4B860000000, float 0x408A281480000000, float 0xC088507AE0000000, float 0x40417AE140000000, float 0x407CF4CCC0000000, float 0x4085342900000000, float 0xC0807C7AE0000000, float 0xC08BF0E140000000, float 0xC080893340000000, float 0x40359C2900000000, float 0xC064B0A3E0000000, float 0xC076A7D700000000, float 0xC028A8F5C0000000, float 0x40899C6660000000, float 0xC08D546660000000], i8 -23, [16 x float] [float 0x403B9999A0000000, float 0x404D0F5C20000000, float 0x405215C280000000, float 0xC058C33340000000, float 0xC053F3D700000000, float 0x404A770A40000000, float 0xC0521F5C20000000, float 0x4030FD70A0000000, float 0x4041970A40000000, float 0x4057AAE140000000, float 0xC0055C2900000000, float -2.100000e+01, float 0xC0513D70A0000000, float 0xC04351EB80000000, float 0xC0558851E0000000, float 0xC054133340000000], [16 x float] [float 0xC0812B1EC0000000, float 0xC083FAA3E0000000, float 0x406CFF5C20000000, float 0x408C8F5C20000000, float 0xC08E067AE0000000, float 0x40860347A0000000, float 0xC08EA18520000000, float 0xC07E9F5C20000000, float 0xC0711FAE20000000, float 0xC06236B860000000, float 0x40627199A0000000, float 0x40864D8520000000, float 0xC074628F60000000, float 2.090000e+02, float 0x408DBD3340000000, float 0x408DAE51E0000000], [16 x float] [float 0x40C1B98140000000, float 0x408BB4B860000000, float 0x408A281480000000, float 0x40F309CC60000000, float 0x40417AE140000000, float 0x40D8A2B860000000, float 0xC0E87EC380000000, float 0xC0C27699A0000000, float 0xC08BF0E140000000, float 0xC080893340000000, float 0x40359C2900000000, float 0xC064B0A3E0000000, float 0xC076A7D700000000, float 0xC028A8F5C0000000, float 0x40899C6660000000, float 0xC08D546660000000] }, %struct.anon.1 { [16 x float] [float 0xC06A3A8F60000000, float 6.750000e+02, float 0x408DFA8F60000000, float 0xC01FA3D700000000, float 0x406988A3E0000000, float 0xC087ECA3E0000000, float 0xC08A306660000000, float 0xC07BBE6660000000, float 0xC089975C20000000, float 0x4060E6B860000000, float 0x4075A1EB80000000, float 0xC07FC7D700000000, float 0x4087668F60000000, float 0x407E4D99A0000000, float 0xC073778520000000, float 0xC089048F60000000], i8 77, [16 x float] [float 0x4057033340000000, float 0xC0562AE140000000, float 0x40561E1480000000, float 0x404F3EB860000000, float 0xC055AB8520000000, float 0xC04E428F60000000, float 0xC0503A3D80000000, float 0xBFF428F5C0000000, float 0x404B1D70A0000000, float 0xC057628F60000000, float 0x40508851E0000000, float 0xC038DEB860000000, float 0xC05897AE20000000, float 0x404E8E1480000000, float 0x404B133340000000, float 0x40514851E0000000], [16 x float] [float 0x4081D33340000000, float 0xC07D26B860000000, float 0xC05A1CCCC0000000, float 0x408926A3E0000000, float 0xC073078520000000, float 0x407C3A6660000000, float 0x408ECF47A0000000, float 0x4089F5EB80000000, float 0xC069475C20000000, float 0xC08054A3E0000000, float 0x40821C6660000000, float 0xC0866B0A40000000, float 0x4064BE6660000000, float 0x408857D700000000, float 0xC08B3ECCC0000000, float 0x40559CCCC0000000], [16 x float] [float 0xC0D24E1CC0000000, float 6.750000e+02, float 0x40F4B1E980000000, float 0x4073687AE0000000, float 0x406988A3E0000000, float 0xC087ECA3E0000000, float 0x40EB0AF7A0000000, float 0xC07BBE6660000000, float 0xC089975C20000000, float 0x4060E6B860000000, float 0x4075A1EB80000000, float 0xC07FC7D700000000, float 0x4087668F60000000, float 0x407E4D99A0000000, float 0xC073778520000000, float 0xC089048F60000000] }], align 16
@test_simde_mm512_maskz_fmadd_ps.test_vec = internal constant [8 x %struct.anon.2] [%struct.anon.2 { i16 14967, [16 x float] [float 0x40321C2900000000, float 0xC044ACCCC0000000, float 0x4040228F60000000, float 0xBFFA8F5C20000000, float 0xC035A3D700000000, float 0x40534CCCC0000000, float 0x4041BAE140000000, float 0xC056BA3D80000000, float 0xC0500EB860000000, float 0xC030851EC0000000, float 0x4036DEB860000000, float 0x403E28F5C0000000, float 0xC01B666660000000, float 0x4049D33340000000, float 0xC0030A3D80000000, float 0xC01D147AE0000000], [16 x float] [float 0xC03A028F60000000, float 5.075000e+01, float 0x403AB33340000000, float 0x4035970A40000000, float 0x4043C66660000000, float 0x4045CE1480000000, float 0xC030D999A0000000, float 6.200000e+01, float 0xC024A8F5C0000000, float 0xC04050A3E0000000, float 0x403D8F5C20000000, float 0x400451EB80000000, float 0x40522F5C20000000, float 0xC04288F5C0000000, float 0xC0529851E0000000, float 0xC0224CCCC0000000], [16 x float] [float 0x406AF999A0000000, float 0x408216CCC0000000, float 8.920000e+02, float 0x408F3AE140000000, float 0x4075EE1480000000, float 0x406ED42900000000, float 0xC08C6DD700000000, float 0x4086246660000000, float 0xC08CB46660000000, float 0x4073EF8520000000, float 0x40246147A0000000, float 0x4029EB8520000000, float 0xC0649147A0000000, float 0x408ED2F5C0000000, float 0x408D622900000000, float 0x4081FB3340000000], [16 x float] [float 0xC06FE7AE20000000, float 0xC097BEA3E0000000, float 0x409B6670A0000000, float 0.000000e+00, float 0xC07F8FAE20000000, float 0x40AC3AA3E0000000, float 0xC0978CEB80000000, float 0.000000e+00, float 0.000000e+00, float 0x408AD02900000000, float 0.000000e+00, float 0x4056647AE0000000, float 0xC084B67AE0000000, float 0xC08D026660000000, float 0.000000e+00, float 0.000000e+00] }, %struct.anon.2 { i16 -16283, [16 x float] [float 0xC034DEB860000000, float 0xC02623D700000000, float 0xC041D5C280000000, float 0x404F228F60000000, float 0xC04888F5C0000000, float 5.400000e+01, float 0xC051970A40000000, float 0x40541F5C20000000, float 0xC045BC2900000000, float 0xC05867AE20000000, float 0xC04C4A3D80000000, float 0xC031D999A0000000, float 0xC01B0A3D80000000, float 6.500000e+01, float 0xC04DFAE140000000, float 0xC0318F5C20000000], [16 x float] [float 0x40503C2900000000, float 0x4052C7AE20000000, float 0xC0573999A0000000, float 0x40527D70A0000000, float 0x4046FD70A0000000, float -8.475000e+01, float 0x401770A3E0000000, float -5.300000e+01, float 0x40308A3D80000000, float 0x40565A3D80000000, float 0xC04B2F5C20000000, float 0x402523D700000000, float 0x40477999A0000000, float 0x4057C147A0000000, float 0xC0512D70A0000000, float 0xC0527B8520000000], [16 x float] [float 0xC06410A3E0000000, float 0xC045E147A0000000, float 0x408B9B8520000000, float 0x4075CC2900000000, float 0xC07F7CA3E0000000, float 0xC089A11EC0000000, float 0x406333D700000000, float 0x404EC51EC0000000, float 0xC088E27AE0000000, float 0x40825E7AE0000000, float 0x408B9851E0000000, float 0x4061028F60000000, float 0x406DB999A0000000, float 0xC08664CCC0000000, float 0x408E0399A0000000, float 0xC05C366660000000], [16 x float] [float 0xC097AF47A0000000, float 0.000000e+00, float 0x40B0652E20000000, float 0.000000e+00, float 0.000000e+00, float 0xC0B514A3E0000000, float 0xC0702B0A40000000, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0x40B3D84CC0000000, float 0x40928570A0000000] }, %struct.anon.2 { i16 -32524, [16 x float] [float 0xC042A8F5C0000000, float 0x4048B851E0000000, float 0xC054670A40000000, float 0x4051228F60000000, float 0x40581C2900000000, float 0x4041770A40000000, float 0x404CF851E0000000, float 0xC04CF70A40000000, float -5.450000e+01, float 0x40138F5C20000000, float 0xC04F747AE0000000, float 0xC037333340000000, float 0x403EF5C280000000, float 0x40350A3D80000000, float 0x40521AE140000000, float 0x40334CCCC0000000], [16 x float] [float 0xC0460A3D80000000, float 0xC0537D70A0000000, float 0x4042A51EC0000000, float 0x4051D1EB80000000, float 0x403C333340000000, float 0x404CD47AE0000000, float 0x403E0F5C20000000, float 1.650000e+01, float 0xC03CBAE140000000, float 0xC047147AE0000000, float 0x40466B8520000000, float 0xC0405851E0000000, float 0x4045466660000000, float 0x404827AE20000000, float 0xC03D8A3D80000000, float 0xC057B147A0000000], [16 x float] [float 0xC036851EC0000000, float 0xC05BDF5C20000000, float 0x40870D70A0000000, float 0xC04D0E1480000000, float 0xC087D13340000000, float 0x4073D199A0000000, float 0x4076AA3D80000000, float 0xC07331C280000000, float 0xC083D03D80000000, float 0x4086EC8F60000000, float 0x407CCDC280000000, float 0x40851C8F60000000, float 0xC04C0147A0000000, float 0x4067228F60000000, float 0xC0606C7AE0000000, float 0x407F728F60000000], [16 x float] [float 0.000000e+00, float 0.000000e+00, float 0xC0A2031EC0000000, float 0.000000e+00, float 0x409E95D700000000, float 0x40A23651E0000000, float 0x40A070A3E0000000, float 0xC093BBCCC0000000, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0xC094B799A0000000] }, %struct.anon.2 { i16 30249, [16 x float] [float 0x40359999A0000000, float -3.125000e+01, float 0x405473D700000000, float 0xC0482B8520000000, float 8.525000e+01, float 0xC04775C280000000, float 0x4015F5C280000000, float 0x403E170A40000000, float 0x403463D700000000, float 0xC049F999A0000000, float 0xC0359C2900000000, float 0x4056B66660000000, float 0xC0475C2900000000, float 0x405308F5C0000000, float 0xC0344CCCC0000000, float 0xC0523CCCC0000000], [16 x float] [float 0xC03DAB8520000000, float 0x400BD70A40000000, float 0x404D6147A0000000, float 0xC0575999A0000000, float 0x40523147A0000000, float 0x4057D66660000000, float 0x4053FCCCC0000000, float 0x4032DC2900000000, float 0x404F747AE0000000, float 0xC039A66660000000, float 0xC04F50A3E0000000, float 0xC0491D70A0000000, float 0xC052D51EC0000000, float 0x40537AE140000000, float 0xC03A147AE0000000, float 0x40472147A0000000], [16 x float] [float 0xC080AAB860000000, float 0xC07BAAB860000000, float 0x408E9970A0000000, float 0xC08546E140000000, float 0x4056066660000000, float 0x40410F5C20000000, float 0x4083602900000000, float -7.080000e+02, float 0x408014E140000000, float 0xC082A051E0000000, float 0xC088FC2900000000, float 0xC08DC4CCC0000000, float 0xC08A14E140000000, float 0xC0043D70A0000000, float 0xC085510A40000000, float 0xC0606999A0000000], [16 x float] [float 0xC09258D700000000, float 0.000000e+00, float 0.000000e+00, float 0x40ADF43340000000, float 0.000000e+00, float 0xC0B157B340000000, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0x408703D700000000, float 0x40814F47A0000000, float 0.000000e+00, float 0x40A4F99EC0000000, float 0x40B72A4CC0000000, float 0xC06316B860000000, float 0.000000e+00] }, %struct.anon.2 { i16 -28722, [16 x float] [float 0xC01A1EB860000000, float 0x405300A3E0000000, float 0x40557999A0000000, float 0xC03A947AE0000000, float 0xC014851EC0000000, float 0x404867AE20000000, float 0x4047E28F60000000, float 0x40401D70A0000000, float 0x4058A51EC0000000, float 0x40521C2900000000, float 0x40244CCCC0000000, float 0xC03B7D70A0000000, float 0x4032B33340000000, float 0x404C68F5C0000000, float 0x403C3D70A0000000, float 0x40309EB860000000], [16 x float] [float 0x40562EB860000000, float 0xC04F7999A0000000, float 0xC053FE1480000000, float 0x40495D70A0000000, float -3.375000e+01, float 0x4051DF5C20000000, float 0x4056C851E0000000, float 0xC02B666660000000, float 0x40530EB860000000, float 0xC057151EC0000000, float 0x4055828F60000000, float 0xC056FEB860000000, float 0xC015D70A40000000, float 0x405651EB80000000, float 0x4058A3D700000000, float 0x405600A3E0000000], [16 x float] [float 0x4084667AE0000000, float 0x408A64E140000000, float 0xC0781C51E0000000, float 0xC078E8A3E0000000, float 0x4074CB5C20000000, float 0xC08C608F60000000, float 0x408CDE6660000000, float 0x4073E87AE0000000, float 0x4089826660000000, float 0x403951EB80000000, float 0xC08DE35C20000000, float 0x400A666660000000, float -4.065000e+02, float 0x40745F8520000000, float 0xC089F43D80000000, float 0xC080398520000000], [16 x float] [float 0.000000e+00, float 0xC0AEC870A0000000, float 0xC0BC5730A0000000, float 0xC09B4BC280000000, float 0.000000e+00, float 0.000000e+00, float 0x40B49D1480000000, float 0xC05EC147A0000000, float 0x40C0458660000000, float 0xC0BA0711E0000000, float 0xC054C70A40000000, float 0x40A3C7A900000000, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0x408D7C51E0000000] }, %struct.anon.2 { i16 21105, [16 x float] [float 0x4058B3D700000000, float 0xC050070A40000000, float 0xC056E1EB80000000, float 0x40567CCCC0000000, float 0x403630A3E0000000, float 0x40552CCCC0000000, float 0x4058670A40000000, float 0x402075C280000000, float 0x40572E1480000000, float 0xC01F666660000000, float 0xC003EB8520000000, float 0x4056D1EB80000000, float 0xC033D70A40000000, float 0xC0429AE140000000, float 0x4052EF5C20000000, float 0x4044CA3D80000000], [16 x float] [float 0x4036EE1480000000, float 0x4022051EC0000000, float 0x404963D700000000, float 0x402E9EB860000000, float 0xC04D91EB80000000, float 0x4040347AE0000000, float 0xC0548999A0000000, float 0xC04B63D700000000, float 0xC050D147A0000000, float 0xC036CCCCC0000000, float 0x4053747AE0000000, float 0xC04928F5C0000000, float 0x403947AE20000000, float 0x4047BAE140000000, float 0xC02AAE1480000000, float 0x4038170A40000000], [16 x float] [float 0x408A0C8F60000000, float 0xC0485EB860000000, float 0x40618BD700000000, float 0x404BBAE140000000, float -2.017500e+02, float 0x405D20A3E0000000, float 0xC08AF1AE20000000, float 0xC0712970A0000000, float 0xC08E0F99A0000000, float 0x405C3851E0000000, float 0xC0769CF5C0000000, float 0xC0640B8520000000, float 0x4087261480000000, float 0xC082E35C20000000, float 0xC0874451E0000000, float 0xC03DE3D700000000], [16 x float] [float 0x40A8368F60000000, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0xC097A847A0000000, float 0x40A65B47A0000000, float 0xC0C1586F60000000, float 0.000000e+00, float 0.000000e+00, float 0x40723DC280000000, float 0.000000e+00, float 0.000000e+00, float 0x406DE66660000000, float 0.000000e+00, float 0xC09B6BA3E0000000, float 0.000000e+00] }, %struct.anon.2 { i16 -28466, [16 x float] [float 0xC055EAE140000000, float 0x40565B8520000000, float 0x402175C280000000, float 0xC051751EC0000000, float 0xC050566660000000, float 0x4044BAE140000000, float 0x401D7AE140000000, float 0xC055E1EB80000000, float 0x4056C8F5C0000000, float 0xC050D70A40000000, float 0x404DF70A40000000, float 0xC036333340000000, float 0x404C5EB860000000, float 0x4045A51EC0000000, float 0x40523B8520000000, float 0xC03D3AE140000000], [16 x float] [float 0xC049947AE0000000, float -4.725000e+01, float 0x40549AE140000000, float 0xC042B0A3E0000000, float 0x40394A3D80000000, float 0x40558EB860000000, float 0x40527999A0000000, float 0x4056470A40000000, float 0xC03DCF5C20000000, float 0x4047FD70A0000000, float 0xC051D51EC0000000, float 0xC0110A3D80000000, float 0xC04B8147A0000000, float 0x40534F5C20000000, float 0xC03BF0A3E0000000, float 0xC045570A40000000], [16 x float] [float 0x4084D5AE20000000, float 0x40893EF5C0000000, float 0xC05F47AE20000000, float -9.867500e+02, float 0x406BCF5C20000000, float 0x408DA46660000000, float 0xC08AF051E0000000, float 0x4060BD1EC0000000, float 0xC086A81480000000, float 0x40870A7AE0000000, float 0x408C7F8520000000, float 0x408A52CCC0000000, float 0x4065470A40000000, float 0x408409C280000000, float 0xC07C1E8F60000000, float 0x408494CCC0000000], [16 x float] [float 0.000000e+00, float 0xC0AAB36660000000, float 0x40829347A0000000, float 1.623500e+03, float 0.000000e+00, float 0.000000e+00, float 0xC073D66660000000, float 0xC0BDF1E3E0000000, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0xC0A70E19A0000000, float 0.000000e+00, float 0.000000e+00, float 0x409DC88F60000000] }, %struct.anon.2 { i16 2209, [16 x float] [float 0xC051E147A0000000, float 0x404515C280000000, float 0xC05315C280000000, float 0xC05867AE20000000, float 0x403F47AE20000000, float 0xC0188F5C20000000, float 0x40492E1480000000, float 0x404DF999A0000000, float 0x4056666660000000, float 0x4057D66660000000, float 0x40429851E0000000, float 0xC0432B8520000000, float 0xC047AA3D80000000, float 0x400EE147A0000000, float 0xC04CC7AE20000000, float 0x4044147AE0000000], [16 x float] [float 0x4014C28F60000000, float 0x40502C2900000000, float 0x40418147A0000000, float 0x4032FD70A0000000, float 0xC035EB8520000000, float 0x404F4147A0000000, float 0xC01D1EB860000000, float 0xC03EB851E0000000, float 4.675000e+01, float 0xC05690A3E0000000, float 0xC050A66660000000, float 0xC0588F5C20000000, float 0x4052E66660000000, float 0xC048DC2900000000, float 0xC04E67AE20000000, float 0xC057FB8520000000], [16 x float] [float 0x408CE38520000000, float 0xC077378520000000, float 0xC08D3B99A0000000, float 0x406DA8A3E0000000, float 0x4081B8B860000000, float 0x4081C147A0000000, float 0xC064666660000000, float 0x407CF0F5C0000000, float 0x40804D8520000000, float 0xC088BA1480000000, float 0xC08CC2F5C0000000, float 0xC08DBCE140000000, float 0x406EEC2900000000, float 0xC07EFEB860000000, float 0x407C1F8520000000, float 0xC085E5D700000000], [16 x float] [float 5.532500e+02, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0x40670B3340000000, float 0.000000e+00, float 0xC0958A6660000000, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0x40A5FDD1E0000000, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00] }], align 16
@test_simde_mm512_fmadd_pd.test_vec = internal constant [8 x %struct.anon.3] [%struct.anon.3 { [8 x double] [double -1.520000e+01, double -9.209000e+01, double -5.680000e+00, double -6.032000e+01, double 1.166000e+01, double -3.924000e+01, double -4.798000e+01, double 0xC023E66666666666], [8 x double] [double -6.723000e+01, double -6.840000e+01, double -4.795000e+01, double 2.622000e+01, double -8.214000e+01, double 0x4052833333333333, double -3.399000e+01, double 0x40568F5C28F5C28F], [8 x double] [double 1.985700e+02, double -6.362500e+02, double 4.708900e+02, double 2.995000e+02, double -3.648200e+02, double 4.405600e+02, double 4.868800e+02, double 0x408CC33333333333], [8 x double] [double 1.220470e+03, double 5.662710e+03, double 7.432500e+02, double -1.282090e+03, double -1.322570e+03, double -2.465160e+03, double 2.117720e+03, double 2.251000e+01] }, %struct.anon.3 { [8 x double] [double 0xC055170A3D70A3D7, double -6.418000e+01, double -1.796000e+01, double -1.318000e+01, double -5.367000e+01, double 2.682000e+01, double -6.480000e+00, double 6.466000e+01], [8 x double] [double -4.892000e+01, double 0xC054133333333333, double 0xC0538147AE147AE1, double -6.990000e+01, double 2.955000e+01, double 5.181000e+01, double 0xC04D6147AE147AE1, double -4.334000e+01], [8 x double] [double -3.695400e+02, double -9.385900e+02, double -9.493500e+02, double 2.943000e+02, double 2.684500e+02, double -1.991700e+02, double 0x4082213333333333, double 6.251200e+02], [8 x double] [double 3.757350e+03, double 4.215060e+03, double 4.518900e+02, double 1.215580e+03, double -1.317500e+03, double 1.190370e+03, double 0x408E0747AE147AE1, double -2.177240e+03] }, %struct.anon.3 { [8 x double] [double 4.220000e+01, double 8.103000e+01, double 0x4057670A3D70A3D7, double 0x40555D70A3D70A3D, double -5.478000e+01, double -4.311000e+01, double 6.899000e+01, double -7.224000e+01], [8 x double] [double 3.124000e+01, double 4.402000e+01, double 3.586000e+01, double 3.600000e+01, double 4.985000e+01, double 7.108000e+01, double 0x4057FC28F5C28F5C, double 0xC04EF70A3D70A3D7], [8 x double] [double -7.068000e+01, double 1.135100e+02, double -2.466600e+02, double 3.295300e+02, double 3.450100e+02, double 5.174700e+02, double 0xC08C1828F5C28F5C, double 1.630300e+02], [8 x double] [double 1.247650e+03, double 3.680450e+03, double 3.110190e+03, double 3.406090e+03, double -2.385770e+03, double -2.546790e+03, double 5.719880e+03, double 4.636850e+03] }, %struct.anon.3 { [8 x double] [double 1.760000e+00, double -7.431000e+01, double 6.256000e+01, double -3.750000e+01, double 1.398000e+01, double 0xC051147AE147AE14, double 0xC0508C28F5C28F5C, double -8.980000e+00], [8 x double] [double -4.681000e+01, double 3.906000e+01, double -8.648000e+01, double -5.233000e+01, double 0x4053A47AE147AE14, double 2.960000e+00, double -7.043000e+01, double 7.787000e+01], [8 x double] [double -7.089600e+02, double 5.891000e+02, double 0xC08CFC3D70A3D70A, double 0x408DAC6666666666, double -8.300200e+02, double -1.188300e+02, double 8.502000e+02, double -7.684600e+02], [8 x double] [double -7.913500e+02, double -2.313450e+03, double -6.337720e+03, double 2.911920e+03, double 2.683900e+02, double -3.210600e+02, double 5.511960e+03, double -1.467730e+03] }, %struct.anon.3 { [8 x double] [double 5.304000e+01, double 1.101000e+01, double -8.873000e+01, double -9.001000e+01, double 2.651000e+01, double 8.806000e+01, double 5.577000e+01, double 0x40544C28F5C28F5C], [8 x double] [double 0x40562147AE147AE1, double 0x4052E51EB851EB85, double -7.510000e+00, double -8.056000e+01, double 5.457000e+01, double 0xC057F33333333333, double -8.404000e+01, double 2.223000e+01], [8 x double] [double -5.540200e+02, double 5.176200e+02, double -3.143600e+02, double 5.175600e+02, double 6.752200e+02, double 4.629600e+02, double 0xC08F1251EB851EB8, double 8.963300e+02], [8 x double] [double 4.141080e+03, double 1.349760e+03, double 3.520000e+02, double 7.768770e+03, double 2.121870e+03, double -7.973190e+03, double -5.681200e+03, double 2.701180e+03] }, %struct.anon.3 { [8 x double] [double 0x404F370A3D70A3D7, double 3.895000e+01, double 9.762000e+01, double 2.391000e+01, double -9.070000e+01, double -3.525000e+01, double -5.592000e+01, double 9.162000e+01], [8 x double] [double 4.907000e+01, double -4.816000e+01, double 3.798000e+01, double -8.953000e+01, double 3.097000e+01, double -7.620000e+01, double -1.845000e+01, double -3.622000e+01], [8 x double] [double 0x40861251EB851EB8, double 5.335600e+02, double -5.342100e+02, double -5.396600e+02, double -6.445000e+01, double 8.474400e+02, double 0x408C226666666666, double -7.062700e+02], [8 x double] [double 3.769730e+03, double -1.342270e+03, double 3.173400e+03, double -2.680320e+03, double -2.873430e+03, double 3.533490e+03, double 1.932020e+03, double -4.024750e+03] }, %struct.anon.3 { [8 x double] [double -2.807000e+01, double 0x4053947AE147AE14, double -3.412000e+01, double -3.250000e+00, double -7.250000e+00, double 1.089000e+01, double 0x40544C28F5C28F5C, double -2.426000e+01], [8 x double] [double 6.422000e+01, double 1.380000e+01, double -2.484000e+01, double -5.457000e+01, double 4.330000e+00, double 2.821000e+01, double -3.050000e+01, double 0xC0583D70A3D70A3D], [8 x double] [double 4.088000e+01, double 0x408F015C28F5C28F, double -5.277700e+02, double -2.369500e+02, double -4.753200e+02, double -6.950700e+02, double -1.712000e+01, double 2.231400e+02], [8 x double] [double -1.761780e+03, double 2.072990e+03, double 3.197700e+02, double -5.960000e+01, double -5.067100e+02, double -3.878600e+02, double -2.493410e+03, double 2.575390e+03] }, %struct.anon.3 { [8 x double] [double 3.524000e+01, double 6.504000e+01, double -1.935000e+01, double 0xC0230A3D70A3D70A, double 4.663000e+01, double 8.876000e+01, double 6.350000e+00, double -2.093000e+01], [8 x double] [double -2.693000e+01, double -1.331000e+01, double 3.730000e+01, double -5.620000e+01, double 9.298000e+01, double -9.279000e+01, double 0x404E770A3D70A3D7, double -9.076000e+01], [8 x double] [double 4.536100e+02, double -2.081800e+02, double 0xC08A1947AE147AE1, double -4.960600e+02, double 7.961000e+02, double 1.691000e+01, double 2.885800e+02, double 2.031300e+02], [8 x double] [double -4.954000e+02, double -1.073860e+03, double -1.556910e+03, double 3.896000e+01, double 5.131760e+03, double 0xC0C00D90A3D70A3D, double 6.754900e+02, double 2.102740e+03] }], align 16
@.str.11 = private unnamed_addr constant [36 x i8] c"simde_mm512_loadu_pd(test_vec[i].r)\00", align 1

; Function Attrs: nounwind uwtable
define dso_local i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %retval1 = alloca i32, align 4
  %i = alloca i64, align 8
  %res = alloca i32, align 4
  store i32 0, ptr %retval, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %retval1) #13
  store i32 0, ptr %retval1, align 4, !tbaa !5
  %0 = load ptr, ptr @stdout, align 8, !tbaa !9
  %call = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %0, ptr noundef @.str, i64 noundef 4)
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %1, 4
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  br label %for.end

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 4, ptr %res) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [4 x %struct.anon], ptr @test_suite_tests, i64 0, i64 %2
  %func = getelementptr inbounds %struct.anon, ptr %arrayidx, i32 0, i32 0
  %3 = load ptr, ptr %func, align 16, !tbaa !13
  %call2 = call i32 %3()
  store i32 %call2, ptr %res, align 4, !tbaa !5
  %4 = load i32, ptr %res, align 4, !tbaa !5
  %cmp3 = icmp ne i32 %4, 0
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  store i32 1, ptr %retval1, align 4, !tbaa !5
  %5 = load ptr, ptr @stdout, align 8, !tbaa !9
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %add = add i64 %6, 1
  %7 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx4 = getelementptr inbounds [4 x %struct.anon], ptr @test_suite_tests, i64 0, i64 %7
  %name = getelementptr inbounds %struct.anon, ptr %arrayidx4, i32 0, i32 1
  %8 = load ptr, ptr %name, align 8, !tbaa !15
  %call5 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %5, ptr noundef @.str.1, i64 noundef %add, ptr noundef %8)
  br label %if.end

if.else:                                          ; preds = %for.body
  %9 = load ptr, ptr @stdout, align 8, !tbaa !9
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %add6 = add i64 %10, 1
  %11 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx7 = getelementptr inbounds [4 x %struct.anon], ptr @test_suite_tests, i64 0, i64 %11
  %name8 = getelementptr inbounds %struct.anon, ptr %arrayidx7, i32 0, i32 1
  %12 = load ptr, ptr %name8, align 8, !tbaa !15
  %call9 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %9, ptr noundef @.str.2, i64 noundef %add6, ptr noundef %12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  call void @llvm.lifetime.end.p0(i64 4, ptr %res) #13
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %13 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %13, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.end:                                          ; preds = %for.cond.cleanup
  %14 = load i32, ptr %retval1, align 4, !tbaa !5
  call void @llvm.lifetime.end.p0(i64 4, ptr %retval1) #13
  ret i32 %14
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #1

declare i32 @fprintf(ptr noundef, ptr noundef, ...) #2

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #1

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm512_fmadd_ps() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <16 x float>, align 64
  %b = alloca <16 x float>, align 64
  %c = alloca <16 x float>, align 64
  %r = alloca <16 x float>, align 64
  %indirect-arg-temp = alloca <16 x float>, align 64
  %indirect-arg-temp10 = alloca <16 x float>, align 64
  %indirect-arg-temp11 = alloca <16 x float>, align 64
  %indirect-arg-temp18 = alloca <16 x float>, align 64
  %indirect-arg-temp19 = alloca <16 x float>, align 64
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup24

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 64, ptr %a) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.0], ptr @test_simde_mm512_fmadd_ps.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.0, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x float], ptr %a1, i64 0, i64 0
  %call = call <16 x float> @simde_mm512_loadu_ps(ptr noundef %arraydecay)
  store <16 x float> %call, ptr %a, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %b) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.0], ptr @test_simde_mm512_fmadd_ps.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.0, ptr %arrayidx2, i32 0, i32 1
  %arraydecay4 = getelementptr inbounds [16 x float], ptr %b3, i64 0, i64 0
  %call5 = call <16 x float> @simde_mm512_loadu_ps(ptr noundef %arraydecay4)
  store <16 x float> %call5, ptr %b, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %c) #13
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx6 = getelementptr inbounds [8 x %struct.anon.0], ptr @test_simde_mm512_fmadd_ps.test_vec, i64 0, i64 %3
  %c7 = getelementptr inbounds %struct.anon.0, ptr %arrayidx6, i32 0, i32 2
  %arraydecay8 = getelementptr inbounds [16 x float], ptr %c7, i64 0, i64 0
  %call9 = call <16 x float> @simde_mm512_loadu_ps(ptr noundef %arraydecay8)
  store <16 x float> %call9, ptr %c, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  %4 = load <16 x float>, ptr %a, align 64, !tbaa !16
  %5 = load <16 x float>, ptr %b, align 64, !tbaa !16
  %6 = load <16 x float>, ptr %c, align 64, !tbaa !16
  store <16 x float> %4, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <16 x float> %5, ptr %indirect-arg-temp10, align 64, !tbaa !16
  store <16 x float> %6, ptr %indirect-arg-temp11, align 64, !tbaa !16
  %call12 = call <16 x float> @simde_mm512_fmadd_ps(ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp10, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp11)
  store <16 x float> %call12, ptr %r, align 64, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %7 = load <16 x float>, ptr %r, align 64, !tbaa !16
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx13 = getelementptr inbounds [8 x %struct.anon.0], ptr @test_simde_mm512_fmadd_ps.test_vec, i64 0, i64 %8
  %r14 = getelementptr inbounds %struct.anon.0, ptr %arrayidx13, i32 0, i32 3
  %arraydecay15 = getelementptr inbounds [16 x float], ptr %r14, i64 0, i64 0
  %call16 = call <16 x float> @simde_mm512_loadu_ps(ptr noundef %arraydecay15)
  %call17 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  store <16 x float> %7, ptr %indirect-arg-temp18, align 64, !tbaa !16
  store <16 x float> %call16, ptr %indirect-arg-temp19, align 64, !tbaa !16
  %call20 = call i32 @simde_test_x86_assert_equal_f32x16_(ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp18, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp19, float noundef %call17, ptr noundef @.str.7, i32 noundef 177, ptr noundef @.str.8, ptr noundef @.str.9)
  %tobool = icmp ne i32 %call20, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %c) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup24 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %9 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %9, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup24:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest25 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest25, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup24
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup24
  %10 = load i32, ptr %retval, align 4
  ret i32 %10

unreachable:                                      ; preds = %cleanup24
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm512_mask_fmadd_ps() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <16 x float>, align 64
  %b = alloca <16 x float>, align 64
  %c = alloca <16 x float>, align 64
  %r = alloca <16 x float>, align 64
  %indirect-arg-temp = alloca <16 x float>, align 64
  %indirect-arg-temp11 = alloca <16 x float>, align 64
  %indirect-arg-temp12 = alloca <16 x float>, align 64
  %indirect-arg-temp19 = alloca <16 x float>, align 64
  %indirect-arg-temp20 = alloca <16 x float>, align 64
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup25

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 64, ptr %a) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.1], ptr @test_simde_mm512_mask_fmadd_ps.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.1, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x float], ptr %a1, i64 0, i64 0
  %call = call <16 x float> @simde_mm512_loadu_ps(ptr noundef %arraydecay)
  store <16 x float> %call, ptr %a, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %b) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.1], ptr @test_simde_mm512_mask_fmadd_ps.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.1, ptr %arrayidx2, i32 0, i32 2
  %arraydecay4 = getelementptr inbounds [16 x float], ptr %b3, i64 0, i64 0
  %call5 = call <16 x float> @simde_mm512_loadu_ps(ptr noundef %arraydecay4)
  store <16 x float> %call5, ptr %b, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %c) #13
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx6 = getelementptr inbounds [8 x %struct.anon.1], ptr @test_simde_mm512_mask_fmadd_ps.test_vec, i64 0, i64 %3
  %c7 = getelementptr inbounds %struct.anon.1, ptr %arrayidx6, i32 0, i32 3
  %arraydecay8 = getelementptr inbounds [16 x float], ptr %c7, i64 0, i64 0
  %call9 = call <16 x float> @simde_mm512_loadu_ps(ptr noundef %arraydecay8)
  store <16 x float> %call9, ptr %c, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  %4 = load <16 x float>, ptr %a, align 64, !tbaa !16
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx10 = getelementptr inbounds [8 x %struct.anon.1], ptr @test_simde_mm512_mask_fmadd_ps.test_vec, i64 0, i64 %5
  %k = getelementptr inbounds %struct.anon.1, ptr %arrayidx10, i32 0, i32 1
  %6 = load i8, ptr %k, align 4, !tbaa !17
  %conv = zext i8 %6 to i16
  %7 = load <16 x float>, ptr %b, align 64, !tbaa !16
  %8 = load <16 x float>, ptr %c, align 64, !tbaa !16
  store <16 x float> %4, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <16 x float> %7, ptr %indirect-arg-temp11, align 64, !tbaa !16
  store <16 x float> %8, ptr %indirect-arg-temp12, align 64, !tbaa !16
  %call13 = call <16 x float> @simde_mm512_mask_fmadd_ps(ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp, i16 noundef zeroext %conv, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp11, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp12)
  store <16 x float> %call13, ptr %r, align 64, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %9 = load <16 x float>, ptr %r, align 64, !tbaa !16
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx14 = getelementptr inbounds [8 x %struct.anon.1], ptr @test_simde_mm512_mask_fmadd_ps.test_vec, i64 0, i64 %10
  %r15 = getelementptr inbounds %struct.anon.1, ptr %arrayidx14, i32 0, i32 4
  %arraydecay16 = getelementptr inbounds [16 x float], ptr %r15, i64 0, i64 0
  %call17 = call <16 x float> @simde_mm512_loadu_ps(ptr noundef %arraydecay16)
  %call18 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  store <16 x float> %9, ptr %indirect-arg-temp19, align 64, !tbaa !16
  store <16 x float> %call17, ptr %indirect-arg-temp20, align 64, !tbaa !16
  %call21 = call i32 @simde_test_x86_assert_equal_f32x16_(ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp19, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp20, float noundef %call18, ptr noundef @.str.7, i32 noundef 335, ptr noundef @.str.8, ptr noundef @.str.9)
  %tobool = icmp ne i32 %call21, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %c) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup25 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %11 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %11, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup25:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest26 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest26, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup25
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup25
  %12 = load i32, ptr %retval, align 4
  ret i32 %12

unreachable:                                      ; preds = %cleanup25
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm512_maskz_fmadd_ps() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <16 x float>, align 64
  %b = alloca <16 x float>, align 64
  %c = alloca <16 x float>, align 64
  %r = alloca <16 x float>, align 64
  %indirect-arg-temp = alloca <16 x float>, align 64
  %indirect-arg-temp11 = alloca <16 x float>, align 64
  %indirect-arg-temp12 = alloca <16 x float>, align 64
  %indirect-arg-temp19 = alloca <16 x float>, align 64
  %indirect-arg-temp20 = alloca <16 x float>, align 64
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup25

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 64, ptr %a) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.2], ptr @test_simde_mm512_maskz_fmadd_ps.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.2, ptr %arrayidx, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x float], ptr %a1, i64 0, i64 0
  %call = call <16 x float> @simde_mm512_loadu_ps(ptr noundef %arraydecay)
  store <16 x float> %call, ptr %a, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %b) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.2], ptr @test_simde_mm512_maskz_fmadd_ps.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.2, ptr %arrayidx2, i32 0, i32 2
  %arraydecay4 = getelementptr inbounds [16 x float], ptr %b3, i64 0, i64 0
  %call5 = call <16 x float> @simde_mm512_loadu_ps(ptr noundef %arraydecay4)
  store <16 x float> %call5, ptr %b, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %c) #13
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx6 = getelementptr inbounds [8 x %struct.anon.2], ptr @test_simde_mm512_maskz_fmadd_ps.test_vec, i64 0, i64 %3
  %c7 = getelementptr inbounds %struct.anon.2, ptr %arrayidx6, i32 0, i32 3
  %arraydecay8 = getelementptr inbounds [16 x float], ptr %c7, i64 0, i64 0
  %call9 = call <16 x float> @simde_mm512_loadu_ps(ptr noundef %arraydecay8)
  store <16 x float> %call9, ptr %c, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  %4 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx10 = getelementptr inbounds [8 x %struct.anon.2], ptr @test_simde_mm512_maskz_fmadd_ps.test_vec, i64 0, i64 %4
  %k = getelementptr inbounds %struct.anon.2, ptr %arrayidx10, i32 0, i32 0
  %5 = load i16, ptr %k, align 4, !tbaa !19
  %6 = load <16 x float>, ptr %a, align 64, !tbaa !16
  %7 = load <16 x float>, ptr %b, align 64, !tbaa !16
  %8 = load <16 x float>, ptr %c, align 64, !tbaa !16
  store <16 x float> %6, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <16 x float> %7, ptr %indirect-arg-temp11, align 64, !tbaa !16
  store <16 x float> %8, ptr %indirect-arg-temp12, align 64, !tbaa !16
  %call13 = call <16 x float> @simde_mm512_maskz_fmadd_ps(i16 noundef zeroext %5, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp11, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp12)
  store <16 x float> %call13, ptr %r, align 64, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %9 = load <16 x float>, ptr %r, align 64, !tbaa !16
  %10 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx14 = getelementptr inbounds [8 x %struct.anon.2], ptr @test_simde_mm512_maskz_fmadd_ps.test_vec, i64 0, i64 %10
  %r15 = getelementptr inbounds %struct.anon.2, ptr %arrayidx14, i32 0, i32 4
  %arraydecay16 = getelementptr inbounds [16 x float], ptr %r15, i64 0, i64 0
  %call17 = call <16 x float> @simde_mm512_loadu_ps(ptr noundef %arraydecay16)
  %call18 = call float @simde_test_f32_precision_to_slop(i32 noundef 1)
  store <16 x float> %9, ptr %indirect-arg-temp19, align 64, !tbaa !16
  store <16 x float> %call17, ptr %indirect-arg-temp20, align 64, !tbaa !16
  %call21 = call i32 @simde_test_x86_assert_equal_f32x16_(ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp19, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp20, float noundef %call18, ptr noundef @.str.7, i32 noundef 493, ptr noundef @.str.8, ptr noundef @.str.9)
  %tobool = icmp ne i32 %call21, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %c) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup25 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %11 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %11, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup25:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest26 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest26, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup25
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup25
  %12 = load i32, ptr %retval, align 4
  ret i32 %12

unreachable:                                      ; preds = %cleanup25
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @test_simde_mm512_fmadd_pd() #3 {
entry:
  %retval = alloca i32, align 4
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %a = alloca <8 x double>, align 64
  %b = alloca <8 x double>, align 64
  %c = alloca <8 x double>, align 64
  %r = alloca <8 x double>, align 64
  %indirect-arg-temp = alloca <8 x double>, align 64
  %indirect-arg-temp10 = alloca <8 x double>, align 64
  %indirect-arg-temp11 = alloca <8 x double>, align 64
  %indirect-arg-temp18 = alloca <8 x double>, align 64
  %indirect-arg-temp19 = alloca <8 x double>, align 64
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup24

for.body:                                         ; preds = %for.cond
  call void @llvm.lifetime.start.p0(i64 64, ptr %a) #13
  %1 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [8 x %struct.anon.3], ptr @test_simde_mm512_fmadd_pd.test_vec, i64 0, i64 %1
  %a1 = getelementptr inbounds %struct.anon.3, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [8 x double], ptr %a1, i64 0, i64 0
  %call = call <8 x double> @simde_mm512_loadu_pd(ptr noundef %arraydecay)
  store <8 x double> %call, ptr %a, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %b) #13
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx2 = getelementptr inbounds [8 x %struct.anon.3], ptr @test_simde_mm512_fmadd_pd.test_vec, i64 0, i64 %2
  %b3 = getelementptr inbounds %struct.anon.3, ptr %arrayidx2, i32 0, i32 1
  %arraydecay4 = getelementptr inbounds [8 x double], ptr %b3, i64 0, i64 0
  %call5 = call <8 x double> @simde_mm512_loadu_pd(ptr noundef %arraydecay4)
  store <8 x double> %call5, ptr %b, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %c) #13
  %3 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx6 = getelementptr inbounds [8 x %struct.anon.3], ptr @test_simde_mm512_fmadd_pd.test_vec, i64 0, i64 %3
  %c7 = getelementptr inbounds %struct.anon.3, ptr %arrayidx6, i32 0, i32 2
  %arraydecay8 = getelementptr inbounds [8 x double], ptr %c7, i64 0, i64 0
  %call9 = call <8 x double> @simde_mm512_loadu_pd(ptr noundef %arraydecay8)
  store <8 x double> %call9, ptr %c, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  %4 = load <8 x double>, ptr %a, align 64, !tbaa !16
  %5 = load <8 x double>, ptr %b, align 64, !tbaa !16
  %6 = load <8 x double>, ptr %c, align 64, !tbaa !16
  store <8 x double> %4, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <8 x double> %5, ptr %indirect-arg-temp10, align 64, !tbaa !16
  store <8 x double> %6, ptr %indirect-arg-temp11, align 64, !tbaa !16
  %call12 = call <8 x double> @simde_mm512_fmadd_pd(ptr noundef byval(<8 x double>) align 64 %indirect-arg-temp, ptr noundef byval(<8 x double>) align 64 %indirect-arg-temp10, ptr noundef byval(<8 x double>) align 64 %indirect-arg-temp11)
  store <8 x double> %call12, ptr %r, align 64, !tbaa !16
  br label %do.body

do.body:                                          ; preds = %for.body
  %7 = load <8 x double>, ptr %r, align 64, !tbaa !16
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx13 = getelementptr inbounds [8 x %struct.anon.3], ptr @test_simde_mm512_fmadd_pd.test_vec, i64 0, i64 %8
  %r14 = getelementptr inbounds %struct.anon.3, ptr %arrayidx13, i32 0, i32 3
  %arraydecay15 = getelementptr inbounds [8 x double], ptr %r14, i64 0, i64 0
  %call16 = call <8 x double> @simde_mm512_loadu_pd(ptr noundef %arraydecay15)
  %call17 = call double @simde_test_f64_precision_to_slop(i32 noundef 1)
  store <8 x double> %7, ptr %indirect-arg-temp18, align 64, !tbaa !16
  store <8 x double> %call16, ptr %indirect-arg-temp19, align 64, !tbaa !16
  %call20 = call i32 @simde_test_x86_assert_equal_f64x8_(ptr noundef byval(<8 x double>) align 64 %indirect-arg-temp18, ptr noundef byval(<8 x double>) align 64 %indirect-arg-temp19, double noundef %call17, ptr noundef @.str.7, i32 noundef 578, ptr noundef @.str.8, ptr noundef @.str.11)
  %tobool = icmp ne i32 %call20, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.then
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %c) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %b) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %cleanup24 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %9 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %9, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup24:                                        ; preds = %cleanup, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest25 = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest25, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup24
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup24
  %10 = load i32, ptr %retval, align 4
  ret i32 %10

unreachable:                                      ; preds = %cleanup24
  unreachable
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <16 x float> @simde_mm512_loadu_ps(ptr noundef %mem_addr) #4 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %r = alloca <16 x float>, align 64
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  %0 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %r, ptr align 1 %0, i64 64, i1 false)
  %1 = load <16 x float>, ptr %r, align 64, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  ret <16 x float> %1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <16 x float> @simde_mm512_fmadd_ps(ptr noundef byval(<16 x float>) align 64 %0, ptr noundef byval(<16 x float>) align 64 %1, ptr noundef byval(<16 x float>) align 64 %2) #4 {
entry:
  %a.addr = alloca <16 x float>, align 64
  %b.addr = alloca <16 x float>, align 64
  %c.addr = alloca <16 x float>, align 64
  %r_ = alloca %union.simde__m512_private, align 64
  %a_ = alloca %union.simde__m512_private, align 64
  %indirect-arg-temp = alloca <16 x float>, align 64
  %b_ = alloca %union.simde__m512_private, align 64
  %indirect-arg-temp1 = alloca <16 x float>, align 64
  %c_ = alloca %union.simde__m512_private, align 64
  %indirect-arg-temp2 = alloca <16 x float>, align 64
  %i = alloca i64, align 8
  %indirect-arg-temp5 = alloca <8 x float>, align 32
  %indirect-arg-temp6 = alloca <8 x float>, align 32
  %indirect-arg-temp7 = alloca <8 x float>, align 32
  %a = load <16 x float>, ptr %0, align 64, !tbaa !16
  %b = load <16 x float>, ptr %1, align 64, !tbaa !16
  %c = load <16 x float>, ptr %2, align 64, !tbaa !16
  store <16 x float> %a, ptr %a.addr, align 64, !tbaa !16
  store <16 x float> %b, ptr %b.addr, align 64, !tbaa !16
  store <16 x float> %c, ptr %c.addr, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %r_) #13
  call void @llvm.lifetime.start.p0(i64 64, ptr %a_) #13
  %3 = load <16 x float>, ptr %a.addr, align 64, !tbaa !16
  store <16 x float> %3, ptr %indirect-arg-temp, align 64, !tbaa !16
  call void @simde__m512_to_private(ptr sret(%union.simde__m512_private) align 64 %a_, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 64, ptr %b_) #13
  %4 = load <16 x float>, ptr %b.addr, align 64, !tbaa !16
  store <16 x float> %4, ptr %indirect-arg-temp1, align 64, !tbaa !16
  call void @simde__m512_to_private(ptr sret(%union.simde__m512_private) align 64 %b_, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp1)
  call void @llvm.lifetime.start.p0(i64 64, ptr %c_) #13
  %5 = load <16 x float>, ptr %c.addr, align 64, !tbaa !16
  store <16 x float> %5, ptr %indirect-arg-temp2, align 64, !tbaa !16
  call void @simde__m512_to_private(ptr sret(%union.simde__m512_private) align 64 %c_, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %6, 2
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  br label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [2 x <8 x float>], ptr %a_, i64 0, i64 %7
  %8 = load <8 x float>, ptr %arrayidx, align 32, !tbaa !16
  %9 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx3 = getelementptr inbounds [2 x <8 x float>], ptr %b_, i64 0, i64 %9
  %10 = load <8 x float>, ptr %arrayidx3, align 32, !tbaa !16
  %11 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx4 = getelementptr inbounds [2 x <8 x float>], ptr %c_, i64 0, i64 %11
  %12 = load <8 x float>, ptr %arrayidx4, align 32, !tbaa !16
  store <8 x float> %8, ptr %indirect-arg-temp5, align 32, !tbaa !16
  store <8 x float> %10, ptr %indirect-arg-temp6, align 32, !tbaa !16
  store <8 x float> %12, ptr %indirect-arg-temp7, align 32, !tbaa !16
  %call = call <8 x float> @simde_mm256_fmadd_ps(ptr noundef byval(<8 x float>) align 32 %indirect-arg-temp5, ptr noundef byval(<8 x float>) align 32 %indirect-arg-temp6, ptr noundef byval(<8 x float>) align 32 %indirect-arg-temp7)
  %13 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx8 = getelementptr inbounds [2 x <8 x float>], ptr %r_, i64 0, i64 %13
  store <8 x float> %call, ptr %arrayidx8, align 32, !tbaa !16
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %14, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.end:                                          ; preds = %for.cond.cleanup
  %call9 = call <16 x float> @simde__m512_from_private(ptr noundef byval(%union.simde__m512_private) align 64 %r_)
  call void @llvm.lifetime.end.p0(i64 64, ptr %c_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %r_) #13
  ret <16 x float> %call9
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_x86_assert_equal_f32x16_(ptr noundef byval(<16 x float>) align 64 %0, ptr noundef byval(<16 x float>) align 64 %1, float noundef %slop, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %a.addr = alloca <16 x float>, align 64
  %b.addr = alloca <16 x float>, align 64
  %slop.addr = alloca float, align 4
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %a_ = alloca [16 x float], align 16
  %b_ = alloca [16 x float], align 16
  %indirect-arg-temp = alloca <16 x float>, align 64
  %indirect-arg-temp2 = alloca <16 x float>, align 64
  %a = load <16 x float>, ptr %0, align 64, !tbaa !16
  %b = load <16 x float>, ptr %1, align 64, !tbaa !16
  store <16 x float> %a, ptr %a.addr, align 64, !tbaa !16
  store <16 x float> %b, ptr %b.addr, align 64, !tbaa !16
  store float %slop, ptr %slop.addr, align 4, !tbaa !22
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 64, ptr %a_) #13
  call void @llvm.lifetime.start.p0(i64 64, ptr %b_) #13
  %arraydecay = getelementptr inbounds [16 x float], ptr %a_, i64 0, i64 0
  %2 = load <16 x float>, ptr %a.addr, align 64, !tbaa !16
  store <16 x float> %2, ptr %indirect-arg-temp, align 64, !tbaa !16
  call void @simde_mm512_storeu_ps(ptr noundef %arraydecay, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp)
  %arraydecay1 = getelementptr inbounds [16 x float], ptr %b_, i64 0, i64 0
  %3 = load <16 x float>, ptr %b.addr, align 64, !tbaa !16
  store <16 x float> %3, ptr %indirect-arg-temp2, align 64, !tbaa !16
  call void @simde_mm512_storeu_ps(ptr noundef %arraydecay1, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp2)
  %arraydecay3 = getelementptr inbounds [16 x float], ptr %a_, i64 0, i64 0
  %arraydecay4 = getelementptr inbounds [16 x float], ptr %b_, i64 0, i64 0
  %4 = load float, ptr %slop.addr, align 4, !tbaa !22
  %5 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %6 = load i32, ptr %line.addr, align 4, !tbaa !5
  %7 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %8 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %call = call i32 @simde_assert_equal_vf32_(i64 noundef 16, ptr noundef %arraydecay3, ptr noundef %arraydecay4, float noundef %4, ptr noundef %5, i32 noundef %6, ptr noundef %7, ptr noundef %8)
  call void @llvm.lifetime.end.p0(i64 64, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a_) #13
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal float @simde_test_f32_precision_to_slop(i32 noundef %precision) #0 {
entry:
  %precision.addr = alloca i32, align 4
  store i32 %precision, ptr %precision.addr, align 4, !tbaa !5
  %0 = load i32, ptr %precision.addr, align 4, !tbaa !5
  %cmp = icmp eq i32 %0, 2147483647
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load i32, ptr %precision.addr, align 4, !tbaa !5
  %conv2 = sitofp i32 %1 to float
  %fneg = fneg float %conv2
  %call = call float @powf(float noundef 1.000000e+01, float noundef %fneg) #13
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi float [ 0.000000e+00, %cond.true ], [ %call, %cond.false ]
  ret float %cond
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #5

; Function Attrs: alwaysinline nounwind uwtable
define internal void @simde__m512_to_private(ptr noalias sret(%union.simde__m512_private) align 64 %agg.result, ptr noundef byval(<16 x float>) align 64 %0) #6 {
entry:
  %v.addr = alloca <16 x float>, align 64
  %v = load <16 x float>, ptr %0, align 64, !tbaa !16
  store <16 x float> %v, ptr %v.addr, align 64, !tbaa !16
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %agg.result, ptr align 64 %v.addr, i64 64, i1 false)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x float> @simde_mm256_fmadd_ps(ptr noundef byval(<8 x float>) align 32 %0, ptr noundef byval(<8 x float>) align 32 %1, ptr noundef byval(<8 x float>) align 32 %2) #7 {
entry:
  %a.addr = alloca <8 x float>, align 32
  %b.addr = alloca <8 x float>, align 32
  %c.addr = alloca <8 x float>, align 32
  %a_ = alloca %union.simde__m256_private, align 32
  %indirect-arg-temp = alloca <8 x float>, align 32
  %b_ = alloca %union.simde__m256_private, align 32
  %indirect-arg-temp1 = alloca <8 x float>, align 32
  %c_ = alloca %union.simde__m256_private, align 32
  %indirect-arg-temp2 = alloca <8 x float>, align 32
  %r_ = alloca %union.simde__m256_private, align 32
  %i = alloca i64, align 8
  %a = load <8 x float>, ptr %0, align 32, !tbaa !16
  %b = load <8 x float>, ptr %1, align 32, !tbaa !16
  %c = load <8 x float>, ptr %2, align 32, !tbaa !16
  store <8 x float> %a, ptr %a.addr, align 32, !tbaa !16
  store <8 x float> %b, ptr %b.addr, align 32, !tbaa !16
  store <8 x float> %c, ptr %c.addr, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %a_) #13
  %3 = load <8 x float>, ptr %a.addr, align 32, !tbaa !16
  store <8 x float> %3, ptr %indirect-arg-temp, align 32, !tbaa !16
  call void @simde__m256_to_private(ptr sret(%union.simde__m256_private) align 32 %a_, ptr noundef byval(<8 x float>) align 32 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 32, ptr %b_) #13
  %4 = load <8 x float>, ptr %b.addr, align 32, !tbaa !16
  store <8 x float> %4, ptr %indirect-arg-temp1, align 32, !tbaa !16
  call void @simde__m256_to_private(ptr sret(%union.simde__m256_private) align 32 %b_, ptr noundef byval(<8 x float>) align 32 %indirect-arg-temp1)
  call void @llvm.lifetime.start.p0(i64 32, ptr %c_) #13
  %5 = load <8 x float>, ptr %c.addr, align 32, !tbaa !16
  store <8 x float> %5, ptr %indirect-arg-temp2, align 32, !tbaa !16
  call void @simde__m256_to_private(ptr sret(%union.simde__m256_private) align 32 %c_, ptr noundef byval(<8 x float>) align 32 %indirect-arg-temp2)
  call void @llvm.lifetime.start.p0(i64 32, ptr %r_) #13
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %6, 2
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  br label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [2 x <4 x float>], ptr %a_, i64 0, i64 %7
  %8 = load <4 x float>, ptr %arrayidx, align 16, !tbaa !16
  %9 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx3 = getelementptr inbounds [2 x <4 x float>], ptr %b_, i64 0, i64 %9
  %10 = load <4 x float>, ptr %arrayidx3, align 16, !tbaa !16
  %11 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx4 = getelementptr inbounds [2 x <4 x float>], ptr %c_, i64 0, i64 %11
  %12 = load <4 x float>, ptr %arrayidx4, align 16, !tbaa !16
  %call = call <4 x float> @simde_mm_fmadd_ps(<4 x float> noundef %8, <4 x float> noundef %10, <4 x float> noundef %12)
  %13 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx5 = getelementptr inbounds [2 x <4 x float>], ptr %r_, i64 0, i64 %13
  store <4 x float> %call, ptr %arrayidx5, align 16, !tbaa !16
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %14, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.end:                                          ; preds = %for.cond.cleanup
  %call6 = call <8 x float> @simde__m256_from_private(ptr noundef byval(%union.simde__m256_private) align 32 %r_)
  call void @llvm.lifetime.end.p0(i64 32, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %c_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a_) #13
  ret <8 x float> %call6
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <16 x float> @simde__m512_from_private(ptr noundef byval(%union.simde__m512_private) align 64 %v) #4 {
entry:
  %r = alloca <16 x float>, align 64
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %r, ptr align 64 %v, i64 64, i1 false)
  %0 = load <16 x float>, ptr %r, align 64, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  ret <16 x float> %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @simde__m256_to_private(ptr noalias sret(%union.simde__m256_private) align 32 %agg.result, ptr noundef byval(<8 x float>) align 32 %0) #6 {
entry:
  %v.addr = alloca <8 x float>, align 32
  %v = load <8 x float>, ptr %0, align 32, !tbaa !16
  store <8 x float> %v, ptr %v.addr, align 32, !tbaa !16
  call void @llvm.memcpy.p0.p0.i64(ptr align 32 %agg.result, ptr align 32 %v.addr, i64 32, i1 false)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x float> @simde_mm_fmadd_ps(<4 x float> noundef %a, <4 x float> noundef %b, <4 x float> noundef %c) #8 {
entry:
  %a.addr = alloca <4 x float>, align 16
  %b.addr = alloca <4 x float>, align 16
  %c.addr = alloca <4 x float>, align 16
  %a_ = alloca %union.simde__m128_private, align 16
  %b_ = alloca %union.simde__m128_private, align 16
  %c_ = alloca %union.simde__m128_private, align 16
  %r_ = alloca %union.simde__m128_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store <4 x float> %a, ptr %a.addr, align 16, !tbaa !16
  store <4 x float> %b, ptr %b.addr, align 16, !tbaa !16
  store <4 x float> %c, ptr %c.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #13
  %0 = load <4 x float>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128_to_private(<4 x float> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %b_) #13
  %5 = load <4 x float>, ptr %b.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128_to_private(<4 x float> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128_private, ptr %b_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %c_) #13
  %10 = load <4 x float>, ptr %c.addr, align 16, !tbaa !16
  %call3 = call { double, double } @simde__m128_to_private(<4 x float> noundef %10)
  %coerce.dive4 = getelementptr inbounds %union.simde__m128_private, ptr %c_, i32 0, i32 0
  %11 = getelementptr inbounds { double, double }, ptr %coerce.dive4, i32 0, i32 0
  %12 = extractvalue { double, double } %call3, 0
  store double %12, ptr %11, align 16
  %13 = getelementptr inbounds { double, double }, ptr %coerce.dive4, i32 0, i32 1
  %14 = extractvalue { double, double } %call3, 1
  store double %14, ptr %13, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #13
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #13
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %15 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !24
  %cmp = icmp ult i64 %15, 4
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %16 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !24
  %mul = mul i64 %16, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !24
  %17 = load <4 x float>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !24
  %18 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !24
  %vecext = extractelement <4 x float> %17, i64 %18
  %19 = load <4 x float>, ptr %b_, align 16, !tbaa !16, !llvm.access.group !24
  %20 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !24
  %vecext5 = extractelement <4 x float> %19, i64 %20
  %21 = load <4 x float>, ptr %c_, align 16, !tbaa !16, !llvm.access.group !24
  %22 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !24
  %vecext7 = extractelement <4 x float> %21, i64 %22
  %23 = call float @llvm.fmuladd.f32(float %vecext, float %vecext5, float %vecext7)
  %24 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !24
  %25 = load <4 x float>, ptr %r_, align 16, !llvm.access.group !24
  %vecins = insertelement <4 x float> %25, float %23, i64 %24
  store <4 x float> %vecins, ptr %r_, align 16, !llvm.access.group !24
  br label %omp.body.continue

omp.body.continue:                                ; preds = %omp.inner.for.body
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %26 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !24
  %add8 = add i64 %26, 1
  store i64 %add8, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !24
  br label %omp.inner.for.cond, !llvm.loop !25

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 4, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #13
  %27 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %28 = load double, ptr %27, align 16
  %29 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %30 = load double, ptr %29, align 8
  %call9 = call <4 x float> @simde__m128_from_private(double %28, double %30)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %c_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #13
  ret <4 x float> %call9
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x float> @simde__m256_from_private(ptr noundef byval(%union.simde__m256_private) align 32 %v) #7 {
entry:
  %r = alloca <8 x float>, align 32
  call void @llvm.lifetime.start.p0(i64 32, ptr %r) #13
  call void @llvm.memcpy.p0.p0.i64(ptr align 32 %r, ptr align 32 %v, i64 32, i1 false)
  %0 = load <8 x float>, ptr %r, align 32, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 32, ptr %r) #13
  ret <8 x float> %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal { double, double } @simde__m128_to_private(<4 x float> noundef %v) #8 {
entry:
  %retval = alloca %union.simde__m128_private, align 16
  %v.addr = alloca <4 x float>, align 16
  store <4 x float> %v, ptr %v.addr, align 16, !tbaa !16
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %retval, ptr align 16 %v.addr, i64 16, i1 false)
  %coerce.dive = getelementptr inbounds %union.simde__m128_private, ptr %retval, i32 0, i32 0
  %0 = load { double, double }, ptr %coerce.dive, align 16
  ret { double, double } %0
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare float @llvm.fmuladd.f32(float, float, float) #9

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x float> @simde__m128_from_private(double %v.coerce0, double %v.coerce1) #8 {
entry:
  %v = alloca %union.simde__m128_private, align 16
  %r = alloca <4 x float>, align 16
  %0 = getelementptr inbounds { double, double }, ptr %v, i32 0, i32 0
  store double %v.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { double, double }, ptr %v, i32 0, i32 1
  store double %v.coerce1, ptr %1, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #13
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %r, ptr align 16 %v, i64 16, i1 false)
  %2 = load <4 x float>, ptr %r, align 16, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #13
  ret <4 x float> %2
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @simde_mm512_storeu_ps(ptr noundef %mem_addr, ptr noundef byval(<16 x float>) align 64 %0) #6 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %a.addr = alloca <16 x float>, align 64
  %a = load <16 x float>, ptr %0, align 64, !tbaa !16
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  store <16 x float> %a, ptr %a.addr, align 64, !tbaa !16
  %1 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %1, ptr align 64 %a.addr, i64 64, i1 false)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_vf32_(i64 noundef %vec_len, ptr noundef %a, ptr noundef %b, float noundef %slop, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %vec_len.addr = alloca i64, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %slop.addr = alloca float, align 4
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i64 %vec_len, ptr %vec_len.addr, align 8, !tbaa !11
  store ptr %a, ptr %a.addr, align 8, !tbaa !9
  store ptr %b, ptr %b.addr, align 8, !tbaa !9
  store float %slop, ptr %slop.addr, align 4, !tbaa !22
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %1 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %3 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds float, ptr %4, i64 %5
  %6 = load float, ptr %arrayidx, align 4, !tbaa !22
  %7 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx1 = getelementptr inbounds float, ptr %7, i64 %8
  %9 = load float, ptr %arrayidx1, align 4, !tbaa !22
  %10 = load float, ptr %slop.addr, align 4, !tbaa !22
  %call = call i32 @simde_test_equal_f32(float noundef %6, float noundef %9, float noundef %10)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %11 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %12 = load i32, ptr %line.addr, align 4, !tbaa !5
  %13 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %14 = load i64, ptr %i, align 8, !tbaa !11
  %15 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %16 = load i64, ptr %i, align 8, !tbaa !11
  %17 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %18 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx5 = getelementptr inbounds float, ptr %17, i64 %18
  %19 = load float, ptr %arrayidx5, align 4, !tbaa !22
  %conv6 = fpext float %19 to double
  %20 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %21 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx7 = getelementptr inbounds float, ptr %20, i64 %21
  %22 = load float, ptr %arrayidx7, align 4, !tbaa !22
  %conv8 = fpext float %22 to double
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.10, ptr noundef %11, i32 noundef %12, ptr noundef %13, i64 noundef %14, ptr noundef %15, i64 noundef %16, double noundef %conv6, double noundef %conv8)
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %23 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %23, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup
  %24 = load i32, ptr %retval, align 4
  ret i32 %24

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_equal_f32(float noundef %a, float noundef %b, float noundef %slop) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca float, align 4
  %b.addr = alloca float, align 4
  %slop.addr = alloca float, align 4
  %lo = alloca float, align 4
  %hi = alloca float, align 4
  store float %a, ptr %a.addr, align 4, !tbaa !22
  store float %b, ptr %b.addr, align 4, !tbaa !22
  store float %slop, ptr %slop.addr, align 4, !tbaa !22
  %0 = load float, ptr %a.addr, align 4, !tbaa !22
  %1 = call i1 @llvm.is.fpclass.f32(float %0, i32 3)
  br i1 %1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load float, ptr %b.addr, align 4, !tbaa !22
  %3 = call i1 @llvm.is.fpclass.f32(float %2, i32 3)
  %4 = zext i1 %3 to i32
  store i32 %4, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %5 = load float, ptr %a.addr, align 4, !tbaa !22
  %6 = call i1 @llvm.is.fpclass.f32(float %5, i32 516)
  br i1 %6, label %if.then1, label %if.else3

if.then1:                                         ; preds = %if.else
  %7 = load float, ptr %a.addr, align 4, !tbaa !22
  %8 = load float, ptr %b.addr, align 4, !tbaa !22
  %cmp = fcmp olt float %7, %8
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then1
  %9 = load float, ptr %a.addr, align 4, !tbaa !22
  %10 = load float, ptr %b.addr, align 4, !tbaa !22
  %cmp2 = fcmp ogt float %9, %10
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then1
  %11 = phi i1 [ true, %if.then1 ], [ %cmp2, %lor.rhs ]
  %lnot = xor i1 %11, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, ptr %retval, align 4
  br label %return

if.else3:                                         ; preds = %if.else
  %12 = load float, ptr %slop.addr, align 4, !tbaa !22
  %cmp4 = fcmp oeq float %12, 0.000000e+00
  br i1 %cmp4, label %if.then5, label %if.else8

if.then5:                                         ; preds = %if.else3
  %call = call i32 @memcmp(ptr noundef %a.addr, ptr noundef %b.addr, i64 noundef 4) #13
  %tobool = icmp ne i32 %call, 0
  %lnot6 = xor i1 %tobool, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  store i32 %lnot.ext7, ptr %retval, align 4
  br label %return

if.else8:                                         ; preds = %if.else3
  call void @llvm.lifetime.start.p0(i64 4, ptr %lo) #13
  %13 = load float, ptr %a.addr, align 4, !tbaa !22
  %14 = load float, ptr %slop.addr, align 4, !tbaa !22
  %sub = fsub float %13, %14
  store float %sub, ptr %lo, align 4, !tbaa !22
  %15 = load float, ptr %lo, align 4, !tbaa !22
  %16 = load float, ptr %a.addr, align 4, !tbaa !22
  %cmp9 = fcmp oeq float %15, %16
  %lnot10 = xor i1 %cmp9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv = sext i32 %lnot.ext13 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool14 = icmp ne i64 %expval, 0
  br i1 %tobool14, label %if.then15, label %if.end

if.then15:                                        ; preds = %if.else8
  %17 = load float, ptr %a.addr, align 4, !tbaa !22
  %call16 = call float @nextafterf(float noundef %17, float noundef 0xFFF0000000000000) #13
  store float %call16, ptr %lo, align 4, !tbaa !22
  br label %if.end

if.end:                                           ; preds = %if.then15, %if.else8
  call void @llvm.lifetime.start.p0(i64 4, ptr %hi) #13
  %18 = load float, ptr %a.addr, align 4, !tbaa !22
  %19 = load float, ptr %slop.addr, align 4, !tbaa !22
  %add = fadd float %18, %19
  store float %add, ptr %hi, align 4, !tbaa !22
  %20 = load float, ptr %hi, align 4, !tbaa !22
  %21 = load float, ptr %a.addr, align 4, !tbaa !22
  %cmp17 = fcmp oeq float %20, %21
  %lnot19 = xor i1 %cmp17, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %expval24 = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool25 = icmp ne i64 %expval24, 0
  br i1 %tobool25, label %if.then26, label %if.end28

if.then26:                                        ; preds = %if.end
  %22 = load float, ptr %a.addr, align 4, !tbaa !22
  %call27 = call float @nextafterf(float noundef %22, float noundef 0x7FF0000000000000) #13
  store float %call27, ptr %hi, align 4, !tbaa !22
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %if.end
  %23 = load float, ptr %b.addr, align 4, !tbaa !22
  %24 = load float, ptr %lo, align 4, !tbaa !22
  %cmp29 = fcmp oge float %23, %24
  br i1 %cmp29, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end28
  %25 = load float, ptr %b.addr, align 4, !tbaa !22
  %26 = load float, ptr %hi, align 4, !tbaa !22
  %cmp31 = fcmp ole float %25, %26
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end28
  %27 = phi i1 [ false, %if.end28 ], [ %cmp31, %land.rhs ]
  %land.ext = zext i1 %27 to i32
  store i32 %land.ext, ptr %retval, align 4
  call void @llvm.lifetime.end.p0(i64 4, ptr %hi) #13
  call void @llvm.lifetime.end.p0(i64 4, ptr %lo) #13
  br label %return

return:                                           ; preds = %land.end, %if.then5, %lor.end, %if.then
  %28 = load i32, ptr %retval, align 4
  ret i32 %28
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(none)
declare i64 @llvm.expect.i64(i64, i64) #10

; Function Attrs: nounwind uwtable
define internal void @simde_test_debug_printf_(ptr noundef %format, ...) #0 {
entry:
  %format.addr = alloca ptr, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  store ptr %format, ptr %format.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 24, ptr %ap) #13
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_start.p0(ptr %arraydecay)
  %0 = load ptr, ptr @stderr, align 8, !tbaa !9
  %1 = load ptr, ptr %format.addr, align 8, !tbaa !9
  %arraydecay1 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  %call = call i32 @vfprintf(ptr noundef %0, ptr noundef %1, ptr noundef %arraydecay1)
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %ap, i64 0, i64 0
  call void @llvm.va_end.p0(ptr %arraydecay2)
  %2 = load ptr, ptr @stderr, align 8, !tbaa !9
  %call3 = call i32 @fflush(ptr noundef %2)
  call void @llvm.lifetime.end.p0(i64 24, ptr %ap) #13
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i1 @llvm.is.fpclass.f32(float, i32 immarg) #9

; Function Attrs: nounwind
declare i32 @memcmp(ptr noundef, ptr noundef, i64 noundef) #11

; Function Attrs: nounwind
declare float @nextafterf(float noundef, float noundef) #11

declare i32 @vfprintf(ptr noundef, ptr noundef, ptr noundef) #2

declare i32 @fflush(ptr noundef) #2

; Function Attrs: nounwind
declare float @powf(float noundef, float noundef) #11

; Function Attrs: alwaysinline nounwind uwtable
define internal <16 x float> @simde_mm512_mask_fmadd_ps(ptr noundef byval(<16 x float>) align 64 %0, i16 noundef zeroext %k, ptr noundef byval(<16 x float>) align 64 %1, ptr noundef byval(<16 x float>) align 64 %2) #4 {
entry:
  %a.addr = alloca <16 x float>, align 64
  %k.addr = alloca i16, align 2
  %b.addr = alloca <16 x float>, align 64
  %c.addr = alloca <16 x float>, align 64
  %indirect-arg-temp = alloca <16 x float>, align 64
  %indirect-arg-temp1 = alloca <16 x float>, align 64
  %indirect-arg-temp2 = alloca <16 x float>, align 64
  %indirect-arg-temp3 = alloca <16 x float>, align 64
  %indirect-arg-temp4 = alloca <16 x float>, align 64
  %a = load <16 x float>, ptr %0, align 64, !tbaa !16
  %b = load <16 x float>, ptr %1, align 64, !tbaa !16
  %c = load <16 x float>, ptr %2, align 64, !tbaa !16
  store <16 x float> %a, ptr %a.addr, align 64, !tbaa !16
  store i16 %k, ptr %k.addr, align 2, !tbaa !28
  store <16 x float> %b, ptr %b.addr, align 64, !tbaa !16
  store <16 x float> %c, ptr %c.addr, align 64, !tbaa !16
  %3 = load <16 x float>, ptr %a.addr, align 64, !tbaa !16
  %4 = load i16, ptr %k.addr, align 2, !tbaa !28
  %5 = load <16 x float>, ptr %a.addr, align 64, !tbaa !16
  %6 = load <16 x float>, ptr %b.addr, align 64, !tbaa !16
  %7 = load <16 x float>, ptr %c.addr, align 64, !tbaa !16
  store <16 x float> %5, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <16 x float> %6, ptr %indirect-arg-temp1, align 64, !tbaa !16
  store <16 x float> %7, ptr %indirect-arg-temp2, align 64, !tbaa !16
  %call = call <16 x float> @simde_mm512_fmadd_ps(ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp1, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp2)
  store <16 x float> %3, ptr %indirect-arg-temp3, align 64, !tbaa !16
  store <16 x float> %call, ptr %indirect-arg-temp4, align 64, !tbaa !16
  %call5 = call <16 x float> @simde_mm512_mask_mov_ps(ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp3, i16 noundef zeroext %4, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp4)
  ret <16 x float> %call5
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <16 x float> @simde_mm512_mask_mov_ps(ptr noundef byval(<16 x float>) align 64 %0, i16 noundef zeroext %k, ptr noundef byval(<16 x float>) align 64 %1) #4 {
entry:
  %src.addr = alloca <16 x float>, align 64
  %k.addr = alloca i16, align 2
  %a.addr = alloca <16 x float>, align 64
  %indirect-arg-temp = alloca <16 x float>, align 64
  %indirect-arg-temp1 = alloca <16 x float>, align 64
  %indirect-arg-temp3 = alloca <8 x i64>, align 64
  %indirect-arg-temp4 = alloca <8 x i64>, align 64
  %indirect-arg-temp6 = alloca <8 x i64>, align 64
  %src = load <16 x float>, ptr %0, align 64, !tbaa !16
  %a = load <16 x float>, ptr %1, align 64, !tbaa !16
  store <16 x float> %src, ptr %src.addr, align 64, !tbaa !16
  store i16 %k, ptr %k.addr, align 2, !tbaa !28
  store <16 x float> %a, ptr %a.addr, align 64, !tbaa !16
  %2 = load <16 x float>, ptr %src.addr, align 64, !tbaa !16
  store <16 x float> %2, ptr %indirect-arg-temp, align 64, !tbaa !16
  %call = call <8 x i64> @simde_mm512_castps_si512(ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp)
  %3 = load i16, ptr %k.addr, align 2, !tbaa !28
  %4 = load <16 x float>, ptr %a.addr, align 64, !tbaa !16
  store <16 x float> %4, ptr %indirect-arg-temp1, align 64, !tbaa !16
  %call2 = call <8 x i64> @simde_mm512_castps_si512(ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp1)
  store <8 x i64> %call, ptr %indirect-arg-temp3, align 64, !tbaa !16
  store <8 x i64> %call2, ptr %indirect-arg-temp4, align 64, !tbaa !16
  %call5 = call <8 x i64> @simde_mm512_mask_mov_epi32(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp3, i16 noundef zeroext %3, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp4)
  store <8 x i64> %call5, ptr %indirect-arg-temp6, align 64, !tbaa !16
  %call7 = call <16 x float> @simde_mm512_castsi512_ps(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp6)
  ret <16 x float> %call7
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <16 x float> @simde_mm512_castsi512_ps(ptr noundef byval(<8 x i64>) align 64 %0) #4 {
entry:
  %a.addr = alloca <8 x i64>, align 64
  %r = alloca <16 x float>, align 64
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %r, ptr align 64 %a.addr, i64 64, i1 false)
  %1 = load <16 x float>, ptr %r, align 64, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  ret <16 x float> %1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde_mm512_mask_mov_epi32(ptr noundef byval(<8 x i64>) align 64 %0, i16 noundef zeroext %k, ptr noundef byval(<8 x i64>) align 64 %1) #4 {
entry:
  %src.addr = alloca <8 x i64>, align 64
  %k.addr = alloca i16, align 2
  %a.addr = alloca <8 x i64>, align 64
  %src_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %a_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp1 = alloca <8 x i64>, align 64
  %r_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp3 = alloca <4 x i64>, align 32
  %indirect-arg-temp4 = alloca <4 x i64>, align 32
  %indirect-arg-temp10 = alloca <4 x i64>, align 32
  %indirect-arg-temp11 = alloca <4 x i64>, align 32
  %src = load <8 x i64>, ptr %0, align 64, !tbaa !16
  %a = load <8 x i64>, ptr %1, align 64, !tbaa !16
  store <8 x i64> %src, ptr %src.addr, align 64, !tbaa !16
  store i16 %k, ptr %k.addr, align 2, !tbaa !28
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %src_) #13
  %2 = load <8 x i64>, ptr %src.addr, align 64, !tbaa !16
  store <8 x i64> %2, ptr %indirect-arg-temp, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %src_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 64, ptr %a_) #13
  %3 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %3, ptr %indirect-arg-temp1, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %a_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp1)
  call void @llvm.lifetime.start.p0(i64 64, ptr %r_) #13
  %arrayidx = getelementptr inbounds [2 x <4 x i64>], ptr %src_, i64 0, i64 0
  %4 = load <4 x i64>, ptr %arrayidx, align 64, !tbaa !16
  %5 = load i16, ptr %k.addr, align 2, !tbaa !28
  %conv = trunc i16 %5 to i8
  %arrayidx2 = getelementptr inbounds [2 x <4 x i64>], ptr %a_, i64 0, i64 0
  %6 = load <4 x i64>, ptr %arrayidx2, align 64, !tbaa !16
  store <4 x i64> %4, ptr %indirect-arg-temp3, align 32, !tbaa !16
  store <4 x i64> %6, ptr %indirect-arg-temp4, align 32, !tbaa !16
  %call = call <4 x i64> @simde_mm256_mask_mov_epi32(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp3, i8 noundef zeroext %conv, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp4)
  %arrayidx5 = getelementptr inbounds [2 x <4 x i64>], ptr %r_, i64 0, i64 0
  store <4 x i64> %call, ptr %arrayidx5, align 64, !tbaa !16
  %arrayidx6 = getelementptr inbounds [2 x <4 x i64>], ptr %src_, i64 0, i64 1
  %7 = load <4 x i64>, ptr %arrayidx6, align 32, !tbaa !16
  %8 = load i16, ptr %k.addr, align 2, !tbaa !28
  %conv7 = zext i16 %8 to i32
  %shr = ashr i32 %conv7, 8
  %conv8 = trunc i32 %shr to i8
  %arrayidx9 = getelementptr inbounds [2 x <4 x i64>], ptr %a_, i64 0, i64 1
  %9 = load <4 x i64>, ptr %arrayidx9, align 32, !tbaa !16
  store <4 x i64> %7, ptr %indirect-arg-temp10, align 32, !tbaa !16
  store <4 x i64> %9, ptr %indirect-arg-temp11, align 32, !tbaa !16
  %call12 = call <4 x i64> @simde_mm256_mask_mov_epi32(ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp10, i8 noundef zeroext %conv8, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp11)
  %arrayidx13 = getelementptr inbounds [2 x <4 x i64>], ptr %r_, i64 0, i64 1
  store <4 x i64> %call12, ptr %arrayidx13, align 32, !tbaa !16
  %call14 = call <8 x i64> @simde__m512i_from_private(ptr noundef byval(%union.simde__m512i_private) align 64 %r_)
  call void @llvm.lifetime.end.p0(i64 64, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %src_) #13
  ret <8 x i64> %call14
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde_mm512_castps_si512(ptr noundef byval(<16 x float>) align 64 %0) #4 {
entry:
  %a.addr = alloca <16 x float>, align 64
  %r = alloca <8 x i64>, align 64
  %a = load <16 x float>, ptr %0, align 64, !tbaa !16
  store <16 x float> %a, ptr %a.addr, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %r, ptr align 64 %a.addr, i64 64, i1 false)
  %1 = load <8 x i64>, ptr %r, align 64, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  ret <8 x i64> %1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @simde__m512i_to_private(ptr noalias sret(%union.simde__m512i_private) align 64 %agg.result, ptr noundef byval(<8 x i64>) align 64 %0) #6 {
entry:
  %v.addr = alloca <8 x i64>, align 64
  %v = load <8 x i64>, ptr %0, align 64, !tbaa !16
  store <8 x i64> %v, ptr %v.addr, align 64, !tbaa !16
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %agg.result, ptr align 64 %v.addr, i64 64, i1 false)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x i64> @simde_mm256_mask_mov_epi32(ptr noundef byval(<4 x i64>) align 32 %0, i8 noundef zeroext %k, ptr noundef byval(<4 x i64>) align 32 %1) #7 {
entry:
  %src.addr = alloca <4 x i64>, align 32
  %k.addr = alloca i8, align 1
  %a.addr = alloca <4 x i64>, align 32
  %src_ = alloca %union.simde__m256i_private, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %a_ = alloca %union.simde__m256i_private, align 32
  %indirect-arg-temp1 = alloca <4 x i64>, align 32
  %r_ = alloca %union.simde__m256i_private, align 32
  %src = load <4 x i64>, ptr %0, align 32, !tbaa !16
  %a = load <4 x i64>, ptr %1, align 32, !tbaa !16
  store <4 x i64> %src, ptr %src.addr, align 32, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <4 x i64> %a, ptr %a.addr, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %src_) #13
  %2 = load <4 x i64>, ptr %src.addr, align 32, !tbaa !16
  store <4 x i64> %2, ptr %indirect-arg-temp, align 32, !tbaa !16
  call void @simde__m256i_to_private(ptr sret(%union.simde__m256i_private) align 32 %src_, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 32, ptr %a_) #13
  %3 = load <4 x i64>, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %3, ptr %indirect-arg-temp1, align 32, !tbaa !16
  call void @simde__m256i_to_private(ptr sret(%union.simde__m256i_private) align 32 %a_, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp1)
  call void @llvm.lifetime.start.p0(i64 32, ptr %r_) #13
  %arrayidx = getelementptr inbounds [2 x <2 x i64>], ptr %src_, i64 0, i64 0
  %4 = load <2 x i64>, ptr %arrayidx, align 32, !tbaa !16
  %5 = load i8, ptr %k.addr, align 1, !tbaa !16
  %arrayidx2 = getelementptr inbounds [2 x <2 x i64>], ptr %a_, i64 0, i64 0
  %6 = load <2 x i64>, ptr %arrayidx2, align 32, !tbaa !16
  %call = call <2 x i64> @simde_mm_mask_mov_epi32(<2 x i64> noundef %4, i8 noundef zeroext %5, <2 x i64> noundef %6)
  %arrayidx3 = getelementptr inbounds [2 x <2 x i64>], ptr %r_, i64 0, i64 0
  store <2 x i64> %call, ptr %arrayidx3, align 32, !tbaa !16
  %arrayidx4 = getelementptr inbounds [2 x <2 x i64>], ptr %src_, i64 0, i64 1
  %7 = load <2 x i64>, ptr %arrayidx4, align 16, !tbaa !16
  %8 = load i8, ptr %k.addr, align 1, !tbaa !16
  %conv = zext i8 %8 to i32
  %shr = ashr i32 %conv, 4
  %conv5 = trunc i32 %shr to i8
  %arrayidx6 = getelementptr inbounds [2 x <2 x i64>], ptr %a_, i64 0, i64 1
  %9 = load <2 x i64>, ptr %arrayidx6, align 16, !tbaa !16
  %call7 = call <2 x i64> @simde_mm_mask_mov_epi32(<2 x i64> noundef %7, i8 noundef zeroext %conv5, <2 x i64> noundef %9)
  %arrayidx8 = getelementptr inbounds [2 x <2 x i64>], ptr %r_, i64 0, i64 1
  store <2 x i64> %call7, ptr %arrayidx8, align 16, !tbaa !16
  %call9 = call <4 x i64> @simde__m256i_from_private(ptr noundef byval(%union.simde__m256i_private) align 32 %r_)
  call void @llvm.lifetime.end.p0(i64 32, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %src_) #13
  ret <4 x i64> %call9
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde__m512i_from_private(ptr noundef byval(%union.simde__m512i_private) align 64 %v) #4 {
entry:
  %r = alloca <8 x i64>, align 64
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %r, ptr align 64 %v, i64 64, i1 false)
  %0 = load <8 x i64>, ptr %r, align 64, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  ret <8 x i64> %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @simde__m256i_to_private(ptr noalias sret(%union.simde__m256i_private) align 32 %agg.result, ptr noundef byval(<4 x i64>) align 32 %0) #6 {
entry:
  %v.addr = alloca <4 x i64>, align 32
  %v = load <4 x i64>, ptr %0, align 32, !tbaa !16
  store <4 x i64> %v, ptr %v.addr, align 32, !tbaa !16
  call void @llvm.memcpy.p0.p0.i64(ptr align 32 %agg.result, ptr align 32 %v.addr, i64 32, i1 false)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_mask_mov_epi32(<2 x i64> noundef %src, i8 noundef zeroext %k, <2 x i64> noundef %a) #8 {
entry:
  %src.addr = alloca <2 x i64>, align 16
  %k.addr = alloca i8, align 1
  %a.addr = alloca <2 x i64>, align 16
  %src_ = alloca %union.simde__m128i_private, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store <2 x i64> %src, ptr %src.addr, align 16, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %src_) #13
  %0 = load <2 x i64>, ptr %src.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %src_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #13
  %5 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call1 = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %5)
  %coerce.dive2 = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %6 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 0
  %7 = extractvalue { double, double } %call1, 0
  store double %7, ptr %6, align 16
  %8 = getelementptr inbounds { double, double }, ptr %coerce.dive2, i32 0, i32 1
  %9 = extractvalue { double, double } %call1, 1
  store double %9, ptr %8, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #13
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #13
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %10 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !29
  %cmp = icmp ult i64 %10, 4
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %11 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !29
  %mul = mul i64 %11, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !29
  %12 = load i8, ptr %k.addr, align 1, !tbaa !16, !llvm.access.group !29
  %conv = zext i8 %12 to i32
  %13 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !29
  %sh_prom = trunc i64 %13 to i32
  %shr = ashr i32 %conv, %sh_prom
  %and = and i32 %shr, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %omp.inner.for.body
  %14 = load <4 x i32>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !29
  %15 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !29
  %vecext = extractelement <4 x i32> %14, i64 %15
  br label %cond.end

cond.false:                                       ; preds = %omp.inner.for.body
  %16 = load <4 x i32>, ptr %src_, align 16, !tbaa !16, !llvm.access.group !29
  %17 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !29
  %vecext3 = extractelement <4 x i32> %16, i64 %17
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %vecext, %cond.true ], [ %vecext3, %cond.false ]
  %18 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !29
  %19 = load <4 x i32>, ptr %r_, align 16, !llvm.access.group !29
  %vecins = insertelement <4 x i32> %19, i32 %cond, i64 %18
  store <4 x i32> %vecins, ptr %r_, align 16, !llvm.access.group !29
  br label %omp.body.continue

omp.body.continue:                                ; preds = %cond.end
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %20 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !29
  %add4 = add i64 %20, 1
  store i64 %add4, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !29
  br label %omp.inner.for.cond, !llvm.loop !30

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 4, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #13
  %21 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %22 = load double, ptr %21, align 16
  %23 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %24 = load double, ptr %23, align 8
  %call5 = call <2 x i64> @simde__m128i_from_private(double %22, double %24)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %src_) #13
  ret <2 x i64> %call5
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x i64> @simde__m256i_from_private(ptr noundef byval(%union.simde__m256i_private) align 32 %v) #7 {
entry:
  %r = alloca <4 x i64>, align 32
  call void @llvm.lifetime.start.p0(i64 32, ptr %r) #13
  call void @llvm.memcpy.p0.p0.i64(ptr align 32 %r, ptr align 32 %v, i64 32, i1 false)
  %0 = load <4 x i64>, ptr %r, align 32, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 32, ptr %r) #13
  ret <4 x i64> %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal { double, double } @simde__m128i_to_private(<2 x i64> noundef %v) #8 {
entry:
  %retval = alloca %union.simde__m128i_private, align 16
  %v.addr = alloca <2 x i64>, align 16
  store <2 x i64> %v, ptr %v.addr, align 16, !tbaa !16
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %retval, ptr align 16 %v.addr, i64 16, i1 false)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %retval, i32 0, i32 0
  %0 = load { double, double }, ptr %coerce.dive, align 16
  ret { double, double } %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde__m128i_from_private(double %v.coerce0, double %v.coerce1) #8 {
entry:
  %v = alloca %union.simde__m128i_private, align 16
  %r = alloca <2 x i64>, align 16
  %0 = getelementptr inbounds { double, double }, ptr %v, i32 0, i32 0
  store double %v.coerce0, ptr %0, align 16
  %1 = getelementptr inbounds { double, double }, ptr %v, i32 0, i32 1
  store double %v.coerce1, ptr %1, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %r) #13
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %r, ptr align 16 %v, i64 16, i1 false)
  %2 = load <2 x i64>, ptr %r, align 16, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 16, ptr %r) #13
  ret <2 x i64> %2
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <16 x float> @simde_mm512_maskz_fmadd_ps(i16 noundef zeroext %k, ptr noundef byval(<16 x float>) align 64 %0, ptr noundef byval(<16 x float>) align 64 %1, ptr noundef byval(<16 x float>) align 64 %2) #4 {
entry:
  %k.addr = alloca i16, align 2
  %a.addr = alloca <16 x float>, align 64
  %b.addr = alloca <16 x float>, align 64
  %c.addr = alloca <16 x float>, align 64
  %indirect-arg-temp = alloca <16 x float>, align 64
  %indirect-arg-temp1 = alloca <16 x float>, align 64
  %indirect-arg-temp2 = alloca <16 x float>, align 64
  %indirect-arg-temp3 = alloca <16 x float>, align 64
  %a = load <16 x float>, ptr %0, align 64, !tbaa !16
  %b = load <16 x float>, ptr %1, align 64, !tbaa !16
  %c = load <16 x float>, ptr %2, align 64, !tbaa !16
  store i16 %k, ptr %k.addr, align 2, !tbaa !28
  store <16 x float> %a, ptr %a.addr, align 64, !tbaa !16
  store <16 x float> %b, ptr %b.addr, align 64, !tbaa !16
  store <16 x float> %c, ptr %c.addr, align 64, !tbaa !16
  %3 = load i16, ptr %k.addr, align 2, !tbaa !28
  %4 = load <16 x float>, ptr %a.addr, align 64, !tbaa !16
  %5 = load <16 x float>, ptr %b.addr, align 64, !tbaa !16
  %6 = load <16 x float>, ptr %c.addr, align 64, !tbaa !16
  store <16 x float> %4, ptr %indirect-arg-temp, align 64, !tbaa !16
  store <16 x float> %5, ptr %indirect-arg-temp1, align 64, !tbaa !16
  store <16 x float> %6, ptr %indirect-arg-temp2, align 64, !tbaa !16
  %call = call <16 x float> @simde_mm512_fmadd_ps(ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp1, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp2)
  store <16 x float> %call, ptr %indirect-arg-temp3, align 64, !tbaa !16
  %call4 = call <16 x float> @simde_mm512_maskz_mov_ps(i16 noundef zeroext %3, ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp3)
  ret <16 x float> %call4
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <16 x float> @simde_mm512_maskz_mov_ps(i16 noundef zeroext %k, ptr noundef byval(<16 x float>) align 64 %0) #4 {
entry:
  %k.addr = alloca i16, align 2
  %a.addr = alloca <16 x float>, align 64
  %indirect-arg-temp = alloca <16 x float>, align 64
  %indirect-arg-temp1 = alloca <8 x i64>, align 64
  %indirect-arg-temp3 = alloca <8 x i64>, align 64
  %a = load <16 x float>, ptr %0, align 64, !tbaa !16
  store i16 %k, ptr %k.addr, align 2, !tbaa !28
  store <16 x float> %a, ptr %a.addr, align 64, !tbaa !16
  %1 = load i16, ptr %k.addr, align 2, !tbaa !28
  %2 = load <16 x float>, ptr %a.addr, align 64, !tbaa !16
  store <16 x float> %2, ptr %indirect-arg-temp, align 64, !tbaa !16
  %call = call <8 x i64> @simde_mm512_castps_si512(ptr noundef byval(<16 x float>) align 64 %indirect-arg-temp)
  store <8 x i64> %call, ptr %indirect-arg-temp1, align 64, !tbaa !16
  %call2 = call <8 x i64> @simde_mm512_maskz_mov_epi32(i16 noundef zeroext %1, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp1)
  store <8 x i64> %call2, ptr %indirect-arg-temp3, align 64, !tbaa !16
  %call4 = call <16 x float> @simde_mm512_castsi512_ps(ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp3)
  ret <16 x float> %call4
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x i64> @simde_mm512_maskz_mov_epi32(i16 noundef zeroext %k, ptr noundef byval(<8 x i64>) align 64 %0) #4 {
entry:
  %k.addr = alloca i16, align 2
  %a.addr = alloca <8 x i64>, align 64
  %a_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp = alloca <8 x i64>, align 64
  %r_ = alloca %union.simde__m512i_private, align 64
  %indirect-arg-temp1 = alloca <4 x i64>, align 32
  %indirect-arg-temp6 = alloca <4 x i64>, align 32
  %a = load <8 x i64>, ptr %0, align 64, !tbaa !16
  store i16 %k, ptr %k.addr, align 2, !tbaa !28
  store <8 x i64> %a, ptr %a.addr, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %a_) #13
  %1 = load <8 x i64>, ptr %a.addr, align 64, !tbaa !16
  store <8 x i64> %1, ptr %indirect-arg-temp, align 64, !tbaa !16
  call void @simde__m512i_to_private(ptr sret(%union.simde__m512i_private) align 64 %a_, ptr noundef byval(<8 x i64>) align 64 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 64, ptr %r_) #13
  %2 = load i16, ptr %k.addr, align 2, !tbaa !28
  %conv = trunc i16 %2 to i8
  %arrayidx = getelementptr inbounds [2 x <4 x i64>], ptr %a_, i64 0, i64 0
  %3 = load <4 x i64>, ptr %arrayidx, align 64, !tbaa !16
  store <4 x i64> %3, ptr %indirect-arg-temp1, align 32, !tbaa !16
  %call = call <4 x i64> @simde_mm256_maskz_mov_epi32(i8 noundef zeroext %conv, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp1)
  %arrayidx2 = getelementptr inbounds [2 x <4 x i64>], ptr %r_, i64 0, i64 0
  store <4 x i64> %call, ptr %arrayidx2, align 64, !tbaa !16
  %4 = load i16, ptr %k.addr, align 2, !tbaa !28
  %conv3 = zext i16 %4 to i32
  %shr = ashr i32 %conv3, 8
  %conv4 = trunc i32 %shr to i8
  %arrayidx5 = getelementptr inbounds [2 x <4 x i64>], ptr %a_, i64 0, i64 1
  %5 = load <4 x i64>, ptr %arrayidx5, align 32, !tbaa !16
  store <4 x i64> %5, ptr %indirect-arg-temp6, align 32, !tbaa !16
  %call7 = call <4 x i64> @simde_mm256_maskz_mov_epi32(i8 noundef zeroext %conv4, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp6)
  %arrayidx8 = getelementptr inbounds [2 x <4 x i64>], ptr %r_, i64 0, i64 1
  store <4 x i64> %call7, ptr %arrayidx8, align 32, !tbaa !16
  %call9 = call <8 x i64> @simde__m512i_from_private(ptr noundef byval(%union.simde__m512i_private) align 64 %r_)
  call void @llvm.lifetime.end.p0(i64 64, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a_) #13
  ret <8 x i64> %call9
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x i64> @simde_mm256_maskz_mov_epi32(i8 noundef zeroext %k, ptr noundef byval(<4 x i64>) align 32 %0) #7 {
entry:
  %k.addr = alloca i8, align 1
  %a.addr = alloca <4 x i64>, align 32
  %a_ = alloca %union.simde__m256i_private, align 32
  %indirect-arg-temp = alloca <4 x i64>, align 32
  %r_ = alloca %union.simde__m256i_private, align 32
  %a = load <4 x i64>, ptr %0, align 32, !tbaa !16
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <4 x i64> %a, ptr %a.addr, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %a_) #13
  %1 = load <4 x i64>, ptr %a.addr, align 32, !tbaa !16
  store <4 x i64> %1, ptr %indirect-arg-temp, align 32, !tbaa !16
  call void @simde__m256i_to_private(ptr sret(%union.simde__m256i_private) align 32 %a_, ptr noundef byval(<4 x i64>) align 32 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 32, ptr %r_) #13
  %2 = load i8, ptr %k.addr, align 1, !tbaa !16
  %arrayidx = getelementptr inbounds [2 x <2 x i64>], ptr %a_, i64 0, i64 0
  %3 = load <2 x i64>, ptr %arrayidx, align 32, !tbaa !16
  %call = call <2 x i64> @simde_mm_maskz_mov_epi32(i8 noundef zeroext %2, <2 x i64> noundef %3)
  %arrayidx1 = getelementptr inbounds [2 x <2 x i64>], ptr %r_, i64 0, i64 0
  store <2 x i64> %call, ptr %arrayidx1, align 32, !tbaa !16
  %4 = load i8, ptr %k.addr, align 1, !tbaa !16
  %conv = zext i8 %4 to i32
  %shr = ashr i32 %conv, 4
  %conv2 = trunc i32 %shr to i8
  %arrayidx3 = getelementptr inbounds [2 x <2 x i64>], ptr %a_, i64 0, i64 1
  %5 = load <2 x i64>, ptr %arrayidx3, align 16, !tbaa !16
  %call4 = call <2 x i64> @simde_mm_maskz_mov_epi32(i8 noundef zeroext %conv2, <2 x i64> noundef %5)
  %arrayidx5 = getelementptr inbounds [2 x <2 x i64>], ptr %r_, i64 0, i64 1
  store <2 x i64> %call4, ptr %arrayidx5, align 16, !tbaa !16
  %call6 = call <4 x i64> @simde__m256i_from_private(ptr noundef byval(%union.simde__m256i_private) align 32 %r_)
  call void @llvm.lifetime.end.p0(i64 32, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a_) #13
  ret <4 x i64> %call6
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x i64> @simde_mm_maskz_mov_epi32(i8 noundef zeroext %k, <2 x i64> noundef %a) #8 {
entry:
  %k.addr = alloca i8, align 1
  %a.addr = alloca <2 x i64>, align 16
  %a_ = alloca %union.simde__m128i_private, align 16
  %r_ = alloca %union.simde__m128i_private, align 16
  %tmp = alloca i64, align 8
  %.omp.iv = alloca i64, align 8
  %i = alloca i64, align 8
  store i8 %k, ptr %k.addr, align 1, !tbaa !16
  store <2 x i64> %a, ptr %a.addr, align 16, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 16, ptr %a_) #13
  %0 = load <2 x i64>, ptr %a.addr, align 16, !tbaa !16
  %call = call { double, double } @simde__m128i_to_private(<2 x i64> noundef %0)
  %coerce.dive = getelementptr inbounds %union.simde__m128i_private, ptr %a_, i32 0, i32 0
  %1 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { double, double } %call, 0
  store double %2, ptr %1, align 16
  %3 = getelementptr inbounds { double, double }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { double, double } %call, 1
  store double %4, ptr %3, align 8
  call void @llvm.lifetime.start.p0(i64 16, ptr %r_) #13
  call void @llvm.lifetime.start.p0(i64 8, ptr %.omp.iv) #13
  store i64 0, ptr %.omp.iv, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  br label %omp.inner.for.cond

omp.inner.for.cond:                               ; preds = %omp.inner.for.inc, %entry
  %5 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !32
  %cmp = icmp ult i64 %5, 4
  br i1 %cmp, label %omp.inner.for.body, label %omp.inner.for.cond.cleanup

omp.inner.for.cond.cleanup:                       ; preds = %omp.inner.for.cond
  br label %omp.inner.for.end

omp.inner.for.body:                               ; preds = %omp.inner.for.cond
  %6 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !32
  %mul = mul i64 %6, 1
  %add = add i64 0, %mul
  store i64 %add, ptr %i, align 8, !tbaa !11, !llvm.access.group !32
  %7 = load i8, ptr %k.addr, align 1, !tbaa !16, !llvm.access.group !32
  %conv = zext i8 %7 to i32
  %8 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !32
  %sh_prom = trunc i64 %8 to i32
  %shr = ashr i32 %conv, %sh_prom
  %and = and i32 %shr, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %omp.inner.for.body
  %9 = load <4 x i32>, ptr %a_, align 16, !tbaa !16, !llvm.access.group !32
  %10 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !32
  %vecext = extractelement <4 x i32> %9, i64 %10
  br label %cond.end

cond.false:                                       ; preds = %omp.inner.for.body
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %vecext, %cond.true ], [ 0, %cond.false ]
  %11 = load i64, ptr %i, align 8, !tbaa !11, !llvm.access.group !32
  %12 = load <4 x i32>, ptr %r_, align 16, !llvm.access.group !32
  %vecins = insertelement <4 x i32> %12, i32 %cond, i64 %11
  store <4 x i32> %vecins, ptr %r_, align 16, !llvm.access.group !32
  br label %omp.body.continue

omp.body.continue:                                ; preds = %cond.end
  br label %omp.inner.for.inc

omp.inner.for.inc:                                ; preds = %omp.body.continue
  %13 = load i64, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !32
  %add1 = add i64 %13, 1
  store i64 %add1, ptr %.omp.iv, align 8, !tbaa !11, !llvm.access.group !32
  br label %omp.inner.for.cond, !llvm.loop !33

omp.inner.for.end:                                ; preds = %omp.inner.for.cond.cleanup
  store i64 4, ptr %i, align 8, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  call void @llvm.lifetime.end.p0(i64 8, ptr %.omp.iv) #13
  %14 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 0
  %15 = load double, ptr %14, align 16
  %16 = getelementptr inbounds { double, double }, ptr %r_, i32 0, i32 1
  %17 = load double, ptr %16, align 8
  %call2 = call <2 x i64> @simde__m128i_from_private(double %15, double %17)
  call void @llvm.lifetime.end.p0(i64 16, ptr %r_) #13
  call void @llvm.lifetime.end.p0(i64 16, ptr %a_) #13
  ret <2 x i64> %call2
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x double> @simde_mm512_loadu_pd(ptr noundef %mem_addr) #4 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %r = alloca <8 x double>, align 64
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  %0 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %r, ptr align 1 %0, i64 64, i1 false)
  %1 = load <8 x double>, ptr %r, align 64, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  ret <8 x double> %1
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x double> @simde_mm512_fmadd_pd(ptr noundef byval(<8 x double>) align 64 %0, ptr noundef byval(<8 x double>) align 64 %1, ptr noundef byval(<8 x double>) align 64 %2) #4 {
entry:
  %a.addr = alloca <8 x double>, align 64
  %b.addr = alloca <8 x double>, align 64
  %c.addr = alloca <8 x double>, align 64
  %r_ = alloca %union.simde__m512d_private, align 64
  %a_ = alloca %union.simde__m512d_private, align 64
  %indirect-arg-temp = alloca <8 x double>, align 64
  %b_ = alloca %union.simde__m512d_private, align 64
  %indirect-arg-temp1 = alloca <8 x double>, align 64
  %c_ = alloca %union.simde__m512d_private, align 64
  %indirect-arg-temp2 = alloca <8 x double>, align 64
  %i = alloca i64, align 8
  %indirect-arg-temp5 = alloca <4 x double>, align 32
  %indirect-arg-temp6 = alloca <4 x double>, align 32
  %indirect-arg-temp7 = alloca <4 x double>, align 32
  %a = load <8 x double>, ptr %0, align 64, !tbaa !16
  %b = load <8 x double>, ptr %1, align 64, !tbaa !16
  %c = load <8 x double>, ptr %2, align 64, !tbaa !16
  store <8 x double> %a, ptr %a.addr, align 64, !tbaa !16
  store <8 x double> %b, ptr %b.addr, align 64, !tbaa !16
  store <8 x double> %c, ptr %c.addr, align 64, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 64, ptr %r_) #13
  call void @llvm.lifetime.start.p0(i64 64, ptr %a_) #13
  %3 = load <8 x double>, ptr %a.addr, align 64, !tbaa !16
  store <8 x double> %3, ptr %indirect-arg-temp, align 64, !tbaa !16
  call void @simde__m512d_to_private(ptr sret(%union.simde__m512d_private) align 64 %a_, ptr noundef byval(<8 x double>) align 64 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 64, ptr %b_) #13
  %4 = load <8 x double>, ptr %b.addr, align 64, !tbaa !16
  store <8 x double> %4, ptr %indirect-arg-temp1, align 64, !tbaa !16
  call void @simde__m512d_to_private(ptr sret(%union.simde__m512d_private) align 64 %b_, ptr noundef byval(<8 x double>) align 64 %indirect-arg-temp1)
  call void @llvm.lifetime.start.p0(i64 64, ptr %c_) #13
  %5 = load <8 x double>, ptr %c.addr, align 64, !tbaa !16
  store <8 x double> %5, ptr %indirect-arg-temp2, align 64, !tbaa !16
  call void @simde__m512d_to_private(ptr sret(%union.simde__m512d_private) align 64 %c_, ptr noundef byval(<8 x double>) align 64 %indirect-arg-temp2)
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i64, ptr %i, align 8, !tbaa !11
  %cmp = icmp ult i64 %6, 2
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  br label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds [2 x <4 x double>], ptr %a_, i64 0, i64 %7
  %8 = load <4 x double>, ptr %arrayidx, align 32, !tbaa !16
  %9 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx3 = getelementptr inbounds [2 x <4 x double>], ptr %b_, i64 0, i64 %9
  %10 = load <4 x double>, ptr %arrayidx3, align 32, !tbaa !16
  %11 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx4 = getelementptr inbounds [2 x <4 x double>], ptr %c_, i64 0, i64 %11
  %12 = load <4 x double>, ptr %arrayidx4, align 32, !tbaa !16
  store <4 x double> %8, ptr %indirect-arg-temp5, align 32, !tbaa !16
  store <4 x double> %10, ptr %indirect-arg-temp6, align 32, !tbaa !16
  store <4 x double> %12, ptr %indirect-arg-temp7, align 32, !tbaa !16
  %call = call <4 x double> @simde_mm256_fmadd_pd(ptr noundef byval(<4 x double>) align 32 %indirect-arg-temp5, ptr noundef byval(<4 x double>) align 32 %indirect-arg-temp6, ptr noundef byval(<4 x double>) align 32 %indirect-arg-temp7)
  %13 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx8 = getelementptr inbounds [2 x <4 x double>], ptr %r_, i64 0, i64 %13
  store <4 x double> %call, ptr %arrayidx8, align 32, !tbaa !16
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %14, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.end:                                          ; preds = %for.cond.cleanup
  %call9 = call <8 x double> @simde__m512d_from_private(ptr noundef byval(%union.simde__m512d_private) align 64 %r_)
  call void @llvm.lifetime.end.p0(i64 64, ptr %c_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %r_) #13
  ret <8 x double> %call9
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_x86_assert_equal_f64x8_(ptr noundef byval(<8 x double>) align 64 %0, ptr noundef byval(<8 x double>) align 64 %1, double noundef %slop, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %a.addr = alloca <8 x double>, align 64
  %b.addr = alloca <8 x double>, align 64
  %slop.addr = alloca double, align 8
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %a_ = alloca [8 x double], align 16
  %b_ = alloca [8 x double], align 16
  %indirect-arg-temp = alloca <8 x double>, align 64
  %indirect-arg-temp2 = alloca <8 x double>, align 64
  %a = load <8 x double>, ptr %0, align 64, !tbaa !16
  %b = load <8 x double>, ptr %1, align 64, !tbaa !16
  store <8 x double> %a, ptr %a.addr, align 64, !tbaa !16
  store <8 x double> %b, ptr %b.addr, align 64, !tbaa !16
  store double %slop, ptr %slop.addr, align 8, !tbaa !35
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 64, ptr %a_) #13
  call void @llvm.lifetime.start.p0(i64 64, ptr %b_) #13
  %arraydecay = getelementptr inbounds [8 x double], ptr %a_, i64 0, i64 0
  %2 = load <8 x double>, ptr %a.addr, align 64, !tbaa !16
  store <8 x double> %2, ptr %indirect-arg-temp, align 64, !tbaa !16
  call void @simde_mm512_storeu_pd(ptr noundef %arraydecay, ptr noundef byval(<8 x double>) align 64 %indirect-arg-temp)
  %arraydecay1 = getelementptr inbounds [8 x double], ptr %b_, i64 0, i64 0
  %3 = load <8 x double>, ptr %b.addr, align 64, !tbaa !16
  store <8 x double> %3, ptr %indirect-arg-temp2, align 64, !tbaa !16
  call void @simde_mm512_storeu_pd(ptr noundef %arraydecay1, ptr noundef byval(<8 x double>) align 64 %indirect-arg-temp2)
  %arraydecay3 = getelementptr inbounds [8 x double], ptr %a_, i64 0, i64 0
  %arraydecay4 = getelementptr inbounds [8 x double], ptr %b_, i64 0, i64 0
  %4 = load double, ptr %slop.addr, align 8, !tbaa !35
  %5 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %6 = load i32, ptr %line.addr, align 4, !tbaa !5
  %7 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %8 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %call = call i32 @simde_assert_equal_vf64_(i64 noundef 8, ptr noundef %arraydecay3, ptr noundef %arraydecay4, double noundef %4, ptr noundef %5, i32 noundef %6, ptr noundef %7, ptr noundef %8)
  call void @llvm.lifetime.end.p0(i64 64, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 64, ptr %a_) #13
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal double @simde_test_f64_precision_to_slop(i32 noundef %precision) #0 {
entry:
  %precision.addr = alloca i32, align 4
  store i32 %precision, ptr %precision.addr, align 4, !tbaa !5
  %0 = load i32, ptr %precision.addr, align 4, !tbaa !5
  %cmp = icmp eq i32 %0, 2147483647
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load i32, ptr %precision.addr, align 4, !tbaa !5
  %conv2 = sitofp i32 %1 to double
  %fneg = fneg double %conv2
  %call = call double @pow(double noundef 1.000000e+01, double noundef %fneg) #13
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ 0.000000e+00, %cond.true ], [ %call, %cond.false ]
  ret double %cond
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @simde__m512d_to_private(ptr noalias sret(%union.simde__m512d_private) align 64 %agg.result, ptr noundef byval(<8 x double>) align 64 %0) #6 {
entry:
  %v.addr = alloca <8 x double>, align 64
  %v = load <8 x double>, ptr %0, align 64, !tbaa !16
  store <8 x double> %v, ptr %v.addr, align 64, !tbaa !16
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %agg.result, ptr align 64 %v.addr, i64 64, i1 false)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x double> @simde_mm256_fmadd_pd(ptr noundef byval(<4 x double>) align 32 %0, ptr noundef byval(<4 x double>) align 32 %1, ptr noundef byval(<4 x double>) align 32 %2) #7 {
entry:
  %a.addr = alloca <4 x double>, align 32
  %b.addr = alloca <4 x double>, align 32
  %c.addr = alloca <4 x double>, align 32
  %indirect-arg-temp = alloca <4 x double>, align 32
  %indirect-arg-temp1 = alloca <4 x double>, align 32
  %indirect-arg-temp2 = alloca <4 x double>, align 32
  %indirect-arg-temp3 = alloca <4 x double>, align 32
  %a = load <4 x double>, ptr %0, align 32, !tbaa !16
  %b = load <4 x double>, ptr %1, align 32, !tbaa !16
  %c = load <4 x double>, ptr %2, align 32, !tbaa !16
  store <4 x double> %a, ptr %a.addr, align 32, !tbaa !16
  store <4 x double> %b, ptr %b.addr, align 32, !tbaa !16
  store <4 x double> %c, ptr %c.addr, align 32, !tbaa !16
  %3 = load <4 x double>, ptr %a.addr, align 32, !tbaa !16
  %4 = load <4 x double>, ptr %b.addr, align 32, !tbaa !16
  store <4 x double> %3, ptr %indirect-arg-temp, align 32, !tbaa !16
  store <4 x double> %4, ptr %indirect-arg-temp1, align 32, !tbaa !16
  %call = call <4 x double> @simde_mm256_mul_pd(ptr noundef byval(<4 x double>) align 32 %indirect-arg-temp, ptr noundef byval(<4 x double>) align 32 %indirect-arg-temp1)
  %5 = load <4 x double>, ptr %c.addr, align 32, !tbaa !16
  store <4 x double> %call, ptr %indirect-arg-temp2, align 32, !tbaa !16
  store <4 x double> %5, ptr %indirect-arg-temp3, align 32, !tbaa !16
  %call4 = call <4 x double> @simde_mm256_add_pd(ptr noundef byval(<4 x double>) align 32 %indirect-arg-temp2, ptr noundef byval(<4 x double>) align 32 %indirect-arg-temp3)
  ret <4 x double> %call4
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <8 x double> @simde__m512d_from_private(ptr noundef byval(%union.simde__m512d_private) align 64 %v) #4 {
entry:
  %r = alloca <8 x double>, align 64
  call void @llvm.lifetime.start.p0(i64 64, ptr %r) #13
  call void @llvm.memcpy.p0.p0.i64(ptr align 64 %r, ptr align 64 %v, i64 64, i1 false)
  %0 = load <8 x double>, ptr %r, align 64, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 64, ptr %r) #13
  ret <8 x double> %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x double> @simde_mm256_add_pd(ptr noundef byval(<4 x double>) align 32 %0, ptr noundef byval(<4 x double>) align 32 %1) #7 {
entry:
  %a.addr = alloca <4 x double>, align 32
  %b.addr = alloca <4 x double>, align 32
  %r_ = alloca %union.simde__m256d_private, align 32
  %a_ = alloca %union.simde__m256d_private, align 32
  %indirect-arg-temp = alloca <4 x double>, align 32
  %b_ = alloca %union.simde__m256d_private, align 32
  %indirect-arg-temp1 = alloca <4 x double>, align 32
  %a = load <4 x double>, ptr %0, align 32, !tbaa !16
  %b = load <4 x double>, ptr %1, align 32, !tbaa !16
  store <4 x double> %a, ptr %a.addr, align 32, !tbaa !16
  store <4 x double> %b, ptr %b.addr, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %r_) #13
  call void @llvm.lifetime.start.p0(i64 32, ptr %a_) #13
  %2 = load <4 x double>, ptr %a.addr, align 32, !tbaa !16
  store <4 x double> %2, ptr %indirect-arg-temp, align 32, !tbaa !16
  call void @simde__m256d_to_private(ptr sret(%union.simde__m256d_private) align 32 %a_, ptr noundef byval(<4 x double>) align 32 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 32, ptr %b_) #13
  %3 = load <4 x double>, ptr %b.addr, align 32, !tbaa !16
  store <4 x double> %3, ptr %indirect-arg-temp1, align 32, !tbaa !16
  call void @simde__m256d_to_private(ptr sret(%union.simde__m256d_private) align 32 %b_, ptr noundef byval(<4 x double>) align 32 %indirect-arg-temp1)
  %arrayidx = getelementptr inbounds [2 x <2 x double>], ptr %a_, i64 0, i64 0
  %4 = load <2 x double>, ptr %arrayidx, align 32, !tbaa !16
  %arrayidx2 = getelementptr inbounds [2 x <2 x double>], ptr %b_, i64 0, i64 0
  %5 = load <2 x double>, ptr %arrayidx2, align 32, !tbaa !16
  %call = call <2 x double> @simde_mm_add_pd(<2 x double> noundef %4, <2 x double> noundef %5)
  %arrayidx3 = getelementptr inbounds [2 x <2 x double>], ptr %r_, i64 0, i64 0
  store <2 x double> %call, ptr %arrayidx3, align 32, !tbaa !16
  %arrayidx4 = getelementptr inbounds [2 x <2 x double>], ptr %a_, i64 0, i64 1
  %6 = load <2 x double>, ptr %arrayidx4, align 16, !tbaa !16
  %arrayidx5 = getelementptr inbounds [2 x <2 x double>], ptr %b_, i64 0, i64 1
  %7 = load <2 x double>, ptr %arrayidx5, align 16, !tbaa !16
  %call6 = call <2 x double> @simde_mm_add_pd(<2 x double> noundef %6, <2 x double> noundef %7)
  %arrayidx7 = getelementptr inbounds [2 x <2 x double>], ptr %r_, i64 0, i64 1
  store <2 x double> %call6, ptr %arrayidx7, align 16, !tbaa !16
  %call8 = call <4 x double> @simde__m256d_from_private(ptr noundef byval(%union.simde__m256d_private) align 32 %r_)
  call void @llvm.lifetime.end.p0(i64 32, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %r_) #13
  ret <4 x double> %call8
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x double> @simde_mm256_mul_pd(ptr noundef byval(<4 x double>) align 32 %0, ptr noundef byval(<4 x double>) align 32 %1) #7 {
entry:
  %a.addr = alloca <4 x double>, align 32
  %b.addr = alloca <4 x double>, align 32
  %r_ = alloca %union.simde__m256d_private, align 32
  %a_ = alloca %union.simde__m256d_private, align 32
  %indirect-arg-temp = alloca <4 x double>, align 32
  %b_ = alloca %union.simde__m256d_private, align 32
  %indirect-arg-temp1 = alloca <4 x double>, align 32
  %a = load <4 x double>, ptr %0, align 32, !tbaa !16
  %b = load <4 x double>, ptr %1, align 32, !tbaa !16
  store <4 x double> %a, ptr %a.addr, align 32, !tbaa !16
  store <4 x double> %b, ptr %b.addr, align 32, !tbaa !16
  call void @llvm.lifetime.start.p0(i64 32, ptr %r_) #13
  call void @llvm.lifetime.start.p0(i64 32, ptr %a_) #13
  %2 = load <4 x double>, ptr %a.addr, align 32, !tbaa !16
  store <4 x double> %2, ptr %indirect-arg-temp, align 32, !tbaa !16
  call void @simde__m256d_to_private(ptr sret(%union.simde__m256d_private) align 32 %a_, ptr noundef byval(<4 x double>) align 32 %indirect-arg-temp)
  call void @llvm.lifetime.start.p0(i64 32, ptr %b_) #13
  %3 = load <4 x double>, ptr %b.addr, align 32, !tbaa !16
  store <4 x double> %3, ptr %indirect-arg-temp1, align 32, !tbaa !16
  call void @simde__m256d_to_private(ptr sret(%union.simde__m256d_private) align 32 %b_, ptr noundef byval(<4 x double>) align 32 %indirect-arg-temp1)
  %arrayidx = getelementptr inbounds [2 x <2 x double>], ptr %a_, i64 0, i64 0
  %4 = load <2 x double>, ptr %arrayidx, align 32, !tbaa !16
  %arrayidx2 = getelementptr inbounds [2 x <2 x double>], ptr %b_, i64 0, i64 0
  %5 = load <2 x double>, ptr %arrayidx2, align 32, !tbaa !16
  %call = call <2 x double> @simde_mm_mul_pd(<2 x double> noundef %4, <2 x double> noundef %5)
  %arrayidx3 = getelementptr inbounds [2 x <2 x double>], ptr %r_, i64 0, i64 0
  store <2 x double> %call, ptr %arrayidx3, align 32, !tbaa !16
  %arrayidx4 = getelementptr inbounds [2 x <2 x double>], ptr %a_, i64 0, i64 1
  %6 = load <2 x double>, ptr %arrayidx4, align 16, !tbaa !16
  %arrayidx5 = getelementptr inbounds [2 x <2 x double>], ptr %b_, i64 0, i64 1
  %7 = load <2 x double>, ptr %arrayidx5, align 16, !tbaa !16
  %call6 = call <2 x double> @simde_mm_mul_pd(<2 x double> noundef %6, <2 x double> noundef %7)
  %arrayidx7 = getelementptr inbounds [2 x <2 x double>], ptr %r_, i64 0, i64 1
  store <2 x double> %call6, ptr %arrayidx7, align 16, !tbaa !16
  %call8 = call <4 x double> @simde__m256d_from_private(ptr noundef byval(%union.simde__m256d_private) align 32 %r_)
  call void @llvm.lifetime.end.p0(i64 32, ptr %b_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %a_) #13
  call void @llvm.lifetime.end.p0(i64 32, ptr %r_) #13
  ret <4 x double> %call8
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @simde__m256d_to_private(ptr noalias sret(%union.simde__m256d_private) align 32 %agg.result, ptr noundef byval(<4 x double>) align 32 %0) #6 {
entry:
  %v.addr = alloca <4 x double>, align 32
  %v = load <4 x double>, ptr %0, align 32, !tbaa !16
  store <4 x double> %v, ptr %v.addr, align 32, !tbaa !16
  call void @llvm.memcpy.p0.p0.i64(ptr align 32 %agg.result, ptr align 32 %v.addr, i64 32, i1 false)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x double> @simde_mm_add_pd(<2 x double> noundef %a, <2 x double> noundef %b) #8 {
entry:
  %a.addr = alloca <2 x double>, align 16
  %b.addr = alloca <2 x double>, align 16
  store <2 x double> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x double> %b, ptr %b.addr, align 16, !tbaa !16
  %0 = load <2 x double>, ptr %a.addr, align 16, !tbaa !16
  %1 = load <2 x double>, ptr %b.addr, align 16, !tbaa !16
  %call = call <2 x double> @_mm_add_pd(<2 x double> noundef %0, <2 x double> noundef %1)
  ret <2 x double> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <4 x double> @simde__m256d_from_private(ptr noundef byval(%union.simde__m256d_private) align 32 %v) #7 {
entry:
  %r = alloca <4 x double>, align 32
  call void @llvm.lifetime.start.p0(i64 32, ptr %r) #13
  call void @llvm.memcpy.p0.p0.i64(ptr align 32 %r, ptr align 32 %v, i64 32, i1 false)
  %0 = load <4 x double>, ptr %r, align 32, !tbaa !16
  call void @llvm.lifetime.end.p0(i64 32, ptr %r) #13
  ret <4 x double> %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x double> @_mm_add_pd(<2 x double> noundef %__a, <2 x double> noundef %__b) #8 {
entry:
  %__a.addr = alloca <2 x double>, align 16
  %__b.addr = alloca <2 x double>, align 16
  store <2 x double> %__a, ptr %__a.addr, align 16, !tbaa !16
  store <2 x double> %__b, ptr %__b.addr, align 16, !tbaa !16
  %0 = load <2 x double>, ptr %__a.addr, align 16, !tbaa !16
  %1 = load <2 x double>, ptr %__b.addr, align 16, !tbaa !16
  %add = fadd <2 x double> %0, %1
  ret <2 x double> %add
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x double> @simde_mm_mul_pd(<2 x double> noundef %a, <2 x double> noundef %b) #8 {
entry:
  %a.addr = alloca <2 x double>, align 16
  %b.addr = alloca <2 x double>, align 16
  store <2 x double> %a, ptr %a.addr, align 16, !tbaa !16
  store <2 x double> %b, ptr %b.addr, align 16, !tbaa !16
  %0 = load <2 x double>, ptr %a.addr, align 16, !tbaa !16
  %1 = load <2 x double>, ptr %b.addr, align 16, !tbaa !16
  %call = call <2 x double> @_mm_mul_pd(<2 x double> noundef %0, <2 x double> noundef %1)
  ret <2 x double> %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal <2 x double> @_mm_mul_pd(<2 x double> noundef %__a, <2 x double> noundef %__b) #8 {
entry:
  %__a.addr = alloca <2 x double>, align 16
  %__b.addr = alloca <2 x double>, align 16
  store <2 x double> %__a, ptr %__a.addr, align 16, !tbaa !16
  store <2 x double> %__b, ptr %__b.addr, align 16, !tbaa !16
  %0 = load <2 x double>, ptr %__a.addr, align 16, !tbaa !16
  %1 = load <2 x double>, ptr %__b.addr, align 16, !tbaa !16
  %mul = fmul <2 x double> %0, %1
  ret <2 x double> %mul
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @simde_mm512_storeu_pd(ptr noundef %mem_addr, ptr noundef byval(<8 x double>) align 64 %0) #6 {
entry:
  %mem_addr.addr = alloca ptr, align 8
  %a.addr = alloca <8 x double>, align 64
  %a = load <8 x double>, ptr %0, align 64, !tbaa !16
  store ptr %mem_addr, ptr %mem_addr.addr, align 8, !tbaa !9
  store <8 x double> %a, ptr %a.addr, align 64, !tbaa !16
  %1 = load ptr, ptr %mem_addr.addr, align 8, !tbaa !9
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %1, ptr align 64 %a.addr, i64 64, i1 false)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_assert_equal_vf64_(i64 noundef %vec_len, ptr noundef %a, ptr noundef %b, double noundef %slop, ptr noundef %filename, i32 noundef %line, ptr noundef %astr, ptr noundef %bstr) #0 {
entry:
  %retval = alloca i32, align 4
  %vec_len.addr = alloca i64, align 8
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %slop.addr = alloca double, align 8
  %filename.addr = alloca ptr, align 8
  %line.addr = alloca i32, align 4
  %astr.addr = alloca ptr, align 8
  %bstr.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store i64 %vec_len, ptr %vec_len.addr, align 8, !tbaa !11
  store ptr %a, ptr %a.addr, align 8, !tbaa !9
  store ptr %b, ptr %b.addr, align 8, !tbaa !9
  store double %slop, ptr %slop.addr, align 8, !tbaa !35
  store ptr %filename, ptr %filename.addr, align 8, !tbaa !9
  store i32 %line, ptr %line.addr, align 4, !tbaa !5
  store ptr %astr, ptr %astr.addr, align 8, !tbaa !9
  store ptr %bstr, ptr %bstr.addr, align 8, !tbaa !9
  %0 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %1 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 8, ptr %i) #13
  store i64 0, ptr %i, align 8, !tbaa !11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %i, align 8, !tbaa !11
  %3 = load i64, ptr %vec_len.addr, align 8, !tbaa !11
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond
  store i32 2, ptr %cleanup.dest.slot, align 4
  br label %cleanup

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %5 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx = getelementptr inbounds double, ptr %4, i64 %5
  %6 = load double, ptr %arrayidx, align 8, !tbaa !35
  %7 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %8 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx1 = getelementptr inbounds double, ptr %7, i64 %8
  %9 = load double, ptr %arrayidx1, align 8, !tbaa !35
  %10 = load double, ptr %slop.addr, align 8, !tbaa !35
  %call = call i32 @simde_test_equal_f64(double noundef %6, double noundef %9, double noundef %10)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %11 = load ptr, ptr %filename.addr, align 8, !tbaa !9
  %12 = load i32, ptr %line.addr, align 4, !tbaa !5
  %13 = load ptr, ptr %astr.addr, align 8, !tbaa !9
  %14 = load i64, ptr %i, align 8, !tbaa !11
  %15 = load ptr, ptr %bstr.addr, align 8, !tbaa !9
  %16 = load i64, ptr %i, align 8, !tbaa !11
  %17 = load ptr, ptr %a.addr, align 8, !tbaa !9
  %18 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx5 = getelementptr inbounds double, ptr %17, i64 %18
  %19 = load double, ptr %arrayidx5, align 8, !tbaa !35
  %20 = load ptr, ptr %b.addr, align 8, !tbaa !9
  %21 = load i64, ptr %i, align 8, !tbaa !11
  %arrayidx6 = getelementptr inbounds double, ptr %20, i64 %21
  %22 = load double, ptr %arrayidx6, align 8, !tbaa !35
  call void (ptr, ...) @simde_test_debug_printf_(ptr noundef @.str.10, ptr noundef %11, i32 noundef %12, ptr noundef %13, i64 noundef %14, ptr noundef %15, i64 noundef %16, double noundef %19, double noundef %22)
  store i32 1, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %23 = load i64, ptr %i, align 8, !tbaa !11
  %inc = add i64 %23, 1
  store i64 %inc, ptr %i, align 8, !tbaa !11
  br label %for.cond

cleanup:                                          ; preds = %if.then, %for.cond.cleanup
  call void @llvm.lifetime.end.p0(i64 8, ptr %i) #13
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 2, label %for.end
    i32 1, label %return
  ]

for.end:                                          ; preds = %cleanup
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %cleanup
  %24 = load i32, ptr %retval, align 4
  ret i32 %24

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @simde_test_equal_f64(double noundef %a, double noundef %b, double noundef %slop) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca double, align 8
  %b.addr = alloca double, align 8
  %slop.addr = alloca double, align 8
  %lo = alloca double, align 8
  %hi = alloca double, align 8
  store double %a, ptr %a.addr, align 8, !tbaa !35
  store double %b, ptr %b.addr, align 8, !tbaa !35
  store double %slop, ptr %slop.addr, align 8, !tbaa !35
  %0 = load double, ptr %a.addr, align 8, !tbaa !35
  %1 = call i1 @llvm.is.fpclass.f64(double %0, i32 3)
  br i1 %1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load double, ptr %b.addr, align 8, !tbaa !35
  %3 = call i1 @llvm.is.fpclass.f64(double %2, i32 3)
  %4 = zext i1 %3 to i32
  store i32 %4, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %5 = load double, ptr %a.addr, align 8, !tbaa !35
  %6 = call i1 @llvm.is.fpclass.f64(double %5, i32 516)
  br i1 %6, label %if.then1, label %if.else3

if.then1:                                         ; preds = %if.else
  %7 = load double, ptr %a.addr, align 8, !tbaa !35
  %8 = load double, ptr %b.addr, align 8, !tbaa !35
  %cmp = fcmp olt double %7, %8
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then1
  %9 = load double, ptr %a.addr, align 8, !tbaa !35
  %10 = load double, ptr %b.addr, align 8, !tbaa !35
  %cmp2 = fcmp ogt double %9, %10
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then1
  %11 = phi i1 [ true, %if.then1 ], [ %cmp2, %lor.rhs ]
  %lnot = xor i1 %11, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, ptr %retval, align 4
  br label %return

if.else3:                                         ; preds = %if.else
  %12 = load double, ptr %slop.addr, align 8, !tbaa !35
  %cmp4 = fcmp oeq double %12, 0.000000e+00
  br i1 %cmp4, label %if.then5, label %if.else8

if.then5:                                         ; preds = %if.else3
  %call = call i32 @memcmp(ptr noundef %a.addr, ptr noundef %b.addr, i64 noundef 8) #13
  %tobool = icmp ne i32 %call, 0
  %lnot6 = xor i1 %tobool, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  store i32 %lnot.ext7, ptr %retval, align 4
  br label %return

if.else8:                                         ; preds = %if.else3
  call void @llvm.lifetime.start.p0(i64 8, ptr %lo) #13
  %13 = load double, ptr %a.addr, align 8, !tbaa !35
  %14 = load double, ptr %slop.addr, align 8, !tbaa !35
  %sub = fsub double %13, %14
  store double %sub, ptr %lo, align 8, !tbaa !35
  %15 = load double, ptr %lo, align 8, !tbaa !35
  %16 = load double, ptr %a.addr, align 8, !tbaa !35
  %cmp9 = fcmp oeq double %15, %16
  %lnot10 = xor i1 %cmp9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv = sext i32 %lnot.ext13 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool14 = icmp ne i64 %expval, 0
  br i1 %tobool14, label %if.then15, label %if.end

if.then15:                                        ; preds = %if.else8
  %17 = load double, ptr %a.addr, align 8, !tbaa !35
  %call16 = call double @nextafter(double noundef %17, double noundef 0xFFF0000000000000) #13
  store double %call16, ptr %lo, align 8, !tbaa !35
  br label %if.end

if.end:                                           ; preds = %if.then15, %if.else8
  call void @llvm.lifetime.start.p0(i64 8, ptr %hi) #13
  %18 = load double, ptr %a.addr, align 8, !tbaa !35
  %19 = load double, ptr %slop.addr, align 8, !tbaa !35
  %add = fadd double %18, %19
  store double %add, ptr %hi, align 8, !tbaa !35
  %20 = load double, ptr %hi, align 8, !tbaa !35
  %21 = load double, ptr %a.addr, align 8, !tbaa !35
  %cmp17 = fcmp oeq double %20, %21
  %lnot19 = xor i1 %cmp17, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %expval24 = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool25 = icmp ne i64 %expval24, 0
  br i1 %tobool25, label %if.then26, label %if.end28

if.then26:                                        ; preds = %if.end
  %22 = load double, ptr %a.addr, align 8, !tbaa !35
  %call27 = call double @nextafter(double noundef %22, double noundef 0x7FF0000000000000) #13
  store double %call27, ptr %hi, align 8, !tbaa !35
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %if.end
  %23 = load double, ptr %b.addr, align 8, !tbaa !35
  %24 = load double, ptr %lo, align 8, !tbaa !35
  %cmp29 = fcmp oge double %23, %24
  br i1 %cmp29, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end28
  %25 = load double, ptr %b.addr, align 8, !tbaa !35
  %26 = load double, ptr %hi, align 8, !tbaa !35
  %cmp31 = fcmp ole double %25, %26
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end28
  %27 = phi i1 [ false, %if.end28 ], [ %cmp31, %land.rhs ]
  %land.ext = zext i1 %27 to i32
  store i32 %land.ext, ptr %retval, align 4
  call void @llvm.lifetime.end.p0(i64 8, ptr %hi) #13
  call void @llvm.lifetime.end.p0(i64 8, ptr %lo) #13
  br label %return

return:                                           ; preds = %land.end, %if.then5, %lor.end, %if.then
  %28 = load i32, ptr %retval, align 4
  ret i32 %28
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i1 @llvm.is.fpclass.f64(double, i32 immarg) #9

; Function Attrs: nounwind
declare double @nextafter(double noundef, double noundef) #11

; Function Attrs: nounwind
declare double @pow(double noundef, double noundef) #11

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_start.p0(ptr) #12

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_end.p0(ptr) #12

attributes #0 = { nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nounwind uwtable "min-legal-vector-width"="512" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { alwaysinline nounwind uwtable "min-legal-vector-width"="512" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #6 = { alwaysinline nounwind uwtable "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { alwaysinline nounwind uwtable "min-legal-vector-width"="256" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { alwaysinline nounwind uwtable "min-legal-vector-width"="128" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #9 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #10 = { nocallback nofree nosync nounwind willreturn memory(none) }
attributes #11 = { nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #12 = { nocallback nofree nosync nounwind willreturn }
attributes #13 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}
!llvm.ident = !{!4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{!"clang version 18.0.0 (https://github.com/llvm-ml/llvm-project b452eb491a2ae09c12cc88b715f003377cec543b)"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C/C++ TBAA"}
!9 = !{!10, !10, i64 0}
!10 = !{!"any pointer", !7, i64 0}
!11 = !{!12, !12, i64 0}
!12 = !{!"long", !7, i64 0}
!13 = !{!14, !10, i64 0}
!14 = !{!"", !10, i64 0, !10, i64 8}
!15 = !{!14, !10, i64 8}
!16 = !{!7, !7, i64 0}
!17 = !{!18, !7, i64 64}
!18 = !{!"", !7, i64 0, !7, i64 64, !7, i64 68, !7, i64 132, !7, i64 196}
!19 = !{!20, !21, i64 0}
!20 = !{!"", !21, i64 0, !7, i64 4, !7, i64 68, !7, i64 132, !7, i64 196}
!21 = !{!"short", !7, i64 0}
!22 = !{!23, !23, i64 0}
!23 = !{!"float", !7, i64 0}
!24 = distinct !{}
!25 = distinct !{!25, !26, !27}
!26 = !{!"llvm.loop.parallel_accesses", !24}
!27 = !{!"llvm.loop.vectorize.enable", i1 true}
!28 = !{!21, !21, i64 0}
!29 = distinct !{}
!30 = distinct !{!30, !31, !27}
!31 = !{!"llvm.loop.parallel_accesses", !29}
!32 = distinct !{}
!33 = distinct !{!33, !34, !27}
!34 = !{!"llvm.loop.parallel_accesses", !32}
!35 = !{!36, !36, i64 0}
!36 = !{!"double", !7, i64 0}
